---
title: PLT表
created: 2022-09-07 19:10:50
updated: 2022-09-08 16:47:27
tags: 
- atom
---
# PLT表

> [深入理解GOT表和PLT表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/130271689)

PLT（Procedure Linkage Table）过程链接表，位于代码段，内容不可修改。
PLT表通过引用GOT表中的函数的绝对地址，来把控制转移到实际的函数。
在实际的可执行程序或者共享目标文件中，PLT表在名称为.plt的section中。

## 结构

PLT[0]：保存一段操作，操作内容：push目标函数编号，跳转到GOT[2]

## 来源

> [GOT表和PLT表知识详解_77458的博客-CSDN博客_got表](https://blog.csdn.net/qq_18661257/article/details/54694748)

这个函数是编译系统自己加的，大家可以通过`disas gets`看看里面的代码，如下图：

![[z-oblib/z2-attachments/Pasted image 20220907230615.png]]

这个函数只有三行代码，第一行跳转，第二行压栈，第三行又是跳转，解释：
第一行跳转，它的作用是通过PLT表跳转到GOT表，而在第一次运行某一个函数之前，这个函数PLTPLT表对应的GOT表中的数据为@plt@plt函数中第二行指令的地址，针对图中来说步骤如下：

1. jmp 指令跳转到 GOT 表
2. GOT 表中的数据为0x400486
3. 跳转到指令地址为0x400486
4. 执行push 0x3 (这个为在GOTGOT中的下标序号)
5. 再执行jmp 0x400440
6. 而0x400440为PLT[0]的地址
7. PLT[0]的指令会进入动态链接器的入口
8. 执行一个函数将真正的函数地址覆盖到[[3-计算机科学/3-操作系统/Linux/原理/GOT表|GOT表]]中

## 问题

### PLT[0]处到底做了什么，按照我们之前的思路它不是应该跳转到GOT[0]吗？

![[z-oblib/z2-attachments/Pasted image 20220907230947.png]]


我们尝试着查看0x400440地址的数据内容发现一个问题，从0x400440−0x400450之间的数据完全不知道是什么，而真正的PLT[x]中的数据是从0x400450开始的，从这里才有了@plt为后缀的地址，但是我们disas gets看代码的时候是从0x400440开始的，我们可以通过x /5i 0x400440查看0x400440处的代码：

![[z-oblib/z2-attachments/Pasted image 20220907231232.png]]

后面的#之后又一个1616进制数，一看便可以知道是GOT表的地址，为什么这么肯定呢，因为我们可以通过`objdump -R ./a.out`查看一个程序的GOT函数的地址，如下图：

![[z-oblib/z2-attachments/Pasted image 20220907231301.png]]

这里都是些GOTGOT地址，我们发现都是0x601...0x601...这些，所以可以断定图77中的也是GOTGOT地址，那么我们可以猜想出，在正式存储一个函数的GOT地址前，我们的PLTPLT表前面有一项进行一些处理，我们暂且不具体深入剖析这些代码有什么用，但是我们可以肯定puts@pltputs@plt前面那1616个字节也算是PLTPLT表中的内容，这其实就是我们的PLT[0]，正如我们之前问题提到的那样，我们的PLT[0]根本没有跳转到GOT[0]，它不像我们的PLT[1]这些存储的是GOT表项的地址，它是一些代码指令，换句话说，PLT[0]是一个函数，这个函数的作用是通过GOT[1]和GOT[2]来正确绑定一个函数的正式地址到GOT表中来。

本来按照最开始的思路PLT[1]也是跳转到GOT[1]的，GOT[2]同理，但是这两个数据好像被PLT[0]利用了，同时GOT[0]好像消失了，这里GOT[0]暂且不说它的作用是什么，针对GOT[1]和GOT[2]被PLT[0]利用，所以我们程序中真实情况其实是从PLT[1]到GOT[3],PLT[2]到GOT[4]，所以我们推翻了之前的图，建立一张新的处理表：

![[z-oblib/z2-attachments/Pasted image 20220907231548.png]]

而plt[0]代码做的事情则是：由于GOT[2]中存储的是动态链接器的入口地址，所以通过GOT[1]中的数据作为GOT[2]参数，跳转到GOT[2]所对应的函数入口地址，这个动态链接器会将一个函数的真正地址绑定到相应的GOT[x]中。

这就是PLT表和GOT表，总而言之，我们调用一个函数的时候有两种方法，一个是通过PLT表调用，一个则是通过GOT表调用，因为PLT表最终也是跳转GOT表，GOT表中则是一个函数真正的地址，这里需要注意的是，在一个函数没有运行一次之前，GOT表中的数据为@plt函数中下一条指令的地址，图55有说。

### 为什么中间要进行push压栈操作？

中间进行的压栈是为了确定PLT对应的GOT表项，即是PLT[1]−>GOT[3]，0x3就是GOT的下标3，也就是说压栈后我们跳转到PLT[0],接着PLT[0]中的指令会通过这次压栈的序号来确定操作的GOT表项为多少。

### 压入的序号为什么为0x3，不是最开始应该为0x0吗？

这里压入0x3的原因是因为，我们的GOT[0],GOT[1],GOT[2]都有额外用处。要从GOT[3]开始。