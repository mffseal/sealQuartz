---
title: 符号解析
created: 2022-09-11 00:28:56
updated: 2022-09-11 16:41:40
tags: 
- atom
---
# 符号解析

## 作用

确定符号引用关系，将每个模块中引用的符号与某个目标模块的定义符号建立关联。

在我们通常的观念里,之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件,所以要将它们链接起来。比如我们直接使用ld来链接“a.o”,而不将“b.o”作为输入。链接器就会发现 shared和swap两个符号没有被定义,没有办法完成链接工作：
![[z-oblib/z2-attachments/Pasted image 20220911163933.png]]
这也是我们平时在编写程序的时候最常碰到的问题之一,就是链接时符号未定义。导致这个问题的原因很多,最常见的一般都是链接时缺少了某个库,或者输入目标文件路径不正确或符号的声明与定义不一样。所以从普通程序员的角度看,符号的解析占据了链接过程的主要内容。
重定位过程也伴随着符号的解析过程,每个目标文件都可能定义一些符号也可能引用到定义在其他目标文件的符号。重定位的过程中,每个重定位的入口都是对一个符号的引用,那么当链接器须要对某个符号的引用进行重定位时,它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表,找到相应的符号后进行重定位。比如我们查看“a.o”的符号表：
![[z-oblib/z2-attachments/Pasted image 20220911164046.png]]
GLOBAL”类型的符号,除了“main”函数是定义在代码段之外,其他两个“ shared和“swap”都是“UND”,即“undefined”未定义类型,这种未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后,所有这些未定义的符号都应该能够在全局符号表中找到,否则链接器就报符号未定义错误。

## 流程

> [《程序员的自我修养》番外笔记——符号解析与重定位 - SegmentFault 思否](https://segmentfault.com/a/1190000021551701)

重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找**由所有输入目标文件**的[[3-计算机科学/3-操作系统/Linux/原理/符号表|符号表]]组成的**全局符号表**，找到相应的符号后进行重定位。

![[z-oblib/z2-attachments/Pasted image 20220911033037.png]]
![[z-oblib/z2-attachments/Pasted image 20220911033032.png]]

通过命令查看“a.o”的符号表：
![[z-oblib/z2-attachments/Pasted image 20220911033013.png]]

可以看到shared和swap的类型都是“UND”，即“undefined”未定义类型，在链接器扫描完所有的输入目标文件后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报**符号未定义**错误。这种一般都是链接时**缺少了某些库**，或者输入目标文件**路径不正确**或符号的**声明与定义不一样**。

## 指令修改方式

- 不同的处理器指令对于地址的格式和方式都不一样。
- 对于32位x86平台下的[[3-计算机科学/3-操作系统/Linux/原理/ELF|ELF]]文件的重定位入口所修正的指令寻址方式只有两种：
    - 绝对近址32位寻址。
    - 相对近址32位寻址。
- 这两种重定位方式指令修正方式每个被修正的位置的长度都是32位。

这两种方式的定义：

![[z-oblib/z2-attachments/Pasted image 20220911033329.png]]

- 通过前面的[[3-计算机科学/3-操作系统/Linux/原理/重定位表|重定位表]]可以看到swap符号的类型为R_386_PC32，这是一条相对位移调用指令。而shared符号的类型为R_386_32，它修正的是一条传输指令的源，即shared的绝对地址。
- 假设在将a.o和b.o链接成最终可执行文件后，main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000，shared变量的虚拟地址为0x3000。
- 首先看偏移为0x18的这条mov指令的修正，它是绝对寻址修正，它修正后的结果是S+A。
    - S是符号shared的实际地址，即0x3000。
    - A是被修正位置的**原始值**（默认填充值），即0x00000000。
- 所以它的修正后的地址为：0x3000+0x00000000=0x3000。
	![[z-oblib/z2-attachments/Pasted image 20220911033447.png]]
- 再来看偏移为0x26的这条call指令的修正，它是相对寻址修正，它修正后的结果是S+A-P。
    - S是符号swap的实际地址，即0x2000。
    - A是被修正位置的值，即0xFFFFFFFC(-4)。
    - P为被修正的位置，当链接成可执行文件时，**这个值应该是被修正位置的虚拟地址**，即0x1000+0x27。
- 所以它的修正后的地址为0x2000+(-4)-(0x1000+0x27)=0xFD5。
	![[z-oblib/z2-attachments/Pasted image 20220911033509.png]]
- 这条相对位移调用指令的调用地址是该指令下一条指令的起始地址加上偏移量，即：0x102b+0xfd5=0x2000，刚好是swap函数的地址。
- 从这两个例子可以看出来，绝对寻址修正和相对寻址修正的区别：是否减被修正位置的地址：
	- **绝对**寻址修正后的地址为**该符号的实际地址**
	- **相对**寻址修正后的地址为**符号距离被修正位置的地址差**