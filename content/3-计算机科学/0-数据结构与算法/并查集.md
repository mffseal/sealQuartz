---
title: 并查集
created: 2022-05-06 19:54:32
updated: 2022-05-08 19:28:47
tags: 
- atom
---
# 并查集

并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。

## 解释

- 并查集其实完成了两个操作
    - 查找一个元素的根是谁
    - 合并两个不同的树

## 用处



## 并查集初始化

并查集一般是用一个一维数组来存储的，其中pre[i]=i表示自己和自己是连通的，也就是说还没有往点之间添加路径。

![[z-oblib/z2-attachments/Pasted image 20220506195441.png]]

## find() 找节点对应根节点

```cpp
// 找某个节点的根节点
int find(int x)
{
    while (fams[x]!=x)  // 如果父节点指向自己，则为根，否则继续找
        x = fams[x];
    return x;
}
```

### 路径压缩

我们使用了太多没用的信息，我的祖先是谁与我父亲是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。**把在路径上的每个节点都直接连接到根上**，这就是路径压缩。

![[z-oblib/z2-attachments/Pasted image 20220508192509.png]]

```cpp
int find(int x) {
  if (x != fa[x])  // x 不是自身的父亲，即 x 不是该集合的代表
    fa[x] = find(fa[x]);  // 查找 x 的祖先直到找到代表，于是顺手路径压缩
  return fa[x];
}
```

## join/union() 向各子树添加节点

主要是用来往存放并查集的一维数组中添加路径的，先判断两个点之间是否连通，如果连通就不用添加路径了，如果不连通那么将两个点的根节点连在一起。

![[z-oblib/z2-attachments/Pasted image 20220506195527.png]]

```cpp
void my_union(int x, int y)
{
	// 查询两个节点各自的根节点
    int rx = find(x);
    int ry = find(y);
    
    // 根节点不同则将根节点连起来
    if (rx!=ry)
        fams[ry] = rx;
}
```

### 启发式合并/按秩合并

一个祖先突然抖了个机灵：「你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。」

由于需要我们支持的只有集合的合并、查询操作，当我们需要将两个集合合二为一时，无论将哪一个集合连接到另一个集合的下面，都能得到正确的结果。但不同的连接方法存在时间复杂度的差异。具体来说，如果我们将一棵点数与深度都较小的集合树连接到一棵更大的集合树下，显然相比于另一种连接方案，接下来执行查找操作的用时更小（也会带来更优的最坏时间复杂度）。

当然，我们不总能遇到恰好如上所述的集合————点数与深度都更小。鉴于点数与深度这两个特征都很容易维护，我们常常从中择一，作为估价函数。而无论选择哪一个，时间复杂度都为$O(m\log n)$，具体的证明可参见 References 中引用的论文。

在算法竞赛的实际代码中，即便不使用启发式合并，代码也往往能够在规定时间内完成任务。在 Tarjan 的论文[1]中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度是$O(m\log n)$。在姚期智的论文[2]中，证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是$O(m\alpha(m,n))$。

如果只使用启发式合并，而不使用路径压缩，时间复杂度为$O(m\log n)$。由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。

```cpp
// C++ Version
std::vector<int> size(N, 1);  // 记录并初始化子树的大小为 1

void unionSet(int x, int y) {
  int xx = find(x), yy = find(y);
  if (xx == yy) return;
  if (size[xx] > size[yy])  // 保证小的合到大的里
    swap(xx, yy);
  fa[xx] = yy;
  size[yy] += size[xx];
}
```

## 例题

## 题目描述

有n个人，编号为1,2,……n，另外还知道存在K个关系。一个关系的表达为二元组（α，β）形式，表示α，β为同一家庭的成员。
当n，k和k个关系给出之后，求出其中共有多少个家庭、最大的家庭中有多少人？
例如：n＝6，k＝3，三个关系为（1,2），(1,3)，(4,5)
此时，6个人组成三个家庭，即：｛1,2,3｝为一个家庭，｛4,5｝为一个家庭，｛6｝单独为一个家庭，第一个家庭的人数为最多。

Input

```
第一行为n,k二个整数（1≤n≤100，0<=k<=1000）（用空格分隔）。
接下来的k行，每行二个整数（用空格分隔）表示关系。
```

Output

二个整数（分别表示家庭个数和最大家庭人数）。

Sample Input

```
6 3
1 2
1 3
4 5
```

Sample Output

```
3 3
```

HINT

```
1≤n≤100，0<=k<=1000
```

## 代码

```cpp
#include <iostream>
using namespace std;

int fams[101];  //标记根节点的数组，下标为儿子，值为对应父亲
int peops[101] = {0};  // 父亲有几个儿子的计数数组
int find(int x)
{
    while (fams[x]!=x)  // 如果父亲值指向自己，则为根，否则继续找
        x = fams[x];
    return x;
}

void my_union(int x, int y)
{
    int rx = find(x);
    int ry = find(y);
    if (rx!=ry)  // 如果两个儿子的根不同，则把一个根加到另一个根的儿子位置
        fams[ry] = rx;
}

int main (void)
{
    int n = 0, k = 0;
    int fams_num = 0, max = 0;
    cin>>n>>k;
    for (int i=0; i<=n; i++)
        fams[i] = i;
    for (int i=0; i<k; i++)
    {
        int p1 = 0, p2 = 0;
        cin>>p1>>p2;  //读取要合并的两个儿子
        my_union(p1, p2);  // 尝试合并
    }
    for (int i=1; i<=n; i++)
        if (find(i)==i) fams_num++;  // 遍历有几个父亲
    for (int i=1; i<=n; i++)
        peops[find(i)]++;  // 将各儿子对应父亲位置++记录每个父亲几个儿子
    for (int i=1; i<=n; i++)
        if (peops[i]>=max) max = peops[i];  // 找儿子最多的父亲有几个儿子

    cout<<fams_num<<' '<<max<<endl;
}
```
