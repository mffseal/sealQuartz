---
title: 组合优于继承
created: 2022-05-25 23:20:21
updated: 2022-05-26 09:29:55
tags: 
- atom
---
# 组合优于继承

> 1. Program to an interface, not an implementation. (面向接口编程，而不是具体的实现)  
>   
> 2. Favor object composition over class inheritance.（如果某个场景的代码复用既可以通过类继承实现， 也可以通过对象组合实现， 尽量选择对象组合的设计方式）

第一个原则的好处非常明显： 可以极大程度地减少子系统具体实现之间的相互依赖。  
第二个原则则不那么容易理解， 下面展开叙述 。

## 组合和继承的区别

| 组合           | 继承                        |
|--------------|---------------------------|
| has-a        | is-a                      |
| 不破坏封装        | 破坏封装，子类依赖父类               |
| 支持扩展，随意增加组合类 | 只能继承一个父类，必须包含所有方法，增加系统复杂性 |

- 通过**继承**实现的代码复用常常是一种“**白盒复用**”， 这里的白盒指的是可见性： 对于继承来说，父类的内部实现对于子类来说是不透明的（实现一个子类时， 你需要了解父类的实现细节， 以此决定是否需要重写某个方法）。
- 对象**组合**实现的代码复用则是一种“**黑盒复用**”: 对象的内部细节不可见，对象仅仅是以“黑盒”的方式出现（可以通过改变对象引用来改变其行为方式）。

## 判断是继承还是组合

所以不难发现， 当我们拿**类继承**和**组合**在一起进行对比时， 并不是以实现方式中是否有用到类继承而区分的。

我们真正关注的是**行为的继承**与**行为的组合** ：需要变化的行为是通过 **继承后重写的方式** 实现， 还是通过 **赋予不同的行为实例** 实现。

## 继承优缺点

### 优点

- 类之间的继承关系时在编译时刻静态地定义好的， 因此使用起来也非常直观， 毕竟继承是被编程语言本身所支持的功能。
- 类继承也使得修改要重用的代码变得相对容易， 因为可以仅仅重写要更改的父类方法。

### 缺点

- 第一个缺点是伴随第一个优点而生的： 没有办法在运行时刻改变继承了父类的子类行为。
- 第二个缺点与第一个缺点相比往往更严重： 通过继承实现的代码复用，本质上把父类的内部实现细节暴露给了子类， 子类的实现会和父类的实现紧密的绑定在一起， 结果是父类实现的改动，会导致子类也必须得改变。

#### 继承如何破坏封装性

```java
public class A {
    //方法功能是说话
    public void say() {
        //一堆说话的实现细节
    }
    //方法功能是唱歌
    public void song() {
        //具体的实现细节
        // 注意这里，唱歌的前提要先说话，所以调用自身的say()方法
        say();
        //然后一堆唱歌的实现细节
    }
}
```

```java
public class B extends A{
    @Override
    public void say() {
        //我就想再说话之前先告诉大家一声我要说话了
        System.out.println("我要开始说话了");
        super.say();
    }

    @Override
    public void song() {
        //我就想再唱歌之前先告诉大家一声我要唱歌了
        System.out.println("我要开始唱歌了");
        super.song();
    }

    public static void main(String[] args) {
        B b = new B();
        //现在我要高歌一首
        b.song();
    }
}

```

结果：
```
我要开始唱歌了
我要开始说话了
```

出现了只想唱歌但是说话了的问题。我明明就是想唱歌呀，为啥又说我开始说话了，  
其实是因为类B继承了类A ，在类A中的song实现细节中用了say()方法，导致在类B中先走了song()方法，又走了say()方法，但是对于类B来说我不想知道你走了啥方法，我就是想要的功能而已，唱歌就是唱歌，说话就是说话。当然我们也可以将类A中的song()方法改成不调用say()方法，但是这个不应该和类A的实现细节有关系啊，我只是提供了我的API接口，功能不变的情况下，我的内部实现细节怎么变都应该是没有问题的啊，所以这就是继承暴漏了API的实现细节出现的问题。

## 组合的缺点

- 不具备之前所罗列的类继承的优点。

## 用组合替代继承

而复合就不会有这样的问题了,把类A做为一个私有域放入类B中。再调用类A的song()方法：

```java
public class B {
    private A a;

    public B(A a) {
        this.a = a;
    }
    public void say() {
        System.out.println("我要开始说话了");
        a.say();
    }

    public void song() {
        System.out.println("我要开始唱歌了");
        a.song();
    }
    
    public static void main(String[] args) {
        B b = new B(new A());
        //现在我要高歌一首
        b.song();
    }
}

```

```
我要开始唱歌了
```

可以看出复合屏蔽了类的实现细节，专注于功能而不关注细节。

## 总结

所以继承要严格的遵循is-a的关系，否则不能瞎用继承，在用继承的时候想好继承是不是只是为了扩展功能。否则就不得不用复合来代替继承了。