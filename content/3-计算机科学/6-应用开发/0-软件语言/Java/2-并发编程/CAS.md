---
title: CAS
created: 2022-04-27 20:58:21
updated: 2022-05-31 23:17:40
tags: 
- atom
---
# CAS


## 原理

CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。

在多核状态下，某个核执行到带 lock 的指令时，CPU 会让**总线锁住**，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。

## CAS应用

java中：与volatile配合实现乐观锁。

## CAS为什么能保证原子操作呐？

这个就关系到了CAS底层所用到的Unsafe类，Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。

## 特点

- 结合 CAS 和 volatile 可以实现无锁并发，适用于**线程数少**、**多核 CPU** 的场景下。
	- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
	- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。
	- CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思
		- 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
		- 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响