---
title: x86汇编快速入门
created: 2022-09-17 15:05:28
updated: 2022-09-23 15:43:30
tags: 
- article
---

# x86汇编快速入门

## 寄存器

### CS : IP

- 物理地址 = 段地址 X 10H + 偏移地址
    - 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H
- 同一个物理地址可以由不同的段地址和偏移地址构成

#### 段寄存器

- CS: 代码段寄存器 (Code Segment)
    - 主要关注此寄存器
- DS: 数据段寄存器 (Data Segment)
- SS: 栈段寄存器 (Stach Segment)
- ES: 附加段寄存器 (Extra Segment)

#### 程序执行

任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:  

![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151311.png]]

#### 修改 CS:IP 控制流程

1. 修改 CS 和 IP
    1. `jmp 段地址:偏移地址`
        - `jmp  2AE3:3` -> 从 2AE33H 处读取指令
        - `jmp  3:0B16` -> 从 00B46H 处读取指令
1. 只修改 IP
    1. `jmp 某合法寄存器`
        - `jmp  bx`
            - 执行前: bx = 0B16H, CS = 2000H, IP = 0003H
            - 执行后: BX = 0B16H, CS = 2000H, IP = 0B16H
        - `jmp  bx` 类似 `mov   IP, bx` (把寄存器的值当作 IP)

## Winodws 下的汇编工具

### 准备

- DOSBox 环境模拟器
- debug.exe
    - win7 及以上系统不自带

### 环境配置

1. 安装 DOSBox0.74-win32-installer.exe
1. 自动配置 DOSBox 操作目录
    1. 运行安装目录中的 `DOSBox 0.74 Options.bat`
    1. 弹出的配置文件中加入如下内容:
	
	```
	MOUNT C E:\masmpro         # 将后面的目录挂载到dos的c盘符下
	set PATH=$PATH$;E:\masmpro # $PATH$代表已有环境变量, 后面是当前目录
	目录不能带中文和空格.
	```
	

1. 手动配置 DOSBox 操作目录
    1. 启动 dosbox
    1. 手动输入 `MOUNT C E:\masmpro`
2. 配置 masmpro
    1. 将 debug.exe 等软件拷贝到目录下

### debug 工具

- debug 是 Dos, Windows 提供的实模式 (8086方式) 程序的调试工具
- debug 功能
    - 查看 CPU 各个寄存器内容
    - 查看内存情况
    - 在机器码级别跟踪程序的运行
- 常用操作
    - `R` 查看更改 cpu 寄存器内容
        1. `R AX`
        1. 出现 `:` 后输入要写入的数据
        1. 回车
        1. 再按 `R` 查看修改情况
    - `D` 查看内存内容
        - `D 段地址:偏移地址`
    - `E` 改写内存内容
    - `U` 将内存中机器指令翻译为汇编指令
    - `T` 执行一条机器指令
    - `A` 以汇编格式在内存中写入一条指令  

    
    ```
    参考 王爽 <汇编语言第三版> p35.
    ```
    

## 分段管理及标志寄存器

- 一个存储单元有一个物理地址
    - 一个存储单元的编号
    - 每个物理存储单元都有一个 20 位编号
    - 8086CPU 物理地址范围: 00000H ~ FFFFFH
    - 物理地址为逻辑地址左移 4 位 (乘以10h), 加上偏移地址
        - `1230:100`, `1030:2100`, `1100:1400` 对应的物理地址都是 `12400`
- 一个存储单元对应多个逻辑地址
    - 用户编程时, 采用逻辑地址
        - `段基地址 : 段内偏移地址`

### 段寄存器和逻辑段

- 8086CPU 有 4 个段寄存器
- 每个段寄存器用来确定一个逻辑段的起始位置
- 每种逻辑段均有自己的用途
    - CS: 代码段寄存器 (Code Segment)
        - 利用 CS:IP 取得下一条要执行的指令
    - DS: 数据段寄存器 (Data Segment)
        - 利用 DS:EA 存取数据段中的数据
    - SS: 栈段寄存器 (Stach Segment)
        - 利用 CS:IP 操作堆栈顶的数据
    - ES: 附加段寄存器 (Extra Segment)
        - 利用 ES:EA 存取附加段中的数据

    
    ```
    - EA 是偏移地址, 称之为有效地址 EA
    - 若操作数在主存中, 存取的方式有:
        - 直接寻址
        - 寄存器间接寻址
        - 寄存器相对寻址
        - 基址变址寻址
        - 相对基址变址寻址
    ```
    
- 没有指明段前缀时, 一般的数据访问在 DS (u数据) 段
    - `MOV AX, [1000H]` == `MOV AX,DS:[1000H]`
        - 从默认的 DS 段中取出数据
    - `MOV AX,CS:[1000H]`
        - 从指定的 CS 段取出数据

## 标志寄存器

结构图:  

![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151340.png]]

含义:  

![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151353.png]]

- 状态标志
    - 用于记录程序运行结果的状态信息
        - CF 进位标志 (Carry Flag)
            - 当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0
        - ZF 零标志 (Zero Flag)
            - 弱运算结果为 0, 则置 1, 否则 0
        - SF 符号标志 (Sign Flag)
            - 若运算结果最高位(符号位)为 1, 则置 1, 否则 0
        - PF 奇偶标志 (Parity Flag)
            - 运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0
        - OF 溢出标志 (Overflow Flag)
            - 运算结果有溢出, 则置 1, 否则 0
            - 溢出: 有符号数的运算结果不正确
        - AF 辅助进位标志 (Auxiliary Carry Flag)
            - 运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0
- 控制标志
    - 用于控制处理器执行指令
        - DF 方向标志 (Direction Flag)
            - 用于串操作指令, 控制地址的变化方向
            - 1 则存储器地址自动增加
            - 0 则存储器地址自动减少
            - `CLD` 用于复位 DF = 0
            - `STD` 用于置位 DF = 1
        - IF 终端允许标志 (Interrupt-enable Flag)
            - 0 禁止中断
            - 1 允许中断
            - `CLI` 用于复位 IF = 0
            - `STI` 用于置位 IF = 1
        - TF 陷阱标志 (Trap Flag)
            - 0 处理器正常工作
            - 1 处理器单步执行

## 指令及寻址方式

- 零操作数指令
- 一操作数指令
- 二操作数指令
    - `操作码 目的操作数 源操作数`

### 七种寻址方式

> 寻址方式: 指令中指明操作数存放位置的表达方式.  

指令中操作数的数据存放位置有 3 种情况:

- 存放指令中 (立即数)
    - 操作数包含在指令中
    - 备操作数据直接表示在指令的操作数字段中
    - 紧跟在操作码之后
    - 例如 `MOV AL, 10H`
- 存放于寄存器中 (寄存器操作数) 
    - 数据存放在 CPU 的一个寄存器中
    - 例如 `INC CX`
- 存放于存储器中 (存储器操作数)
    - 数据再内存或 I/I 端口中
    - 存放数据的偏移地址以某种方式表示在指令中
    - 例如 `MOV AX, [2500H]`
        - 其中 [2500] 为存储器操作数
        - 存储器操作数中操作的数字段指示此操作数的偏移地址
        - 段地址由某个段寄存器提供
        - 默认为 DS 提供

### 寻址方式分类

- 立即数寻址
    - 操作数为立即数
    - 直接存放在指令的操作数字段
    - 只允许源操作数为立即数
    - 目标操作数必须是寄存器或存储单元
        - 给寄存器或存储单元赋值
- 寄存器寻址
    - 直接在指令中写出寄存器名称
- 存储器寻址
    - 直接寻址
        - 操作数存在内存中, 操作数的偏移地址直接表示在指令中
        - 表示格式: [偏移地址]
        - 默认操作数存放在内存的数据段中
        - 例如 `MOV AL, [1064H]`
        - 段超越指明使用的段
    - 寄存器间接寻址
    - 基址加变址寻址
    - 相对加基址变址寻址

## 常见汇编指令

### 数据传送指令

#### 通用传送指令

> 所有通用传送指令都不影响标志位.  

- MOV DST, SRC;
    - 将 SRC 内容赋值给 DST
    - 存储器操作数之间不能直接传递
        - 反例: `MOV [1000H], [DI]`
        - 应改为: `MOV AX, [DI]`; `MOV [1000H], AX`
    - 立即数不能直接给段寄存器
        - 反例: `MOV DS, 2000H`
        - 应改为: `MOV AX, 2000H`, `MOV DS, AX`
    - 段寄存器之间不能直接传递
    - CS 值可以作为源操作数
    - 源操作数和目的操作数宽度必须相等

![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151408.png]]

#### 堆栈指令

> 后进先出.  
> 赋值遵循高高低低原则.

- PUSH src
    1. (SP) <- (SP) - 2
        - 堆栈操作以字为单位, 所以 -2
    1. ((SP)+1,(SP)) <- (src)
- POP
    - 把 SP 所指向的堆栈顶部的一个字送入目的地址, 同时谢盖堆栈指针
    1. (dst) <- ((SP)+1,(SP))
    1. (SP) <- (SP)+2

#### 交换指令

- XCHG dst, src
    - 可以实现寄存器之间, 寄存器和存储器之间的交换操作
    - 存储器之间不能直接交换
    - 段寄存器不能作为操作数
    - 允许字或字节操作

#### 输入指令

- IN
    - 用于 CPU 从外设端口接收数据

#### 输出指令

- OUT
    - 用于 CPU 向外设端口传输数据

#### 目的地址传送指令

- LEA reg16, mem
    - reg16 -- 16位通用寄存器
    - mem -- 存储单元
    - 将元操作数的偏移地址传给目的操作数
    - 源操作数必须以寄存器间接寻址, 变址寻址, 基址加变址寻址等方式表示的存储器操作数
- LDS reg16, mem

#### 标志传送指令

- LAHF
    - 将标志寄存器低八位传送给 AH
- SAHF
    - 将 AH 赋值给标志寄存器低八位
- PUSHF
    - 标志进栈
- POPF
    - 标志出栈

### 算数运算类指令

#### 加法指令

- ADD (Addition) 加法指令
    - `ADD dest, src`
    - (data) <- (dest) + (src)
    - 源和目的不能同时为存储器, 不能为段寄存器
- ADC (Add with Carry) 带进位加法指令
    - `ADC dest, src`
    - (dest) <- (dest) + (src) + C
    - C 是上一条指令的进位结果
    - 用于多字节拆分运算
- INC (Increment) 加 1 指令
    - `INC dest`
    - (dest) <- (dest) + 1
    - 多用于循环中修改地址指针和循环次数
    - 影响标志位 S, Z, A, P, O

#### 减法指令

- SUB
    - `SUB dest, src`
    - (data) <- (dest) - (src)
- SBB
    - `SBB dest, src`
    - (dest) <- (dest) - (src) - C
- DEC
    - `DEC dest`
    - (dest) <- (dest) - 1
    - 多用于循环中修改地址指针和循环次数
    - 影响标志位 S, Z, A, P, O

#### 求补指令

- `NEG dest`
    - (dest) <- 0 - (dest)
    - 把操作数按位求反再加一

#### 比较指令

- `CMP dest, src`
    - (dest) - (src)
    - 结果不保留, 只用来影响标志位
        - A, C, O, P, S, Z
    - 比较两个数的大小关系
        - Z: 判断两者是否相等
        - C: 判断两个无符号数的大小
        - S, O: 判断两个带符号数的大小
    - cmp 算术减法运算结果为零,就把ZF(零标志)置1

#### 乘法指令

- MUL 无符号乘法
    - `MUL SRC`
    - 字节操作数: AX <- (AL) * (SRC)
    - 字操作数: DX:AX <- (AX) * (SRC)
- IMUL 带符号乘法
    - 与上面类似

#### 除法指令

- DIV 无符号除法
    - `DIV SRC`
    - 字节除法:
        - AL <- (AX) / (SRC) 的商
        - AL <- (AX) / (SRC) 的余数
    - 字除法:
        - AL <- (DX:AX) / (SRC) 的商
        - AL <- (DX:AX) / (SRC) 的余数
- IDIV 有符号除法
    - 与上面类似

### 逻辑运算指令 (位操作)

- AND dest, src
    - (dest) <- (dest) and (src)
- TEST dest, src
    - 与 and 类似
    - 不保存结果, 只改变标志位
    - test逻辑与运算结果为零,就把ZF(零标志)置1
- OR dest, src
    - 与 and 相反
- XOR dest, src
    - 相同为 0
- NOT dest
    - 按位取反

### 移位指令 (位操作)

- SAL (Shift Arithmetic Left) 算术左移
    - 相当于无符号乘以2^n
    - 最低位填充 0
- SAR (shift arithmetic right) 算术右移
    - 最高位不变
    - 最低位移入寄存器 CL
- SHL (shift logical left) 逻辑左移
    - 相当于无符号乘以2^n
    - 最低位填充 0
- SHR (shift logical right) 逻辑右移
    - 相当于无符号除以2^n
    - 最高位填充 0
    - 最低位进入寄存器 CF
- ROL (rotate left) 循环左移
    - 最高位放入最低位
    - 最高位复制到 CF
- ROR (rotate right) 循环右移
    - 最低位放入最高位
    - 最低位复制到 CF
- RCL (rotate left with carry) 带进位循环左移
    - CF 进位值放低位
    - 高位放 CF
- RCR (rotate right with carry) 带进位循环右移
    - CF 进位值放高危
    - 低位放 CF

指令格式:  

```x86arm
操作码 reg/mem, count   # count=1或CL, 指定移位次数
```

### 串操作

> 串是内存中一段地址相连的字节或字.

- 串操作也叫数据块操作
- 可实现存储器数据间的直接传送
- 8086 有 5 种基本串操作
- 对字操作以 B 结尾, 对字节操作以 W 结尾
    - MOVS (move string) 串传送
    - CMPS (compare string) 串比较
    - SCAS (scan string) 串扫描
    - LODS (load from string) 取串
    - STOS (store in to string) 存串
    - REP 重复串操作执行过程
        - 当 CX != 0 则执行 CX <- CX - 1, 再执行后续串指令
        - 当 CX == 0, 结束 REP, 执行下一条指令

```
可以不借助寄存器直接在存储器间传递数据.
```

### 控制类指令

#### 非条件转移

- JMP 
    - `JMP 位置`

#### 条件转义

- 根据单个条件标志
    - Z 标志
        - JZ / JNZ (jump on zero; jump on no zero)
    - C 标志
        - JC / JNC (jump if carry)
    - p 标志
        - JP (JPE) / JNP (JPO) (jump on parity; jump on even; jump on odd)
    - S 标志
        - JS (负号跳转) / JNS
    - 0
        - JO (溢出跳转) / JNO
- 根据两个无符号数大小关系
    - JB 低于跳转
    - JBE 不高于跳转
    - JA 高于跳转
    - JAE 高于等于跳转
    - JNB 不低于跳转
- 根据两个带符号数比较结果
    - JL (JNGE) 小于跳转
    - JNL (JGE) 不小于跳转

```
所有条件转义指令都是段内 (-128 ~ +127) 范围内转移
```

#### 过程(子程序)调用

- 自程序调用
    - CALL 子过程名
- 返回指令
    - RET
        - 在子程序的结尾
        - 用于返回主程序

#### 无条件循环

- LOOP 语句标号
    - CX <- CX - 1
    - 若 CX != 0 转向目标地址去执行
    - 否则执行 LOOP 之后的指令
    - 过程解释
        1. 首先执行 CX = CX - 1
        1. 判断 CX 的值
        1. 若 CX != 0 则转移到 Lable 处执行
        1. 否则向下继续

#### 条件循环

- LOOPZ / LOOPE 语句标号
    - CX <- CX - 1
    - 若 CX != 0 且 ZF == 1, 转向目标地址执行
    - 否则执行之后的语句
    - 过程解释
        - 首先执行 CX = CX - 1
        - 判断 CX != 0 和 ZF == 1 满足则转到 Lable 执行
        - 否则向下继续

#### 中断指令

- 中断调用
    - INT n
    - n为中断号, 0 ~ 255
- 中断返回
    - IRET

#### 标志处理指令

- CLC (clear carry flag) 清 C
- STC (set carry flag) 置 C
- CMC (complement carry flag) C 求反
- CLD (clear direction flag) 清 D
- STD (set direction flag) 置 D
- CLI (clear interrupt flag) 清 I
- STI (set interrupt enable flag) 置 I

#### 其它处理机控制指令

- NOP (no operation)

## OPCode

- 一个 opcode 不一定对应一条汇编指令
- 一条汇编指令不一定对应一个 opcode

### OPCode 主要数据域

![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151425.png]]

- 以上只有 Code 域是必须存在的
- 其它数据域视指令格式而定有无
- 一个指令的长度在 `1Byte ~ 16Byte` 之间
- 实际正常的最长指令为 `13Byte`

### 指令前缀

- 前缀(Prefixes)大小为 `Byte, 可以被划分为 5 个集合
    - 切换操作数大小 66
    - 切换地址大小 67
        - 切换是特指在 2 种状态间切换, 而非切换到特指的某状态
    - 重复操作前缀 F2/F3
    - 修改默认段 2E/36/3E/26/64/65
        - 将默认值修改为其它段
    - 锁定前缀 F0
- 这些指令独此一份, 不可能为其它机器码
- 如果有多个 prefixes, 顺序可能是乱序
- 如果 prefixes 不能对后续的 opcode 起作用, 那就被忽略
- 出现特定操作码时用作补充说明, 一般是指令冒号前的部分

### ModR/M

- 辅助说明操作码的操作数
    - 操作数的个数
    - 操作数的种类 [寄存器, 内存地址, 常量]

### D-SIB

- 用来辅助说明 ModR/M
- 辅助寻址
- 需要和 ModR/M 一起使用

### 位移

- 操作码的操作数为内存地址事, 用来表示位移操作

### 立即数

- 操作码的操作数是常量, 该常量为立即数
