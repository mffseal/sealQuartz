---
title: 跳表
created: 2022-05-13 19:53:48
updated: 2022-05-14 22:40:45
tags: 
- #atom
---
# 跳表

>https://www.jianshu.com/p/9d8296562806

针对顺序表，以某一概率在当前最上层选点构建新的一层，以此构建多层索引，由上往下逐层增加稠密度。

![[z-oblib/z2-attachments/19063731-70b00aafa9f5b793.webp]]
![[z-oblib/z2-attachments/19063731-4f4535e6d0959c32.webp]]
![[z-oblib/z2-attachments/19063731-3852cc36af701f46.webp]]

## 索引高度

假设原始链表有n个元素，以每两个节点抽出一个节点为例，即某个点有1/2的概率被选中：
- 1级索引节点数：n/2
- 2级索引节点数：n/4
- k级索引节点数：$n/2^k$
此例中跳表索引高度为：$h = log_2{n} - 1$，-1是因为最上层不会有节点个数为1的层，所以减掉1。

因此原始链表有n个元素，各级跳表的选取概率为p，则第k层的节点数 $m_k = m_{k-1} \times 1/p$，索引的高度为$h = log_{1/p}{n} - 1$。

## 查找时间复杂度

时间复杂度 = 索引的高度 * 相邻索引间包含的下层索引个数（均值）。

![[z-oblib/z2-attachments/19063731-5ec10e6ae2c32587.webp]]

图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。

可知各级索引个数和选取的概率相关，个数$q = 1/p + 1$，+1是因为上层索引进入下层索引时，会重复访问一次（例子中的w）。

则时间复杂度为
$$
\begin{split}
O(h*q) &= O((log_{1/p}{n} - 1) * (1/p + 1)) \\
&= O(log{n})
\end{split}
$$
最后简化的原因是，在具体实现上p会取一个确定的值，例如前例中的1/2，所以这里p是常数，而时间复杂度计算时可以省略常数。

但在实际应用中，p的取值会影响具体算法实现的效率。Redis 的 zset 中 SKIPLIST_P 设定的 0.25，即隔4个取一下。

#TODO 
