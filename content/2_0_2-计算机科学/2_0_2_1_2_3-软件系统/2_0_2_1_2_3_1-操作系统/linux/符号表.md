---
title: 符号表
created: 2022-09-11 02:51:17
updated: 2022-09-11 23:45:33
tags: 
- atom
---
# 符号表

## 作用

> 一张“查询表。

符号表包含了**一些通用的符号**，这部分信息在进行了 `strip` 操作后就会消失。这些符号信息可能包括变量名、函数名。
符号表本质就是一个映射表，举个例子：某行二进制汇编代码映射到源码第几行。

符号表的作用：

1. 调试：汇编--查找-->源码位置
2. 重定位：函数名--查找-->汇编位置

### 调试

- window工程有一个*.pdb文件,里面编包含调试符号.可参阅wiki window pdb格式。
- 在java工程会使用一个叫混淆的技术，混淆后会生成混淆前后的映射文件mapping.txt,这个也可以理解为符号表的一种。
- 在linux有一个dwarf的文件格式也是专门用于调试的文件。参阅wiki DWARF。


### 重定位

重定位可以大致分为两种类别`动态重定位`与`静态重定位`

#### 动态重定位

假设A程序需要`xxx.so`中的`yyyy`函数那么就需要从`xxx.so`中的符号表进行读取。

#### 静态重定位

[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/静态重定位|静态重定位]]

## 基本结构

ELF文件中的符号表往往是文件中的一个段，段名一般叫".symtab"。符号表的结构很简单，它是一个符号表项数组数组，每个符号表项结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的"未定义"符号。

Elf32_Sym的结构定义如下：

```cpp
typedef struct {  
	Elf32_Word st_name;  
	Elf32_Addr st_value;  
	Elf32_Word st_size;  
	unsigned char st_info;  
	unsigned char st_other;  
	Elf32_Half st_shndx;  
} Elf32_Sym;
```

| 名称       | 描述                                                                      |
|----------|-------------------------------------------------------------------------|
| st_name  | 符号名。这个成员包含了该符号名在字符串表中的下标（还记得字符串表吧？）                                     |
| st_value | 符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同，见下文“符号值”。          |
| st_size  | 符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个double型的符号它占用8个字节。如果该值为0，则表示该符号大小为0或未知。 |
| st_info  | 符号类型和绑定信息，见下文“符号类型与绑定信息”                                                |
| st_other | 该成员目前为0，没用                                                              |
| st_shndx | 符号所在的段，见下文“符号所在段”                                                       |


Elf64_Symbol定义如下：

```cpp
typedef struct { 
    int   name;      /* String table offset */ 
    char  type:4,    /* Function or data (4 bits) */ 
    binding:4;       /* Local or global (4 bits) */ 
    char  reserved;  /* Unused */  
    short section;   /* Section header index */
    long  value;     /* Section offset or absolute address */ 
    long  size;      /* Object size in bytes */ 
} Elf64_Symbol; 
```

注意：  
有三类伪节是没有节头表条目的
- `ABS` 
    不需要重定位的符号，比如源代码的路径名；
- `COMMON` 
    未初始化的全局变量；  
    `.bss`保存的是未初始化的静态变量，及初始化为0的全局变量和静态变量；
- `UND` 
    在目标文件`m`中引用，但定义在别的文件中的符号；

其中，符号表中下标 0 存储了符号表的一个元素，同时这个元素也相对比较特殊，作为所有未定义符号的索引，具体如下：
| 名称       | 取值 | 说明       |
|----------|----|----------|
| st_name  | 0  | 无名称      |
| st_value | 0  | 0 值      |
| st_size  | 0  | 无大小      |
| st_info  | 0  | 无类型，局部绑定 |
| st_other | 0  | 无附加信息    |
| st_shndx | 0  | 无节区      |


## st_info[¶](https://ctf-wiki.org/executable/elf/structure/symbol-table/#st_info "Permanent link")

st_info 中包含符号类型和绑定信息，这里给出了控制它的值的方式具体信息如下

`#define ELF32_ST_TYPE(i)    ((i)&0xf) #define ELF32_ST_INFO(b, t) (((b)<<4) + ((t)&0xf))`。

## 符号类型和绑定信息（st_info）

该成员低4位表示符号的类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）

符号绑定信息：
| 宏定义名       | 值 | 说明                |
|------------|---|-------------------|
| STB_LOCAL  | 0 | 局部符号，对于目标文件的外部不可见 |
| STB_GLOBAL | 1 | 全局符号，外部可见         |
| STB_WEAK   | 2 | 弱引用，详见“弱符号与强符号”   |

st_info 的低 4 位表示符号类型：
| 宏定义名        | 值 | 说明                 |
|-------------|---|--------------------|
| STT_NOTYPE  | 0 | 未知类型符号             |
| STT_OBJECT  | 1 | 该符号是个数据对象，比如变量、数组等 |
| STT_FUNC    | 2 | 该符号是个函数或其他可执行代码    |
| STT_SECTION | 3 | 该符号表示一个段，这种符号必须是   |
|             |   | STB_LOCAL的         |
| STT_FILE    | 4 | 该符号表示文件名，一般都是该目标文  |
|             |   | 件所对应的源文件名，它一定是     |
|             |   | STB_LOCAL类型的，并且它的  |
|             |   | st_shndx一定是SHN_ABS |

### 符号所在段（st_shndx）

如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊：
特殊常量：
| 宏定义名       | 值      | 说明                                                                                                                   |
|------------|--------|----------------------------------------------------------------------------------------------------------------------|
| SHN_ABS    | 0xfff1 | 表示该符号包含了一个绝对的值。比如表示文件名的符号就属于这种类型的                                                                                    |
| SHN_COMMON | 0xfff2 | 表示该符号是一个“COMMON块”类型的符号，一般来说，未初始化的全局符号定义就是这种类型的，比如SimpleSection.o里面的global_uninit_var。 |
| SHN_UNDEF  | 0      | 表示该符号未定义。这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中。                                                                           |
