---
title: cmpxchg
created: 2022-05-03 17:02:29
updated: 2022-05-03 17:11:31
tags: 
- atom
---
# cmpxchg

>https://zhuanlan.zhihu.com/p/34556594

## 底层实现

linux_x86的实现：

![[z-oblib/z2-attachments/v2-918101df747ba9d03815cefff3955d74_1440w.jpg]]

windows_x86的实现：

![[z-oblib/z2-attachments/v2-cd24129a2b8f106ec3179083d3e8cfd1_1440w.jpg]]

mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。

1.  如果当前系统是多处理器，该函数返回1。
2.  否则，返回0。

LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。

1.  如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。
2.  否则，不加lock前缀。

这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。

  

intel手册对lock前缀的说明如下：

1.  确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会**锁住总线**，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做**缓存锁定**（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。
2.  禁止该指令与之前和之后的读和写指令[[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/指令重排序|重排序]]。
3.  把写缓冲区中的所有数据刷新到内存中。

## 在Java中

上面的第1点保证了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]]读和volatile写的内存语义。