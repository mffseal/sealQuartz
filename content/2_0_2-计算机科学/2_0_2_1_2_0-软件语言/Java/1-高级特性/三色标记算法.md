---
title: 三色标记算法
created: 2022-08-05 01:39:30
updated: 2022-08-05 02:59:24
tags: 
- atom
---
# 三色标记算法

## 解决的问题

CMS垃圾回收机制下，对象标记线程和用户线程同时执行，用户线程会影响标记准确度，导致：
1. 浮游垃圾问题
	1. 该问题不同特别在意，因为浮动垃圾会在下次GC时被清理。
2. 错误回收问题
	1. 该问题要特别在意，因为回收了一个正在使用的对象是严重的BUG。

## 解决思路

通过广度优先算法扫描gc树上的节点，并用黑色标记已经扫描完成的节点，灰色标记正在扫描的节点，白的未扫描的节点，达到性质：
1. 黑色节点的所有子节点都应该是灰色节点。
2. 所有白色节点都是垃圾。

因为**黑色节点是已经扫描完成的，不会再处理**，所以若用户线程把白色节点接入黑色节点就会产生错误：该白色节点不应该被回收但不会再变色了。

## 问题产生条件

我们将用户线程针对对象引用的操作成为赋值（修改应用或者置null），则有：
1. 赋值器插入了若干条 **黑色 --> 白色** 的新引用。
2. 赋值器删除了针对某白色节点的所有 **灰色 --> 白色** 的引用。
	1. 可能该白色节点就是垃圾。
	2. 赋值器可能接下来会把白色节点接入黑色节点，进入情况1。

## 解决方案

只要打破上述两种情况的任意一种即可，则对应有两种解决方案：

### 增量更新

通过“写屏障”（类似AOP），记录用户将白色节点链到黑色节点的操作。重新标记阶段就会根据该记录以这部分黑色节点为根再扫描一次。

### 原始快照

在用户线程断开灰白间引用关系前加入“写屏障”，将这个要删除的引用记录下来。发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。

### 总结

原始快照关注的是引用删除，增量更新关注的是引用增加。
使用增量更新算法，那变成灰色的对象还要重新扫描一遍，效率太低了，所以G1在处理并发标记的过程比CMS效率要高，这个主要是解决漏标的算法决定的。
因此G1不采用增量更新。