---
title: 偏向锁
created: 2022-04-27 16:39:13
updated: 2022-05-28 16:36:39
tags: 
- atom
---
# 偏向锁

## 存在缘由

轻量级锁在没有竞争时，每次[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#获取锁|在5.2重入锁时]]都要重复执行[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作，例如：
```java
static final Object obj = new Object();
public static void m1() {
    synchronized( obj ) {
        // 同步块 A
        m2();
    }
}
public static void m2() {
    synchronized( obj ) {
        // 同步块 B
        m3();
    }
}
public static void m3() {
    synchronized( obj ) {
	    // 同步块 C
    }
}
```

对应轻量级锁：

![[z-oblib/z2-attachments/Pasted image 20220527220040.png]]

对应偏向锁：

![[z-oblib/z2-attachments/Pasted image 20220527220054.png]]

java6中引入偏向锁来进一步优化：
只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。

## 偏向状态

一个对象创建时：
- 如果开启了偏向锁（默认开启），在 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 中，偏向锁的锁标志位仍然是01，偏向锁标志位1 --> Mark Word后三位为101。
- 初始状态 thread、epoch、age都为0。
- 偏向锁是默认是**延迟**的（4秒），不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟。
	> 因为JVM在启动期间会采取大量安全点来消除偏差。这跟偏向锁有啥关系？说下我的理解哈，不一定是JVM工程师设计此的初衷。安全点大家应该是很熟悉了，启用安全点会带来STW。而偏向锁的撤销与重偏向判断，也是需要启用安全点的，因为需要扫描所有线程的虚拟机栈，需要内存静止才能保证结果准确。而JVM在启动期间用到的锁，包括初始化很多类的过程中用的锁，都会经过偏向锁逻辑，如果没有偏向延迟，就会带来更多的STW，导致JVM启动时间过长。
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值。
- 测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁。

## 偏向锁获取过程

- 访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。
- 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
- 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
- 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
- 执行同步代码。

![[z-oblib/z2-attachments/偏向锁2.png]]

## 偏向锁的释放

![[z-oblib/z2-attachments/偏向锁.png]]

偏向锁的撤销在上述第四步骤中有提到。偏向锁只有**遇到其他线程尝试竞争偏向锁**时，持有偏向锁的线程才会释放锁，**线程不会主动去释放偏向锁**。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况： 
1. A 线程已经退出了同步代码块，或者是已经不再存活，如果是上面两种情况之一，此时就会直接撤销偏向锁，变成无锁状态。
2. 线程还在同步代码块中，此时将A线程的**偏向锁升级为轻量级锁**。

偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：

1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。

所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：

```bash
-XX:UseBiasedLocking=false。
```


## 批量重偏向

### 为什么有批量重偏向

当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。这个过程是要消耗一定的成本的，所以如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。

### 批量重偏向的原理

竞争发生先升级成轻量级锁，但是如果线程对锁是交错访问的，没有实际上的竞争发生，并且次数达到一定阈值，则会进行重偏向（因为偏向锁不会释放，所以线程用完锁了偏向状态不会改变，别的线程一下子不知道）。

epoch：一个时间戳，用来记录线程对某个类生成的对象的控制权。

> 我们要对一个**类**的所有实例（对象）进行批量重定向，就会在一个关键节点对所有实例进行一次扫描，看看有没有线程在锁定这些对象，被锁定的对象会更新一个标记，这个标记和类元数据中的最新标记一致，未被锁定的不会记录最新值，这样就能知道对象有没有线程在用。

1. 首先引入一个概念epoch，其本质是一个**时间戳**，代表了**偏向锁的有效性**，epoch存储在可偏向对象的MarkWord中。除了**对象**中的epoch，对象所属的**类**class信息中，也会保存一个epoch值。
    
2. 每当遇到一个全局安全点时(这里的意思是说批量重偏向没有完全替代了全局安全点（比如要对class C 进行批量重偏向），则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new

3. 然后扫描所有持有 class C **实例**的线程栈，根据线程栈的信息**判断出该线程是否锁定了该对象**，仅将epoch_new的值赋给**被锁定**的对象中，也就是现在**偏向锁还在被使用**的对象才会被赋值epoch_new。

4. 退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为步骤3里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作，**偏向自己而不是升级成轻量级锁**。

## 撤销

### 调用对象hashCode

hashCode会禁用偏向锁：哈希码用的时候才产生，默认是0，只有第一次调用对象的hashcode，对象的哈希码才会产生，才在对象头的markword里面填充哈希码。

> 轻量级锁会在锁记录中记录 hashCode
重量级锁会在 Monitor 中记录 hashCode

### 其它线程使用对象

当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁。

### 调用 wait/notify

### 批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会发现这个类的对象竞争比较激烈，不应该用偏向锁。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。