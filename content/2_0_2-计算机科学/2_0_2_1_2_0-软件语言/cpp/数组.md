---
title: 数组
created: 2022-10-30 23:25:36
updated: 2022-11-01 23:29:51
tags: 
- article
---

# 数组

## 数组名

```c
int b[10];
```

其中：
- b[4] 的类型是int。
- b的类型是数组名。



- 数组名本质是一个常量[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/指针|指针]]，但编译器会记录相关属性，如数组元素个数等。
- 数组名的值是一个指向首元素的指针常量。
- 只有数组名在表达式中使用时，编译器才会为它产生一个指针常量。
- 指针常量意味着指针的值不能改变。

两种情况下数组名不用指针常量来表示：
- 数组名作为 sizeof 操作数时：
    - sizeof返回数组的长度，而不是指向数组的指针长度。
- 作为 &  的操作数时：
    - 取一个数组名的地址所产生的时一个指向数组的指针，而不是一个指向某个常量值的指针。

```c
int a[10];
int b[10];
...
c = &a[10];
```

- `&a[0]`是一个指向数组第一个元素的指针，正是数组名本身的值，等价于 `c =a;`。
- `b = a;` 和 `a = c;` 都是非法的，无法给指针常量赋值。

## 下标引用

```c
array[下标]
```

等价于：

```c
*(array + (下标) )
```

### 等价关系

```c
int array[10];
int *ap = array + 2;
```

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221031001323.png]]

- ap：array+2、&array[2]。
- \*ap：array[2]、\*(array+2)。
- ap[0]：\*(ap+(0))、array[2]。
- ap+6：array+8、&array[8]。
- \*(ap+6)：\*(array+8)、array[8]。
- ap[6]：\*(array+8)、array[8]。
- &ap：合法但是没有对等的涉及array的表达式，无法预测编译器会把ap放在相对于array的何处。
- ap[-1]：\*(array+2-1)、array[1]。
- ap[9]：array[11]，数组越界但编译器可能无法检测到此类错误。
- 2[array]：\*(2+(array))，array外括号可省略并交换顺序-->\*(array+2)，合法。

例如下面这段代码会输出10：

```c
int main() {
	int array[10] = { 0,1,2,3,4,5,6,7,8,9 };
	int test[5] = { 0,1,2,3,4 };
	int *p = array;
	p[16] = 10;
	cout << test[0];
	return 0;
}
```

> 在一些场景会使用该技巧，例如嵌入式开发时对boot magic address的操作。

## 数组与指针的差别

```c
int a[5];
int *b;
```

a和b都有指针值，都可以进行间接访问和下标引用，但是不能随意互换使用：
- 声明一个数组时，编译器会根据指定元素数量为其保留内存空间，再创建数组名且值是指向该段空间起始位置的常量。
- 声明一个指针时，编译器只会为指针本身保留空间，且不会初始化指向任何现有空间。

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101015317.png]]

## 指针与下标的选择

上面两段代码中

### 指针效率更高的场景

> 指针的效率和下标一样或者更高。

```c
int array[10], a;
for (a = 0; a<10; a++)
    array[a] = 0;
```

上一段代码，编译器先取出a的值，再乘以整型的长度4，循环执行。

```c
int array[10], *ap;
for (ap = array; ap<array+10; ap++)
    *ap = 0;
```

上段代码中，ap指针多次加上$1*4$的值。

虽然都有多次乘法，但是第二个代码中的乘法总是$1*4$，即可在编译阶段优化。

### 效率一样的场景

```c
a = get_value();
array[a] = 0;
```

```c
a = get_value();
*(array+a) = 0;
```

上面两段代码中的a每次都是不确定的值，因此指针访问也不能被优化，所以效率一样。

### 更复杂的场景

```c
#define SIZE 50
int x[SIZE];
int y[SIZE];
int i;
int *p1, *p2;

int main() {
    for(i=0;i<SIZE;i++)
        x[i]=y[i];
}
```

```c
int x[SIZE];
int y[SIZE];
int i;
int *p1, *p2;

int main() {
    register int *p1, *p2;
    for(p1=x ,p2=y;p1<&x[SIZE];)
        *p1++=*p2++;
}
```

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101014553.png]]

第二种方式更快，因为用到了寄存器变量，并且通过消除计数器来将循环边界的范围比较值放在编译阶段进行计算。

## 数组名作为函数参数

实参实际上是一个指针，而不是一个数组，因为函数并不会为数组参数分配内存空间，形参只是一个指针，指向了已经在其它地方分配好的内存空间。因此函数也无法知道数组的长度，需要显示的传递一个参数告知数组长度，且 `sizeof string`的值时指向字符串首个字符的指针的长度，而不是字符串的长度。
下面两种形式相等，但仅限于当前上下文环境。

```c
int strlen(char *string);
int strlen(char string[]);
```

## 多维数组

```c
int array[3][6];
```

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101171935.png]]

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101171952.png]]

多维数组的第一维实际上时另一个数组。上面例子中array可以看作时一个一维数组，包含3个元素，每个元素恰好是包含6个整型元素的数组。

array这个名字的值指向第一个元素的指针，所以array是一个指向包含6个整型元素的数组的指针。

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101172727.png]]

array+1也是指向包含6个整型元素的数组的指针，但是指向的是array的另一行：

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101172809.png]]

`*(array+1)` 是一个指向整型的指针

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101172926.png]]

`*(array+1)+5`：

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101173028.png]]

`*(*(array+1)+5)`：执行间接访问操作。

### 下标访问

```c
int matrix[3][10];
matrix[1][5];
```

![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/cpp/z-attachments/Pasted image 20221101172653.png]]

### 指向数组的指针

```c
int vector[10], *vp=vector;
int matrix[3][10], *mp=matrix;
```

语句1合法，语句2不合法。因为matrix不是一个指向整型的指针，而是一个指向整型数组的指针，与 `int *mp`中mp的类型不符，应该声明如下：

```c
int (*p)[10];
```

下标引用优先级高于间接访问，但括号提高了间接访问的优先级保证其首先被执行，所以p是一个指针；
执行下标访问后，确定了p指向某种类型的**数组**，数组的每个元素都是int。

下面的例子包含了三种常见情况：

```c
int main() {
	int array[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	int* p1 = &array[0][0];
	int* p2 = array[0];
	int (*p3)[4] = array;
	cout << *(p1 + 1) << endl;    // 2
	cout << *(p2 + 1) << endl;    // 2
	cout << *(*(p3 + 1)) << endl; // 5
	return 0;
}
```

### 多维数组作为函数参数

参数中的多维数组名，实际传递的时指向数组第一个元素的指针。

可以参考一维数组的情况：

```c
void func1(int *vec);
void func1(int vec[]);
...
int vector[10];
...
func1(vector);
```

```c

```

二维数组：

```c
void func2(int (*mat)[10]);
void func2(int mat[][10]);
...
int matrix[3][10];
...
func2(matrix);
```

关键是编译器必须要能知道第二个及以后各维的长度才能对各下标求值，函数形参必须声明>=2维的长度。
第一维的长度不重要，因为计算下标值时用不到。

下列声明形式不正确：

```c
void func2(int **mat);
```

## 指针数组

```c
int *api[10];
```

下标引用优先级高于间接访问，在上述表达式中首先执行下标引用，api时某种类型的长度为10数组。返回数组首元素，再执行间接访问后是整型。
最终api是一个数组，元素类型是指向整型的指针。

