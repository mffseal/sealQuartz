---
title: 流
created: 2022-08-05 01:40:14
updated: 2022-08-05 01:40:15
tags: 
- atom
---

# 流

## 基本概念


流只是一个比喻。

任何比喻都无法完美。

流比喻数据的均匀连续性。

你从水龙头接水，无论拿杯子，脸盘，还是桶。只要水流不断，你都可以接满。

假设水龙头吐出的是大小不一的冰块，那就不叫连续了。

当然，计算机最小单位是字节，所以流数据最小单位也是字节（byte)。当然可以通过写程序模拟以位(bit 每字节8位）为单位的bit流。

模拟bit流多用在压缩算法。平常我们更多时候是需要连续的字节以某种方式组合起来读入或写出，比如以字符形式就是两个两个读（char，在java里是两个字节。）。看看jdk里有什xxxstream的类。

你的问题是自我想像流一定是个管子。其实在计算机世界里，管子是管子，流是流。

以文件流为比喻。你下载了1个G的某片，存在磁盘上总要占用一大块磁盘空间（物理上很可能是不连续的，但暂时想像它们是家里瓷盘上的一汪水）然后你凑过嘴，把嘴嘟起来，陶醉（假装）地吸上一口，字节带着细微的水花从你嘴唇穿入，这时候磁盘的一汪字节和你产生吸力的嘴之间，没有吸管，但真的有流。

  

你说嘴巴吸不了磁盘上的字节。你说甚至一G的文件在磁盘上很可能是分在不连续的扇区存储的，怎么有连续的流呢？

  

你说得很对。。。也许你看本地片子时，突然某处稍卡了一下，你怀疑是不是正好上个字节和下个字节之间 隔了几个扇区几个[磁道](https://www.zhihu.com/search?q=%E7%A3%81%E9%81%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A44911601%7D)

。。。但其实通常不是的。操作系统不会这么直接。它会趁你慢慢欣赏某些片段时，早就将数据从慢腾腾的磁盘预读到快如闪电的内存中了，这个位于磁盘和播放器程序之间的缓存区，是很像你说的管子，但它真的和流这个对象没有什么关系，在代码中的流对象看来 那缓存区就是操作系统提供的文件。

JAVA代码是在[虚拟机](https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A44911601%7D)

上跑的，所以在操作系统自带的缓存区这管子后面，可能还要再接一截虚拟机提供的管子。并且，看过净水机的广告吧？ 什么十八过滤芯层层净化，那就是JAVA虚拟机或运行时提供的，用于转换数据编码什么的。

  

流这个比喻的本质就是为了让某个对象可以均匀持续地吐出无间隔的数据，或者你可以向这个对象毫无压力地持续不断塞进数据。。。。至于那些管子。。。恰恰是因为现实世界不够符合这个要求，所以必须有。经典例子改成网上看超大的片子。我们希望网络是一个符合我们说的条件的流，它必须连续出数据，但它做不到，它卡卡卡的，太像是在咳嗽吐结石了……认真回答我，看片子很卡，你会有“流”的任何联想和感受吗。。怎么办？你先等等，操作系统已经准备了个长管子，帮你缓存一大段你再看，这回就很流很流的感觉了。

  

所以，管子什么的，那不是流，那是不得不要靠它们来装（装逼的装 不是装放的装）流的枝节。通常是伟大的C程序员们要管的事。

最后有关网线。。。你要从公司回家，公司是A端，家是B端，你是数据，两个问题请回答：

一，你回家不从任何路上经过，你闭上眼睛心里默念我要回家，然后就瞬间转移到家里出现了？？

二，你拉开家门，你老婆会说：哟，从公司回来了呀？ 还是她很认真严谨地说：哟，从马路上回来了呀？

再说三点：一，物理上你无法直接从公司转移到家，所以需要马路管子。二，你老婆关心以及认知你是从公司还是某些她不喜欢的店回来的，通常不关心你从哪条马路回来了。三，但你也不是一个流，除非哪天你有个孩子，并且孩子日志里写到：下午，爸爸陆陆续续地回来了。。。。。。。。。

## java中的流

Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。

标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中（供Java程序使用）的称为[输入流](https://www.zhihu.com/search?q=%E8%BE%93%E5%85%A5%E6%B5%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)

，将数据从内存写入外存中的称为[输出流](https://www.zhihu.com/search?q=%E8%BE%93%E5%87%BA%E6%B5%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)

。

流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。

流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。

流的分类：

流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：

1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。

2、按照处理数据的单位不同分，字节流和[字符流](https://www.zhihu.com/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)

，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。

3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的 一种流，FileInputStream是一个节点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。

流的类结构图：

![[z-oblib/z2-attachments/20191013212051298.png]]

![[z-oblib/z2-attachments/20191014111930276.png]]

Java中“流”的概念与简介

字节流与字符流：

字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是**基于字节流读取时，去查了指定的码表**。 字节流和字符流的区别：

读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。

处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。

结论：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。

这里需要提到的一句是：一个英文字符的长度是1byte，而汉字的长度是2byte. 如果我们把英汉混合的文档统一按照字节流处理，就会出现分割混乱，出现乱码。这是，我们需要使用字符流来处理。这就是为什么在处理文档的时候，都要把inputstream放到FileReader中。

方向性：

流分为输入流和输出流。但这都是相对的。特别是在Hadoop的序列化时，总是不知道到底使用输入流还是输出流。这里，我们可以做个区分：

序列化，就是把数据做字节流处理。而字节流只是一种存储形式。他不会被程序识别，需要把字节流反序列化为java识别的对象，才可以被java程序识别。所以，序列化就是字节流化，就是从java代码或内存中输出到外存。而反序列化就是对象化，就是从外存中将字节流数据转化为程序识别的对象。