---
title: 类加载器
created: 2022-06-24 17:17:04
updated: 2022-06-24 17:19:11
tags: 
- atom
---
# 类加载器

## 简介

一个可以将Java字节码加载为`java.lang.Class`实例的工具。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。

## 特点

- 动态加载，无需在程序一开始运行的时候加载，而是在程序运行的过程中，动态按需加载，字节码的来源也很多，压缩包jar、war中，网络中，本地文件等。类加载器动态加载的特点为热部署，热加载做了有力支持。
- 全盘负责，当一个类加载器加载一个类时，这个类所依赖的、引用的其他所有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。所以破坏双亲委派不能破坏扩展类加载器以上的顺序。

## 为何需要多个类加载器

**思考以下情景：**

1. **首先，是为了区分同名的类**：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 jvm 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？_当然是不同的应用都拥有自己独立的类加载器了。_
2. **其次，是为了更方便的加强类的能力**：类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？_一个比较方便的模式就是每个类库都可以使用独立的类加载器_

一个类的唯一性由加载它的类加载器和这个类的本身决定（类的全限定名+类加载器的实例ID作为唯一标识）。比较两个类是否相等（包括Class对象的`equals()`、`isAssignableFrom()`、`isInstance()`以及`instanceof`关键字等），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类就必定不相等。

jvm 需要有不同的类加载器，因为它一方面允许你在一个 jvm 里运行不同的应用程序，另一方面方便你独立的对不同类库进行运行时增强。

## 分类

从实现方式上，类加载器可以分为两种：一种是**启动类加载器**，由C++语言实现，是虚拟机自身的一部分；另一种是继承于`java.lang.ClassLoader`的类加载器，包括**扩展类加载器**、**应用程序类加载器**以及自定义类加载器。

### 启动类加载器

（`Bootstrap ClassLoader`）：负责加载`<JAVA_HOME>\lib`目录中的，或者被`-Xbootclasspath`参数所指定的路径，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。**启动类加载器无法被Java程序直接引用**，用户在编写自定义类加载器时，如果想设置`Bootstrap ClassLoader`为其`parent`，**可直接设置null**。

### 扩展类加载器

（`Extension ClassLoader`）：负责加载`<JAVA_HOME>\lib\ext`目录中的，或者被`java.ext.dirs`系统变量所指定路径中的所有类库。该类加载器由`sun.misc.Launcher$ExtClassLoader`实现。扩展类加载器由启动类加载器加载，其父类加载器为启动类加载器，即`parent=null`。

### 应用程序类加载器

（`Application ClassLoader`）：负责加载用户类路径（`ClassPath`）上所指定的类库，由`sun.misc.Launcher$App-ClassLoader`实现。开发者可直接通过`java.lang.ClassLoader`中的`getSystemClassLoader()`方法获取应用程序类加载器，所以也可称它为系统类加载器。应用程序类加载器也是启动类加载器加载的，但是它的父类加载器是扩展类加载器。在一个应用程序中，系统类加载器一般是默认类加载器。