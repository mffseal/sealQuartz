---
title: Java内存模型
created: 2022-04-29 21:18:23
updated: 2022-05-26 11:36:43
tags: 
- atom
---
# Java内存模型

## 运行时内存的划分

![[z-oblib/z2-attachments/Java运行时数据区.png]]
对于每一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]来说，**栈都是私有的**，而**堆是公有的**。

也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量，内存的可见性针对的是**共享变量**。

### 既然堆是共享的，为什么在堆中会有内存不可见?

这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。
> 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。

Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/2_0_2_1_2_0_0-Java/2_0_2_1_2_0_0_1-高级特性/JMM#JMM的抽象示意图|JMM的抽象示意图]]。
## 一个例子

> https://www.bilibili.com/video/BV16J411h7Rd?p=21&t=575.8

![[z-oblib/z2-attachments/Pasted image 20220526104910.png]]

1. 初始化时会将类加载到方法区。
2. jvm启动main方法作为主线程。
3. main线程栈中包含：
	1. 程序计数器：指向下一句要执行的代码地址。
	2. [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/2_0_2_1_2_0_0-Java/2_0_2_1_2_0_0_1-高级特性/栈帧|栈帧]]：每次调用其它函数都会生成一个运行时栈帧。
4. 每次调用一个方法，就会在main线程栈中创建一个目标方法的栈帧。
5. 局部变量可以指向堆空间的数组或者是对象。