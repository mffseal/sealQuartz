---
title: final
created: 2022-05-09 22:50:41
updated: 2022-06-07 18:13:12
tags: 
- #atom
---
# final

> final是可被继承的，这点和static不同。

## 修饰类

**不可继承**

当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

## 修饰方法

**不可重写**

>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。
>--摘自《Java编程思想》第四版第143页

- 如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。
- 类的private方法会隐式地被指定为final方法。

## 修饰变量

**不可变**

- 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
- 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

但是和static不同，final在声明时不进行初始化，但是后续只能给给未初始化的final变量赋值一次。再次赋值会报错。


## 原理

```java
public class TestFinal {
    final int a = 20;
}
```

字节码：

```java
0: aload_0
1: invokespecial #1                  // Method java/lang/Object."<init>":()V
4: aload_0
5: bipush        20
7: putfield      #2                  // Field a:I
    <-- 写屏障
10: return
```

发现 ﬁnal 变量的赋值也会通过 putﬁeld 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况

### 设置final

理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了

### 获取final


static变量的读取会用getstatic访问共享内存
而final static变量的读取，会把值赋值一份，避免共享：
- 变量较小则赋复制到当前线程的栈空间。
- 变量较大则复制到常量区。