<!doctype html><html lang=cn><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-6PZ4T4J4G8"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6PZ4T4J4G8")</script><meta name=baidu-site-verification content="codeva-gnZgwv8wOq"><meta charset=utf-8><meta name=description content="x86汇编快速入门 寄存器 CS : IP  物理地址 = 段地址 X 10H + 偏移地址  物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H   同一个物理地址可以由不同的段地址和偏移地址构成  段寄存器  CS: 代码段寄存器 (Code Segment)  主要关注此寄存器   DS: 数据段寄存器 (Data Segment) SS: 栈段寄存器 (Stach Segment) ES: 附加段寄存器 (Extra Segment)  程序执行 任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:"><title>x86汇编快速入门</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://mffseal.top//icon.png><link href=https://mffseal.top/styles.73cf69c3fd63eaf27dde453f5aa109f7.min.css rel=stylesheet><link href=https://mffseal.top/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://mffseal.top/js/darkmode.0044c532e9ace8b35200713c5a425353.min.js></script>
<script src=https://mffseal.top/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://mffseal.top/js/popover.53ad9a087e3feeaaa12b63bfd02d923b.min.js></script>
<script src=https://mffseal.top/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://mffseal.top/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://mffseal.top/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://mffseal.top/",fetchData=Promise.all([fetch("https://mffseal.top/indices/linkIndex.3d2d03102eda393ed53f6fd9593533e0.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://mffseal.top/indices/contentIndex.6bbd925b2c5b77b309b477f5c7b83caf.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://mffseal.top",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://mffseal.top",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/mffseal.top\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-NV58SYWRZD"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NV58SYWRZD",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=搜索 placeholder=搜一搜...><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://mffseal.top/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://mffseal.top/>🦭 港湾</a></h1><div class=spacer></div><div id=search-icon><p>搜索</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">搜索图标</title><desc id="desc">打开搜索图标</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>亮色</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>暗色</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>x86汇编快速入门</h1><p class=meta>最后更新
Sep 23, 2022
<a href="obsidian://open?vault=content&file=3-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%2f6-%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91%2f0-%e8%bd%af%e4%bb%b6%e8%af%ad%e8%a8%80%2f%e6%b1%87%e7%bc%96%2fx86%e6%b1%87%e7%bc%96%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8.md" rel=noopener>编辑源</a></p><ul class=tags><li><a href=https://mffseal.top/tags/article/>Article</a></li></ul><div class=toc-wrapper><div class=mainTOC id=mainTOC><aside><header><h3>x86汇编快速入门</h3></header><nav id=TableOfContents><ol><li><a href=#寄存器>寄存器</a><ol><li><a href=#cs--ip>CS : IP</a></li></ol></li><li><a href=#winodws-下的汇编工具>Winodws 下的汇编工具</a><ol><li><a href=#准备>准备</a></li><li><a href=#环境配置>环境配置</a></li><li><a href=#debug-工具>debug 工具</a></li></ol></li><li><a href=#分段管理及标志寄存器>分段管理及标志寄存器</a><ol><li><a href=#段寄存器和逻辑段>段寄存器和逻辑段</a></li></ol></li><li><a href=#标志寄存器>标志寄存器</a></li><li><a href=#指令及寻址方式>指令及寻址方式</a><ol><li><a href=#七种寻址方式>七种寻址方式</a></li><li><a href=#寻址方式分类>寻址方式分类</a></li></ol></li><li><a href=#常见汇编指令>常见汇编指令</a><ol><li><a href=#数据传送指令>数据传送指令</a></li><li><a href=#算数运算类指令>算数运算类指令</a></li><li><a href=#逻辑运算指令-位操作>逻辑运算指令 (位操作)</a></li><li><a href=#移位指令-位操作>移位指令 (位操作)</a></li><li><a href=#串操作>串操作</a></li><li><a href=#控制类指令>控制类指令</a></li></ol></li><li><a href=#opcode>OPCode</a><ol><li><a href=#opcode-主要数据域>OPCode 主要数据域</a></li><li><a href=#指令前缀>指令前缀</a></li><li><a href=#modrm>ModR/M</a></li><li><a href=#d-sib>D-SIB</a></li><li><a href=#位移>位移</a></li><li><a href=#立即数>立即数</a></li></ol></li></ol></nav></aside><a href=# id=toc-toggle></a></div></div><a href=#x86汇编快速入门><h1 id=x86汇编快速入门><span class=hanchor arialabel=Anchor># </span>x86汇编快速入门</h1></a><a href=#寄存器><h2 id=寄存器><span class=hanchor arialabel=Anchor># </span>寄存器</h2></a><a href=#cs--ip><h3 id=cs--ip><span class=hanchor arialabel=Anchor># </span>CS : IP</h3></a><ul><li>物理地址 = 段地址 X 10H + 偏移地址<ul><li>物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H</li></ul></li><li>同一个物理地址可以由不同的段地址和偏移地址构成</li></ul><a href=#段寄存器><h4 id=段寄存器><span class=hanchor arialabel=Anchor># </span>段寄存器</h4></a><ul><li>CS: 代码段寄存器 (Code Segment)<ul><li>主要关注此寄存器</li></ul></li><li>DS: 数据段寄存器 (Data Segment)</li><li>SS: 栈段寄存器 (Stach Segment)</li><li>ES: 附加段寄存器 (Extra Segment)</li></ul><a href=#程序执行><h4 id=程序执行><span class=hanchor arialabel=Anchor># </span>程序执行</h4></a><p>任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:</p><p><img src="/3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151311.png" width=auto></p><a href=#修改-csip-控制流程><h4 id=修改-csip-控制流程><span class=hanchor arialabel=Anchor># </span>修改 CS:IP 控制流程</h4></a><ol><li>修改 CS 和 IP<ol><li><code>jmp 段地址:偏移地址</code><ul><li><code>jmp 2AE3:3</code> -> 从 2AE33H 处读取指令</li><li><code>jmp 3:0B16</code> -> 从 00B46H 处读取指令</li></ul></li></ol></li><li>只修改 IP<ol><li><code>jmp 某合法寄存器</code><ul><li><code>jmp bx</code><ul><li>执行前: bx = 0B16H, CS = 2000H, IP = 0003H</li><li>执行后: BX = 0B16H, CS = 2000H, IP = 0B16H</li></ul></li><li><code>jmp bx</code> 类似 <code>mov IP, bx</code> (把寄存器的值当作 IP)</li></ul></li></ol></li></ol><a href=#winodws-下的汇编工具><h2 id=winodws-下的汇编工具><span class=hanchor arialabel=Anchor># </span>Winodws 下的汇编工具</h2></a><a href=#准备><h3 id=准备><span class=hanchor arialabel=Anchor># </span>准备</h3></a><ul><li>DOSBox 环境模拟器</li><li>debug.exe<ul><li>win7 及以上系统不自带</li></ul></li></ul><a href=#环境配置><h3 id=环境配置><span class=hanchor arialabel=Anchor># </span>环境配置</h3></a><ol><li><p>安装 DOSBox0.74-win32-installer.exe</p></li><li><p>自动配置 DOSBox 操作目录</p><ol><li>运行安装目录中的 <code>DOSBox 0.74 Options.bat</code></li><li>弹出的配置文件中加入如下内容:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MOUNT C E:\masmpro         # 将后面的目录挂载到dos的c盘符下
</span></span><span class=line><span class=cl>set PATH=$PATH$;E:\masmpro # $PATH$代表已有环境变量, 后面是当前目录
</span></span><span class=line><span class=cl>目录不能带中文和空格.
</span></span></code></pre></td></tr></table></div></div><p>``</p></li><li><p>手动配置 DOSBox 操作目录</p><ol><li>启动 dosbox</li><li>手动输入 <code>MOUNT C E:\masmpro</code></li></ol></li><li><p>配置 masmpro</p><ol><li>将 debug.exe 等软件拷贝到目录下</li></ol></li></ol><a href=#debug-工具><h3 id=debug-工具><span class=hanchor arialabel=Anchor># </span>debug 工具</h3></a><ul><li><p>debug 是 Dos, Windows 提供的实模式 (8086方式) 程序的调试工具</p></li><li><p>debug 功能</p><ul><li>查看 CPU 各个寄存器内容</li><li>查看内存情况</li><li>在机器码级别跟踪程序的运行</li></ul></li><li><p>常用操作</p><ul><li><code>R</code> 查看更改 cpu 寄存器内容<ol><li><code>R AX</code></li><li>出现 <code>:</code> 后输入要写入的数据</li><li>回车</li><li>再按 <code>R</code> 查看修改情况</li></ol></li><li><code>D</code> 查看内存内容<ul><li><code>D 段地址:偏移地址</code></li></ul></li><li><code>E</code> 改写内存内容</li><li><code>U</code> 将内存中机器指令翻译为汇编指令</li><li><code>T</code> 执行一条机器指令</li><li><code>A</code> 以汇编格式在内存中写入一条指令</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>参考 王爽 &lt;汇编语言第三版&gt; p35.
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#分段管理及标志寄存器><h2 id=分段管理及标志寄存器><span class=hanchor arialabel=Anchor># </span>分段管理及标志寄存器</h2></a><ul><li>一个存储单元有一个物理地址<ul><li>一个存储单元的编号</li><li>每个物理存储单元都有一个 20 位编号</li><li>8086CPU 物理地址范围: 00000H ~ FFFFFH</li><li>物理地址为逻辑地址左移 4 位 (乘以10h), 加上偏移地址<ul><li><code>1230:100</code>, <code>1030:2100</code>, <code>1100:1400</code> 对应的物理地址都是 <code>12400</code></li></ul></li></ul></li><li>一个存储单元对应多个逻辑地址<ul><li>用户编程时, 采用逻辑地址<ul><li><code>段基地址 : 段内偏移地址</code></li></ul></li></ul></li></ul><a href=#段寄存器和逻辑段><h3 id=段寄存器和逻辑段><span class=hanchor arialabel=Anchor># </span>段寄存器和逻辑段</h3></a><ul><li><p>8086CPU 有 4 个段寄存器</p></li><li><p>每个段寄存器用来确定一个逻辑段的起始位置</p></li><li><p>每种逻辑段均有自己的用途</p><ul><li>CS: 代码段寄存器 (Code Segment)<ul><li>利用 CS:IP 取得下一条要执行的指令</li></ul></li><li>DS: 数据段寄存器 (Data Segment)<ul><li>利用 DS:EA 存取数据段中的数据</li></ul></li><li>SS: 栈段寄存器 (Stach Segment)<ul><li>利用 CS:IP 操作堆栈顶的数据</li></ul></li><li>ES: 附加段寄存器 (Extra Segment)<ul><li>利用 ES:EA 存取附加段中的数据</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a style=outline:none;text-decoration:none;color:inherit href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>- EA 是偏移地址, 称之为有效地址 EA
</span></span><span class=line><span class=cl>- 若操作数在主存中, 存取的方式有:
</span></span><span class=line><span class=cl>    - 直接寻址
</span></span><span class=line><span class=cl>    - 寄存器间接寻址
</span></span><span class=line><span class=cl>    - 寄存器相对寻址
</span></span><span class=line><span class=cl>    - 基址变址寻址
</span></span><span class=line><span class=cl>    - 相对基址变址寻址
</span></span></code></pre></td></tr></table></div></div></li><li><p>没有指明段前缀时, 一般的数据访问在 DS (u数据) 段</p><ul><li><code>MOV AX, [1000H]</code> == <code>MOV AX,DS:[1000H]</code><ul><li>从默认的 DS 段中取出数据</li></ul></li><li><code>MOV AX,CS:[1000H]</code><ul><li>从指定的 CS 段取出数据</li></ul></li></ul></li></ul><a href=#标志寄存器><h2 id=标志寄存器><span class=hanchor arialabel=Anchor># </span>标志寄存器</h2></a><p>结构图:</p><p><img src="/3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151340.png" width=auto></p><p>含义:</p><p><img src="/3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151353.png" width=auto></p><ul><li>状态标志<ul><li>用于记录程序运行结果的状态信息<ul><li>CF 进位标志 (Carry Flag)<ul><li>当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0</li></ul></li><li>ZF 零标志 (Zero Flag)<ul><li>弱运算结果为 0, 则置 1, 否则 0</li></ul></li><li>SF 符号标志 (Sign Flag)<ul><li>若运算结果最高位(符号位)为 1, 则置 1, 否则 0</li></ul></li><li>PF 奇偶标志 (Parity Flag)<ul><li>运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0</li></ul></li><li>OF 溢出标志 (Overflow Flag)<ul><li>运算结果有溢出, 则置 1, 否则 0</li><li>溢出: 有符号数的运算结果不正确</li></ul></li><li>AF 辅助进位标志 (Auxiliary Carry Flag)<ul><li>运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0</li></ul></li></ul></li></ul></li><li>控制标志<ul><li>用于控制处理器执行指令<ul><li>DF 方向标志 (Direction Flag)<ul><li>用于串操作指令, 控制地址的变化方向</li><li>1 则存储器地址自动增加</li><li>0 则存储器地址自动减少</li><li><code>CLD</code> 用于复位 DF = 0</li><li><code>STD</code> 用于置位 DF = 1</li></ul></li><li>IF 终端允许标志 (Interrupt-enable Flag)<ul><li>0 禁止中断</li><li>1 允许中断</li><li><code>CLI</code> 用于复位 IF = 0</li><li><code>STI</code> 用于置位 IF = 1</li></ul></li><li>TF 陷阱标志 (Trap Flag)<ul><li>0 处理器正常工作</li><li>1 处理器单步执行</li></ul></li></ul></li></ul></li></ul><a href=#指令及寻址方式><h2 id=指令及寻址方式><span class=hanchor arialabel=Anchor># </span>指令及寻址方式</h2></a><ul><li>零操作数指令</li><li>一操作数指令</li><li>二操作数指令<ul><li><code>操作码 目的操作数 源操作数</code></li></ul></li></ul><a href=#七种寻址方式><h3 id=七种寻址方式><span class=hanchor arialabel=Anchor># </span>七种寻址方式</h3></a><blockquote><p>寻址方式: 指令中指明操作数存放位置的表达方式.</p></blockquote><p>指令中操作数的数据存放位置有 3 种情况:</p><ul><li>存放指令中 (立即数)<ul><li>操作数包含在指令中</li><li>备操作数据直接表示在指令的操作数字段中</li><li>紧跟在操作码之后</li><li>例如 <code>MOV AL, 10H</code></li></ul></li><li>存放于寄存器中 (寄存器操作数)<ul><li>数据存放在 CPU 的一个寄存器中</li><li>例如 <code>INC CX</code></li></ul></li><li>存放于存储器中 (存储器操作数)<ul><li>数据再内存或 I/I 端口中</li><li>存放数据的偏移地址以某种方式表示在指令中</li><li>例如 <code>MOV AX, [2500H]</code><ul><li>其中 [2500] 为存储器操作数</li><li>存储器操作数中操作的数字段指示此操作数的偏移地址</li><li>段地址由某个段寄存器提供</li><li>默认为 DS 提供</li></ul></li></ul></li></ul><a href=#寻址方式分类><h3 id=寻址方式分类><span class=hanchor arialabel=Anchor># </span>寻址方式分类</h3></a><ul><li>立即数寻址<ul><li>操作数为立即数</li><li>直接存放在指令的操作数字段</li><li>只允许源操作数为立即数</li><li>目标操作数必须是寄存器或存储单元<ul><li>给寄存器或存储单元赋值</li></ul></li></ul></li><li>寄存器寻址<ul><li>直接在指令中写出寄存器名称</li></ul></li><li>存储器寻址<ul><li>直接寻址<ul><li>操作数存在内存中, 操作数的偏移地址直接表示在指令中</li><li>表示格式: [偏移地址]</li><li>默认操作数存放在内存的数据段中</li><li>例如 <code>MOV AL, [1064H]</code></li><li>段超越指明使用的段</li></ul></li><li>寄存器间接寻址</li><li>基址加变址寻址</li><li>相对加基址变址寻址</li></ul></li></ul><a href=#常见汇编指令><h2 id=常见汇编指令><span class=hanchor arialabel=Anchor># </span>常见汇编指令</h2></a><a href=#数据传送指令><h3 id=数据传送指令><span class=hanchor arialabel=Anchor># </span>数据传送指令</h3></a><a href=#通用传送指令><h4 id=通用传送指令><span class=hanchor arialabel=Anchor># </span>通用传送指令</h4></a><blockquote><p>所有通用传送指令都不影响标志位.</p></blockquote><ul><li>MOV DST, SRC;<ul><li>将 SRC 内容赋值给 DST</li><li>存储器操作数之间不能直接传递<ul><li>反例: <code>MOV [1000H], [DI]</code></li><li>应改为: <code>MOV AX, [DI]</code>; <code>MOV [1000H], AX</code></li></ul></li><li>立即数不能直接给段寄存器<ul><li>反例: <code>MOV DS, 2000H</code></li><li>应改为: <code>MOV AX, 2000H</code>, <code>MOV DS, AX</code></li></ul></li><li>段寄存器之间不能直接传递</li><li>CS 值可以作为源操作数</li><li>源操作数和目的操作数宽度必须相等</li></ul></li></ul><p><img src="/3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151408.png" width=auto></p><a href=#堆栈指令><h4 id=堆栈指令><span class=hanchor arialabel=Anchor># </span>堆栈指令</h4></a><blockquote><p>后进先出.<br>赋值遵循高高低低原则.</p></blockquote><ul><li>PUSH src<ol><li>(SP) &lt;- (SP) - 2<ul><li>堆栈操作以字为单位, 所以 -2</li></ul></li><li>((SP)+1,(SP)) &lt;- (src)</li></ol></li><li>POP<ul><li>把 SP 所指向的堆栈顶部的一个字送入目的地址, 同时谢盖堆栈指针</li></ul><ol><li>(dst) &lt;- ((SP)+1,(SP))</li><li>(SP) &lt;- (SP)+2</li></ol></li></ul><a href=#交换指令><h4 id=交换指令><span class=hanchor arialabel=Anchor># </span>交换指令</h4></a><ul><li>XCHG dst, src<ul><li>可以实现寄存器之间, 寄存器和存储器之间的交换操作</li><li>存储器之间不能直接交换</li><li>段寄存器不能作为操作数</li><li>允许字或字节操作</li></ul></li></ul><a href=#输入指令><h4 id=输入指令><span class=hanchor arialabel=Anchor># </span>输入指令</h4></a><ul><li>IN<ul><li>用于 CPU 从外设端口接收数据</li></ul></li></ul><a href=#输出指令><h4 id=输出指令><span class=hanchor arialabel=Anchor># </span>输出指令</h4></a><ul><li>OUT<ul><li>用于 CPU 向外设端口传输数据</li></ul></li></ul><a href=#目的地址传送指令><h4 id=目的地址传送指令><span class=hanchor arialabel=Anchor># </span>目的地址传送指令</h4></a><ul><li>LEA reg16, mem<ul><li>reg16 &ndash; 16位通用寄存器</li><li>mem &ndash; 存储单元</li><li>将元操作数的偏移地址传给目的操作数</li><li>源操作数必须以寄存器间接寻址, 变址寻址, 基址加变址寻址等方式表示的存储器操作数</li></ul></li><li>LDS reg16, mem</li></ul><a href=#标志传送指令><h4 id=标志传送指令><span class=hanchor arialabel=Anchor># </span>标志传送指令</h4></a><ul><li>LAHF<ul><li>将标志寄存器低八位传送给 AH</li></ul></li><li>SAHF<ul><li>将 AH 赋值给标志寄存器低八位</li></ul></li><li>PUSHF<ul><li>标志进栈</li></ul></li><li>POPF<ul><li>标志出栈</li></ul></li></ul><a href=#算数运算类指令><h3 id=算数运算类指令><span class=hanchor arialabel=Anchor># </span>算数运算类指令</h3></a><a href=#加法指令><h4 id=加法指令><span class=hanchor arialabel=Anchor># </span>加法指令</h4></a><ul><li>ADD (Addition) 加法指令<ul><li><code>ADD dest, src</code></li><li>(data) &lt;- (dest) + (src)</li><li>源和目的不能同时为存储器, 不能为段寄存器</li></ul></li><li>ADC (Add with Carry) 带进位加法指令<ul><li><code>ADC dest, src</code></li><li>(dest) &lt;- (dest) + (src) + C</li><li>C 是上一条指令的进位结果</li><li>用于多字节拆分运算</li></ul></li><li>INC (Increment) 加 1 指令<ul><li><code>INC dest</code></li><li>(dest) &lt;- (dest) + 1</li><li>多用于循环中修改地址指针和循环次数</li><li>影响标志位 S, Z, A, P, O</li></ul></li></ul><a href=#减法指令><h4 id=减法指令><span class=hanchor arialabel=Anchor># </span>减法指令</h4></a><ul><li>SUB<ul><li><code>SUB dest, src</code></li><li>(data) &lt;- (dest) - (src)</li></ul></li><li>SBB<ul><li><code>SBB dest, src</code></li><li>(dest) &lt;- (dest) - (src) - C</li></ul></li><li>DEC<ul><li><code>DEC dest</code></li><li>(dest) &lt;- (dest) - 1</li><li>多用于循环中修改地址指针和循环次数</li><li>影响标志位 S, Z, A, P, O</li></ul></li></ul><a href=#求补指令><h4 id=求补指令><span class=hanchor arialabel=Anchor># </span>求补指令</h4></a><ul><li><code>NEG dest</code><ul><li>(dest) &lt;- 0 - (dest)</li><li>把操作数按位求反再加一</li></ul></li></ul><a href=#比较指令><h4 id=比较指令><span class=hanchor arialabel=Anchor># </span>比较指令</h4></a><ul><li><code>CMP dest, src</code><ul><li>(dest) - (src)</li><li>结果不保留, 只用来影响标志位<ul><li>A, C, O, P, S, Z</li></ul></li><li>比较两个数的大小关系<ul><li>Z: 判断两者是否相等</li><li>C: 判断两个无符号数的大小</li><li>S, O: 判断两个带符号数的大小</li></ul></li><li>cmp 算术减法运算结果为零,就把ZF(零标志)置1</li></ul></li></ul><a href=#乘法指令><h4 id=乘法指令><span class=hanchor arialabel=Anchor># </span>乘法指令</h4></a><ul><li>MUL 无符号乘法<ul><li><code>MUL SRC</code></li><li>字节操作数: AX &lt;- (AL) * (SRC)</li><li>字操作数: DX:AX &lt;- (AX) * (SRC)</li></ul></li><li>IMUL 带符号乘法<ul><li>与上面类似</li></ul></li></ul><a href=#除法指令><h4 id=除法指令><span class=hanchor arialabel=Anchor># </span>除法指令</h4></a><ul><li>DIV 无符号除法<ul><li><code>DIV SRC</code></li><li>字节除法:<ul><li>AL &lt;- (AX) / (SRC) 的商</li><li>AL &lt;- (AX) / (SRC) 的余数</li></ul></li><li>字除法:<ul><li>AL &lt;- (DX:AX) / (SRC) 的商</li><li>AL &lt;- (DX:AX) / (SRC) 的余数</li></ul></li></ul></li><li>IDIV 有符号除法<ul><li>与上面类似</li></ul></li></ul><a href=#逻辑运算指令-位操作><h3 id=逻辑运算指令-位操作><span class=hanchor arialabel=Anchor># </span>逻辑运算指令 (位操作)</h3></a><ul><li>AND dest, src<ul><li>(dest) &lt;- (dest) and (src)</li></ul></li><li>TEST dest, src<ul><li>与 and 类似</li><li>不保存结果, 只改变标志位</li><li>test逻辑与运算结果为零,就把ZF(零标志)置1</li></ul></li><li>OR dest, src<ul><li>与 and 相反</li></ul></li><li>XOR dest, src<ul><li>相同为 0</li></ul></li><li>NOT dest<ul><li>按位取反</li></ul></li></ul><a href=#移位指令-位操作><h3 id=移位指令-位操作><span class=hanchor arialabel=Anchor># </span>移位指令 (位操作)</h3></a><ul><li>SAL (Shift Arithmetic Left) 算术左移<ul><li>相当于无符号乘以2^n</li><li>最低位填充 0</li></ul></li><li>SAR (shift arithmetic right) 算术右移<ul><li>最高位不变</li><li>最低位移入寄存器 CL</li></ul></li><li>SHL (shift logical left) 逻辑左移<ul><li>相当于无符号乘以2^n</li><li>最低位填充 0</li></ul></li><li>SHR (shift logical right) 逻辑右移<ul><li>相当于无符号除以2^n</li><li>最高位填充 0</li><li>最低位进入寄存器 CF</li></ul></li><li>ROL (rotate left) 循环左移<ul><li>最高位放入最低位</li><li>最高位复制到 CF</li></ul></li><li>ROR (rotate right) 循环右移<ul><li>最低位放入最高位</li><li>最低位复制到 CF</li></ul></li><li>RCL (rotate left with carry) 带进位循环左移<ul><li>CF 进位值放低位</li><li>高位放 CF</li></ul></li><li>RCR (rotate right with carry) 带进位循环右移<ul><li>CF 进位值放高危</li><li>低位放 CF</li></ul></li></ul><p>指令格式:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>操作码 reg/mem, count   # count=1或CL, 指定移位次数
</span></span></code></pre></td></tr></table></div></div><a href=#串操作><h3 id=串操作><span class=hanchor arialabel=Anchor># </span>串操作</h3></a><blockquote><p>串是内存中一段地址相连的字节或字.</p></blockquote><ul><li>串操作也叫数据块操作</li><li>可实现存储器数据间的直接传送</li><li>8086 有 5 种基本串操作</li><li>对字操作以 B 结尾, 对字节操作以 W 结尾<ul><li>MOVS (move string) 串传送</li><li>CMPS (compare string) 串比较</li><li>SCAS (scan string) 串扫描</li><li>LODS (load from string) 取串</li><li>STOS (store in to string) 存串</li><li>REP 重复串操作执行过程<ul><li>当 CX != 0 则执行 CX &lt;- CX - 1, 再执行后续串指令</li><li>当 CX == 0, 结束 REP, 执行下一条指令</li></ul></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>可以不借助寄存器直接在存储器间传递数据.
</span></span></code></pre></td></tr></table></div></div><a href=#控制类指令><h3 id=控制类指令><span class=hanchor arialabel=Anchor># </span>控制类指令</h3></a><a href=#非条件转移><h4 id=非条件转移><span class=hanchor arialabel=Anchor># </span>非条件转移</h4></a><ul><li>JMP<ul><li><code>JMP 位置</code></li></ul></li></ul><a href=#条件转义><h4 id=条件转义><span class=hanchor arialabel=Anchor># </span>条件转义</h4></a><ul><li>根据单个条件标志<ul><li>Z 标志<ul><li>JZ / JNZ (jump on zero; jump on no zero)</li></ul></li><li>C 标志<ul><li>JC / JNC (jump if carry)</li></ul></li><li>p 标志<ul><li>JP (JPE) / JNP (JPO) (jump on parity; jump on even; jump on odd)</li></ul></li><li>S 标志<ul><li>JS (负号跳转) / JNS</li></ul></li><li>0<ul><li>JO (溢出跳转) / JNO</li></ul></li></ul></li><li>根据两个无符号数大小关系<ul><li>JB 低于跳转</li><li>JBE 不高于跳转</li><li>JA 高于跳转</li><li>JAE 高于等于跳转</li><li>JNB 不低于跳转</li></ul></li><li>根据两个带符号数比较结果<ul><li>JL (JNGE) 小于跳转</li><li>JNL (JGE) 不小于跳转</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a style=outline:none;text-decoration:none;color:inherit href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>所有条件转义指令都是段内 (-128 ~ +127) 范围内转移
</span></span></code></pre></td></tr></table></div></div><a href=#过程子程序调用><h4 id=过程子程序调用><span class=hanchor arialabel=Anchor># </span>过程(子程序)调用</h4></a><ul><li>自程序调用<ul><li>CALL 子过程名</li></ul></li><li>返回指令<ul><li>RET<ul><li>在子程序的结尾</li><li>用于返回主程序</li></ul></li></ul></li></ul><a href=#无条件循环><h4 id=无条件循环><span class=hanchor arialabel=Anchor># </span>无条件循环</h4></a><ul><li>LOOP 语句标号<ul><li>CX &lt;- CX - 1</li><li>若 CX != 0 转向目标地址去执行</li><li>否则执行 LOOP 之后的指令</li><li>过程解释<ol><li>首先执行 CX = CX - 1</li><li>判断 CX 的值</li><li>若 CX != 0 则转移到 Lable 处执行</li><li>否则向下继续</li></ol></li></ul></li></ul><a href=#条件循环><h4 id=条件循环><span class=hanchor arialabel=Anchor># </span>条件循环</h4></a><ul><li>LOOPZ / LOOPE 语句标号<ul><li>CX &lt;- CX - 1</li><li>若 CX != 0 且 ZF == 1, 转向目标地址执行</li><li>否则执行之后的语句</li><li>过程解释<ul><li>首先执行 CX = CX - 1</li><li>判断 CX != 0 和 ZF == 1 满足则转到 Lable 执行</li><li>否则向下继续</li></ul></li></ul></li></ul><a href=#中断指令><h4 id=中断指令><span class=hanchor arialabel=Anchor># </span>中断指令</h4></a><ul><li>中断调用<ul><li>INT n</li><li>n为中断号, 0 ~ 255</li></ul></li><li>中断返回<ul><li>IRET</li></ul></li></ul><a href=#标志处理指令><h4 id=标志处理指令><span class=hanchor arialabel=Anchor># </span>标志处理指令</h4></a><ul><li>CLC (clear carry flag) 清 C</li><li>STC (set carry flag) 置 C</li><li>CMC (complement carry flag) C 求反</li><li>CLD (clear direction flag) 清 D</li><li>STD (set direction flag) 置 D</li><li>CLI (clear interrupt flag) 清 I</li><li>STI (set interrupt enable flag) 置 I</li></ul><a href=#其它处理机控制指令><h4 id=其它处理机控制指令><span class=hanchor arialabel=Anchor># </span>其它处理机控制指令</h4></a><ul><li>NOP (no operation)</li></ul><a href=#opcode><h2 id=opcode><span class=hanchor arialabel=Anchor># </span>OPCode</h2></a><ul><li>一个 opcode 不一定对应一条汇编指令</li><li>一条汇编指令不一定对应一个 opcode</li></ul><a href=#opcode-主要数据域><h3 id=opcode-主要数据域><span class=hanchor arialabel=Anchor># </span>OPCode 主要数据域</h3></a><p><img src="/3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151425.png" width=auto></p><ul><li>以上只有 Code 域是必须存在的</li><li>其它数据域视指令格式而定有无</li><li>一个指令的长度在 <code>1Byte ~ 16Byte</code> 之间</li><li>实际正常的最长指令为 <code>13Byte</code></li></ul><a href=#指令前缀><h3 id=指令前缀><span class=hanchor arialabel=Anchor># </span>指令前缀</h3></a><ul><li>前缀(Prefixes)大小为 `Byte, 可以被划分为 5 个集合<ul><li>切换操作数大小 66</li><li>切换地址大小 67<ul><li>切换是特指在 2 种状态间切换, 而非切换到特指的某状态</li></ul></li><li>重复操作前缀 F2/F3</li><li>修改默认段 2E/36/3E/26/64/65<ul><li>将默认值修改为其它段</li></ul></li><li>锁定前缀 F0</li></ul></li><li>这些指令独此一份, 不可能为其它机器码</li><li>如果有多个 prefixes, 顺序可能是乱序</li><li>如果 prefixes 不能对后续的 opcode 起作用, 那就被忽略</li><li>出现特定操作码时用作补充说明, 一般是指令冒号前的部分</li></ul><a href=#modrm><h3 id=modrm><span class=hanchor arialabel=Anchor># </span>ModR/M</h3></a><ul><li>辅助说明操作码的操作数<ul><li>操作数的个数</li><li>操作数的种类 [寄存器, 内存地址, 常量]</li></ul></li></ul><a href=#d-sib><h3 id=d-sib><span class=hanchor arialabel=Anchor># </span>D-SIB</h3></a><ul><li>用来辅助说明 ModR/M</li><li>辅助寻址</li><li>需要和 ModR/M 一起使用</li></ul><a href=#位移><h3 id=位移><span class=hanchor arialabel=Anchor># </span>位移</h3></a><ul><li>操作码的操作数为内存地址事, 用来表示位移操作</li></ul><a href=#立即数><h3 id=立即数><span class=hanchor arialabel=Anchor># </span>立即数</h3></a><ul><li>操作码的操作数是常量, 该常量为立即数</li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>反向链接</h3><ul class=backlinks><li>无反向链接</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>湾区地图</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://mffseal.top/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p><a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/><img alt="Creative Commons Licence" style=border-width:0 src=https://i.creativecommons.org/l/by-nc/4.0/88x31.png></a><br>本博客的博主原创文章均遵循 <a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/>CC BY-NC(署名-非商业性使用) 4.0 国际协议</a><br>转载请附上原文出处链接及本声明</p><p>由 mffseal 使用 <a href=https://github.com/jackyzha0/quartz>Quartz</a> 开发, © 2023</p><ul><li><a href=https://mffseal.top/>港口</a></li><li><a href=https://github.com/mffseal>Github</a></li></ul></footer></div></div></body></html>