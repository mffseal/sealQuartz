{"/":{"title":"🦭海豹湾","content":"\n**海豹港湾，第二大脑**\n\n海豹的视线：网络安全 | 逆向 | 二进制 | Java 开发 | 物联网安全 | TEE | 区块链\n\n---\n\n# 🦭海豹湾\n\n湾区建设状态：\n\n[![上传](https://github.com/mffseal/sealQuartz/actions/workflows/deploy.yaml/badge.svg)](https://github.com/mffseal/sealQuartz/actions/workflows/deploy.yaml) [![构建](https://github.com/mffseal/sealQuartz/actions/workflows/pages/pages-build-deployment/badge.svg)](https://github.com/mffseal/sealQuartz/actions/workflows/pages/pages-build-deployment)\n\n知识最小单位为 atom，由多个 atom 组合成 article，构建知识图谱，降低内容冗余度，不断精炼内容输出。\n\n[所有article文章](https://harbor.mffseal.top/tags/article) | [所有atom项](https://harbor.mffseal.top/tags/atom)\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6":{"title":"数字证书","content":"\n# 数字证书\n\n最简单的证书包含公钥、名称以及证书授权中心的数字签名。\n一般情况下证书中还包括密钥的有效期，颁发者（证书授权中心）的名称，该证书的序列号等信息，证书的结构遵循X.509 v3版本的规范。\n\n## 字段解释\n\n![[2-数学/2_0_0_2-密码学/z-attachments/Pasted image 20220928021147.png]]\n\n- 版本：即使用X.509的版本，目前普遍使用的是v3版本（0x2）。\n- 序列号：颁发者分配给证书的一个正整数，同一颁发者颁发的证书序列号各不相同，可用与颁发者名称一起作为证书唯一标识。\n- 签名算法：颁发者颁发证书使用的签名算法。\n- 颁发者：颁发该证书的设备名称，必须与颁发者证书中的主体名一致。通常为[[2-数学/2_0_0_2-密码学/CA|CA]]服务器的名称。\n- 有效期：包含有效的起、止日期，不在有效期范围的证书为无效证书。\n- 主体名：证书拥有者的名称，如果与颁发者相同则说明该证书是一个自签名证书。\n- 公钥信息：用户对外公开的公钥以及公钥算法信息。\n- 扩展信息：通常包含了证书的用法、[[2-数学/2_0_0_2-密码学/CRL|CRL]]的发布地址等可选字段。\n- 签名：颁发者用私钥对证书信息的签名。\n\n## 证书类型\n\n- 自签名证书：自签名证书又称为根证书，是自己颁发给自己的证书，即**证书中的颁发者和主体名相同**。\n- CA证书：CA自身的证书。如果[[2-数学/2_0_0_2-密码学/PKI|PKI]]系统中没有多层级CA，CA证书就是自签名证书；如果有多层级CA，则会形成一个CA层次结构，最上层的CA是根CA，它拥有一个CA“自签名”的证书。\n- 本地证书：CA颁发给申请者的证书。\n- 设备本地证书：设备根据CA证书给自己颁发的证书，证书中的颁发者名称是CA服务器的名称。\n\n## 证书格式\n\n1. PKCS#12：以二进制格式保存证书，可以包含私钥，也可以不包含私钥。常用的后缀有：.P12和.PFX。\n2. DER：以二进制格式保存证书，不包含私钥。常用的后缀有：.DER、.CER和.CRT。\n3. PEM：以ASCII码格式保存证书，可以包含私钥，也可以不包含私钥。常用的后缀有：.PEM、.CER和.CRT。\n\n\u003e 对于证书后缀为.CER或.CRT，可以用记事本打开证书，查看证书内容来区分证书格式。\n\u003e \n\u003e -   如果有类似＂—–BEGIN CERTIFICATE—–＂和＂—–END CERTIFICATE—–＂的头尾标记，则证书格式为PEM。\n\u003e -   如果是乱码，则证书格式为DER\n\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%94%A8%E6%88%B7%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91%E6%96%B9%E5%BC%8F":{"title":"用户证书签发方式","content":"\n# 用户证书签发方式\n\n两种方式：\n1. 由 CA 直接来生成证书（内含公钥）和对应的私钥发给用户；\n1. 由用户自己生成公钥和私钥，然后由 CA 来对公钥内容进行签名。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%AF%81%E4%B9%A6%E6%92%A4%E9%94%80":{"title":"证书撤销","content":"\n# 证书撤销\n\n证书超出有效期后会作废，用户也可以主动向 [[2-数学/2_0_0_2-密码学/CA|CA]] 申请撤销某证书文件，由于 CA 无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个[[2-数学/2_0_0_2-密码学/CRL|CRL]]。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7":{"title":"证书申请","content":"\n# 证书申请\n\n## 前置条件\n\n1. 同步时间：时间是PIK系统的重中之重，必须先确保参加[[2-数学/2_0_0_2-密码学/PKI|PKI]]系统的设备和主机的时间同步。才能开始PKI的部署。当设备的时间慢与证书有效期的开始时间或者设备时间大于证书有效期的结束时间那么证书都是无效的。 忌讳：设备时间比证书服务器的时间慢。\n2. 部署证书服务器。证书服务器是整个PKI系统的核心。可以选择微软的证书服务器。\n3. 客户端产生密钥对。每一个实体在申请证书之前，需要预先产生RSA的秘钥对。\n4. 验证证书服务器的合法性。每一个实体需要获取证书服务器的根证书，里面包含证书服务器的公钥。获取了根证书后，可以通过fingerprint离先验证证书服务器。\n5. 申请个人证书。每一个实体发送自己的个人信息和公钥到PKI。（在线和离线方式）\n6. [[2-数学/2_0_0_2-密码学/RA|RA]]审核并签名证书。管理员对每一个证书请求进行审核，并对个人信息和公钥内容进行数字签名，签名后的文件即为[[2-数学/2_0_0_2-密码学/数字证书|数字证书]]。\n7. [[2-数学/2_0_0_2-密码学/CA|CA]]颁发数字证书给设备。证书服务器把签名的[[2-数学/2_0_0_2-密码学/证书颁发|证书颁发]]给实体。\n8. 设备相互交换证书。\n\n## 证书申请方式\n\n- SCEP（Simple Certificate Enrollment Protocol）for VPN devices。\n- File-based（PKCS#10）\n- Web-based(browser-to-CA)\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91":{"title":"证书颁发","content":"\n# 证书颁发\n\n- 每个实体都要获取[[2-数学/2_0_0_2-密码学/CA|CA]]的公钥（认证CA的过程）\n- 每个实体都要提交自己的公钥给CA（注册到PKI）\n- 这个初始步骤，必须手动认证或者通过一个可信任的传输网络来执行。\n- CA使用自己的私钥为提交的公钥做数字签名。\n- 被数字签了名的公钥（身份证书）再返回给实体。\n- 实体现在可以通过非信任的网络来彼此交换被CA签了名的公钥了。\n- 收到的公钥都是被CA的公钥所确认的，CA的公钥在每个实体本地必须是有效的。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81":{"title":"证书验证","content":"\n# 证书验证\n\n## 准备阶段\n\n- 实体A：需要有A的公钥、A的私钥、A证书、CA证书\n- 实体B：需要有B的公钥、B的私钥、B证书、CA证书\n\n\u003e A证书内容：【A公钥 + CA私钥签名[Hash（A的公钥 + 个人信息）]】\n\u003e B证书内容：【B公钥 + CA私钥签名[Hash（B的公钥 + 个人信息）]】\n\u003e CA证书内容：【CA公钥 + CA私钥签名[Hash（CA的公钥 + 个人信息）]】\n\n互相交换交换证书后，实体A有了B证书，实体B有了A证书。\n\n## 验证证书合法性\n\n举例：A验证B证书是否合法：\n\n\u003e B证书内容：【B公钥 + CA私钥签名[Hash（B的公钥 + 个人信息）]】\n\u003e CA证书内容：【CA公钥 + CA私钥签名[Hash（CA的公钥 + 个人信息）]】\n\n1. 用CA公解密B证书——得到HASH值12345。\n2. 使用B证书提供的个人信息，公钥，签名算法也做HASH值得到12345 。\n3. 如果两次hash值相同，即验证了B证书的合法。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/CA":{"title":"CA","content":"\n# CA\n\nCertification Authority，认证中心。\n\n负责证书的颁发和吊销（Revoke），接收来自 [[2-数学/2_0_0_2-密码学/RA|RA]] 的请求，是最核心的部分。\n\n## 存在意义\n\n即使是非对称加密系统，也不能保证公钥的分发是可靠的。 为了防范公钥分发过程中的中间人攻击，需要一个可信的\"始祖\"公证人，这就是CA机构存在的意义。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/CRL":{"title":"CRL","content":"\n# CRL\n\n证书撤销列表 (Certificate Revocation List, CRL) 用于列出客户机或服务器用户不应再信任的所有证书和密钥。如果证书中的数据发生变化（例如，用户在证书到期之前换单位或离职），该证书将被撤销，并且其数据将显示在 CRL 中。CRL 由 [[2-数学/2_0_0_2-密码学/CA|CA]] 生成并定期更新。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/CSR":{"title":"CSR","content":"\n# CSR\n\nCertificate Signing Request，证书签名请求文件。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/DES":{"title":"DES","content":"# DES\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/PKCS":{"title":"PKCS","content":"\n# PKCS\n\nThe Public-Key Cryptography Standards (PKCS)，\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/PKI":{"title":"PKI","content":"\n# PKI\n\nPublic Key Infrastructure，公钥基础设施。\n\n## 组成\n\n一个PKI体系由终端实体、证书认证机构、证书注册机构和证书/[[2-数学/2_0_0_2-密码学/CRL|CRL]]存储库四部分共同组成。\n\n- 证书颁发机构（[[2-数学/2_0_0_2-密码学/CA|CA]]）\n- 证书注册机构（[[2-数学/2_0_0_2-密码学/RA|RA]])\n- 证书库\n- 密钥备份及恢复系统\n- 证书废除处理系统\n- 应用系统接口\n- [[2-数学/2_0_0_2-密码学/数字证书|数字证书]]\n\n## 重要角色\n\n1. 终端实体（EE, End Entity）: 证书的最终使用者，例如总部和分支的网关。\n2. 证书颁发机构（CA， Certificate Authority）：是一个权威的、可信的第三方机构，负载[[2-数学/2_0_0_2-密码学/证书颁发|证书颁发]]、查询以及更新等工作。\n3. 证书注册机构（RA）\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/RA":{"title":"RA","content":"\n# RA\n\nRegistration Authority，注册机构。\n\n对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给 [[2-数学/2_0_0_2-密码学/CA|CA]]。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/2-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/SSL%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B":{"title":"SSL连接建立","content":"\n# SSL连接建立\n\n1. HTTPS服务器向PKI认证中心申请本地证书。\n2. PKI认证中心向HTTPS服务器颁发本地证书。\n3. HTTPS服务器将携带自己公钥信息的数字证书发送给HTTPS客户端。\n4. HTTPS客户端验证HTTPS服务器的本地证书合法后，利用证书中的公钥加密HTTPS客户端随机生成的密钥，并发送给HTTPS服务器。\n5. HTTPS客户端和HTTPS服务器通过协商，最终确定所使用的密钥和加密套件。后续传输的数据，双方都会使用该密钥和加密套件进行加密处理。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE":{"title":"二分查找","content":"# 二分查找\n\n\u003e https://www.zhihu.com/question/36132386\n\n## 二分查找的重点\n- 将数据分成三个区间 左 中 右\n\t- 左 右是已经搜索过的区间，中间是待搜索区间\n\t- 区间全部采用**左闭右开**\n\n## 搜索区间\n\n- 搜索的过程就是尽量扩大左 右 区间的范围，最终消灭中间区间\n- 可能的目标会出现在四个位置：\n\t- 左区间下界\n\t- 中区间上界\n\t- 中区间下界\n\t- 右区间上界\n\t![[z-oblib/z2-attachments/Pasted image 20220426105510.png]]\n- 四种情况两两差别一位，因此可以通过\n\n## 如何取中点\n\n```java\n// 通用\nmid = first + (last - first) / 2;\n\n// java \u003e\u003e\u003e 为带符号位移，溢出到符号位的数字会移回来\nmid = (first+last) \u003e\u003e\u003e 1;\n```\n\n## 处理中点\n\n```python\ndef lower_bound(array, first, last, value):\n    while first \u003c last: # 搜索区间[first, last)不为空\n        mid = first + (last - first) // 2  # 防溢出\n        if array[mid] \u003c value: first = mid + 1\n        else: last = mid\n    return first  # last也行，因为此时重合\n```\n\n**对中间的处理实际上就是决定把终点归入左区间还是右区间。**\n- 放入左区间则左区间下界 = mid +1，+1是因为区间右开\n- 放入右区间则右区间上界 = mid，不+1是因为区间保持左闭\n\n## 例子\n\n举个栗子，搜索整个`array = [-1, 0, 0, 3, 3, 3, 7, 8, 9]`，`value = 3`\n\n![[z-oblib/z2-attachments/v2-6fc0ed8d64174bc1d494236e1cce95bf_1440w.jpg]]\n\n初始状态，搜索区间两侧都为空，满足loop invariant 2和3\n\n一开始黄色的搜索区间左右(青、紫)都是空的，loop invariants的2和3自然满足。\n\n上图`array[mid] \u003e= 3`，说明`mid`属于紫色！\n\n在已知信息下，最大限度合理扩张紫色区间、缩小黄色搜索区间长度的操作是：\n\n把`last`放到上图中`mid`的位置，即`last = mid` ：\n\n![[z-oblib/z2-attachments/v2-7ef64338dd2ac43768e965a04ef4930c_1440w.jpg]]\n\n紫色区间最大限度向左扩张了\n\n如上图，新的`mid`满足`array[mid] \u003c 3`，说明`mid`属于青色！在已知信息下，最大限度合理扩张青色区间、缩小黄色搜索区间长度的操作是：`first = mid + 1`：\n\n![[z-oblib/z2-attachments/v2-f3e9d6b819f0c54851d5ed9f9d7db4eb_1440w.jpg]]\n\n此时搜索区间长度为1，只剩最后一步，答案要么是first要么是last\n\n现在搜索区间长度缩短到1了！可以返回`first`了吗？不行，我们检查过了红圈左边和右边，却没有检查红圈本身。如果红圈是2，那么答案应该是上图的`last`才对。\n\n之所以更新`first`或`last`的时候要最大限度缩小搜索区间（`first`更新为`mid + 1`而非弱一点的`mid`，`last`更新为`mid`而非弱一点的`mid + 1`），主要考虑并不是这个效率efficiency，而是上图区间长度为1的情况！此时`mid`就是`first`，`mid + 1`就是`last`，于是弱一点的更新等于没有更新，会导致死循环！\n\n最后一步，上图中`array[mid] \u003e= 3`，mid属于紫色，于是`last`左移一位，搜索结束：\n\n![[z-oblib/z2-attachments/v2-bcc8f37438db16ca4952ff9542b46691_1440w.jpg]]\n\n最后区间`[first, last)`为空，青区间和紫区间都最大限度扩张了。所以，根据紫区间的定义`任意元素 \u003e= 3`，已经饱和的它，第一个元素(若存在)的位置`last`就是答案！若没有满足要求`x \u003e= 3`的元素，那么紫区间就是空的，停留在初始状态`[last0, last0)`，所以返回的是`last0`，即初始范围之后的第一个元素，表示“不存在”，无需特殊处理！\n\n皆大欢喜的是，`first`与`last`重合，所以完全不需要纠结返回哪个！","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F":{"title":"冒泡排序","content":"# 冒泡排序\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88":{"title":"单调栈","content":"\n# 单调栈\n\nhttps://www.cnblogs.com/liang24/p/14200734.html\n#TODO\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86":{"title":"并查集","content":"# 并查集\n\n并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。\n\n## 解释\n\n- 并查集其实完成了两个操作\n    - 查找一个元素的根是谁\n    - 合并两个不同的树\n\n## 用处\n\n\n\n## 并查集初始化\n\n并查集一般是用一个一维数组来存储的，其中pre[i]=i表示自己和自己是连通的，也就是说还没有往点之间添加路径。\n\n![[z-oblib/z2-attachments/Pasted image 20220506195441.png]]\n\n## find() 找节点对应根节点\n\n```cpp\n// 找某个节点的根节点\nint find(int x)\n{\n    while (fams[x]!=x)  // 如果父节点指向自己，则为根，否则继续找\n        x = fams[x];\n    return x;\n}\n```\n\n### 路径压缩\n\n我们使用了太多没用的信息，我的祖先是谁与我父亲是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。**把在路径上的每个节点都直接连接到根上**，这就是路径压缩。\n\n![[z-oblib/z2-attachments/Pasted image 20220508192509.png]]\n\n```cpp\nint find(int x) {\n  if (x != fa[x])  // x 不是自身的父亲，即 x 不是该集合的代表\n    fa[x] = find(fa[x]);  // 查找 x 的祖先直到找到代表，于是顺手路径压缩\n  return fa[x];\n}\n```\n\n## join/union() 向各子树添加节点\n\n主要是用来往存放并查集的一维数组中添加路径的，先判断两个点之间是否连通，如果连通就不用添加路径了，如果不连通那么将两个点的根节点连在一起。\n\n![[z-oblib/z2-attachments/Pasted image 20220506195527.png]]\n\n```cpp\nvoid my_union(int x, int y)\n{\n\t// 查询两个节点各自的根节点\n    int rx = find(x);\n    int ry = find(y);\n    \n    // 根节点不同则将根节点连起来\n    if (rx!=ry)\n        fams[ry] = rx;\n}\n```\n\n### 启发式合并/按秩合并\n\n一个祖先突然抖了个机灵：「你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。」\n\n由于需要我们支持的只有集合的合并、查询操作，当我们需要将两个集合合二为一时，无论将哪一个集合连接到另一个集合的下面，都能得到正确的结果。但不同的连接方法存在时间复杂度的差异。具体来说，如果我们将一棵点数与深度都较小的集合树连接到一棵更大的集合树下，显然相比于另一种连接方案，接下来执行查找操作的用时更小（也会带来更优的最坏时间复杂度）。\n\n当然，我们不总能遇到恰好如上所述的集合————点数与深度都更小。鉴于点数与深度这两个特征都很容易维护，我们常常从中择一，作为估价函数。而无论选择哪一个，时间复杂度都为$O(m\\log n)$，具体的证明可参见 References 中引用的论文。\n\n在算法竞赛的实际代码中，即便不使用启发式合并，代码也往往能够在规定时间内完成任务。在 Tarjan 的论文[1]中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度是$O(m\\log n)$。在姚期智的论文[2]中，证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是$O(m\\alpha(m,n))$。\n\n如果只使用启发式合并，而不使用路径压缩，时间复杂度为$O(m\\log n)$。由于路径压缩单次合并可能造成大量修改，有时路径压缩并不适合使用。例如，在可持久化并查集、线段树分治 + 并查集中，一般使用只启发式合并的并查集。\n\n```cpp\n// C++ Version\nstd::vector\u003cint\u003e size(N, 1);  // 记录并初始化子树的大小为 1\n\nvoid unionSet(int x, int y) {\n  int xx = find(x), yy = find(y);\n  if (xx == yy) return;\n  if (size[xx] \u003e size[yy])  // 保证小的合到大的里\n    swap(xx, yy);\n  fa[xx] = yy;\n  size[yy] += size[xx];\n}\n```\n\n## 例题\n\n## 题目描述\n\n有n个人，编号为1,2,……n，另外还知道存在K个关系。一个关系的表达为二元组（α，β）形式，表示α，β为同一家庭的成员。\n当n，k和k个关系给出之后，求出其中共有多少个家庭、最大的家庭中有多少人？\n例如：n＝6，k＝3，三个关系为（1,2），(1,3)，(4,5)\n此时，6个人组成三个家庭，即：｛1,2,3｝为一个家庭，｛4,5｝为一个家庭，｛6｝单独为一个家庭，第一个家庭的人数为最多。\n\nInput\n\n```\n第一行为n,k二个整数（1≤n≤100，0\u003c=k\u003c=1000）（用空格分隔）。\n接下来的k行，每行二个整数（用空格分隔）表示关系。\n```\n\nOutput\n\n二个整数（分别表示家庭个数和最大家庭人数）。\n\nSample Input\n\n```\n6 3\n1 2\n1 3\n4 5\n```\n\nSample Output\n\n```\n3 3\n```\n\nHINT\n\n```\n1≤n≤100，0\u003c=k\u003c=1000\n```\n\n## 代码\n\n```cpp\n#include \u003ciostream\u003e\nusing namespace std;\n\nint fams[101];  //标记根节点的数组，下标为儿子，值为对应父亲\nint peops[101] = {0};  // 父亲有几个儿子的计数数组\nint find(int x)\n{\n    while (fams[x]!=x)  // 如果父亲值指向自己，则为根，否则继续找\n        x = fams[x];\n    return x;\n}\n\nvoid my_union(int x, int y)\n{\n    int rx = find(x);\n    int ry = find(y);\n    if (rx!=ry)  // 如果两个儿子的根不同，则把一个根加到另一个根的儿子位置\n        fams[ry] = rx;\n}\n\nint main (void)\n{\n    int n = 0, k = 0;\n    int fams_num = 0, max = 0;\n    cin\u003e\u003en\u003e\u003ek;\n    for (int i=0; i\u003c=n; i++)\n        fams[i] = i;\n    for (int i=0; i\u003ck; i++)\n    {\n        int p1 = 0, p2 = 0;\n        cin\u003e\u003ep1\u003e\u003ep2;  //读取要合并的两个儿子\n        my_union(p1, p2);  // 尝试合并\n    }\n    for (int i=1; i\u003c=n; i++)\n        if (find(i)==i) fams_num++;  // 遍历有几个父亲\n    for (int i=1; i\u003c=n; i++)\n        peops[find(i)]++;  // 将各儿子对应父亲位置++记录每个父亲几个儿子\n    for (int i=1; i\u003c=n; i++)\n        if (peops[i]\u003e=max) max = peops[i];  // 找儿子最多的父亲有几个儿子\n\n    cout\u003c\u003cfams_num\u003c\u003c' '\u003c\u003cmax\u003c\u003cendl;\n}\n```\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1":{"title":"快速取模","content":"# 快速取模\n\n使用位运算代替取模：\n前提：b为2^n\n$a \\% b == a \\\u0026 (b - 1)$\n\n## 原理\n\n$X \\% 2^n = X \\\u0026 (2^n - 1)$\n\n假设 n 为 3，则 2^3 = 8，表示成 2 进制就是 1000。2^3 - 1 = 7 ，即 0111。\n\n此时 $X \\\u0026 (2^3 - 1)$ 就相当于取 X 的 2 进制的最后三位数。","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82":{"title":"快速幂","content":"# 快速幂\n\n\u003e 二分的思想。\n\u003e 1. 指数转换为二进制\n\u003e 2. 二进制树又可以拆分成1 2 4 8...的和\n\u003e 3. 而1 2 4 8...之间都是 X2的关系，每一位都是前一位的2倍，计算更高位只用x2\n\u003e 4. 这样时间复杂度就降低了\n\n\u003e 同样的思路可以实现快速乘，只要将部分乘法换成加法即可。\n\n## 基本方法\n\n```java\npublic class FastPower {  \n\t// 递归\n    static int byRecursion(int base, int exponent) {  \n        if (exponent==0)  // 指数为0  \n            return 1;  \n        if (exponent % 2 == 1) {  // 指数为奇数  \n            return byRecursion(base, exponent-1) * base;  \n        }  \n        int tmp = byRecursion(base, exponent/2);  // 指数为偶数  \n        return tmp * tmp;  // 除以2后，时间复杂度降为 log(n)，不用重复算两次byRecursion(base, exponent/2)了。  \n    }  \n\n\t// 迭代\n    static int byIteration(int base, int exponent) {  \n        int ans = 1;  \n        while(exponent\u003e0) {  \n            if ((exponent \u0026 1) == 1) {  // 判断指数最低位是否为1，是的话则将当前  \n                ans *= base;  // 底数相乘指数相加  \n            }  \n            base *= base;  // 不断计算出 x^2 x^4 x*8 ... 的结果  \n            exponent \u003e\u003e= 1;  // 移位相当于除以2  \n        }  \n        return ans;  \n    }  \n  \n    public static void main(String[] args) {  \n        System.out.println(byRecursion(2, 5));  \n        System.out.println(byIteration(2, 6));  \n    }  \n}\n```\n\n## 结合取余\n\n终于来到了最关键的地方，结合快速幂算法后会有什么影响呢？\n\n其实在我们日常做题中，你会看到**输出结果对 xxxx 取模**。这种题目可能是有两种考察方向:\n\n1. **在原算法的基础上，多一个取模运算来考察你对取模运算规律的掌握；**\n2. **大数据时数据增长太快，64 位甚至 128 位的整形无法表示；**\n\n对应的，我们快速幂的题目就是这样，假设让你求 a 的 b 次方，当 `a = 10` 且 `b = 20` 次方就已经超过了 64 位 `Int` 类型的范围（ 2642^{64}264 次方约等于 `1.84 * 10^19`）。\n\n```java\nstatic int byIteration(int base, int exponent) {  \n\tint ans = 1;  \n\twhile(exponent\u003e0) {  \n\t\tif ((exponent \u0026 1) == 1) {  // 关注点 1\n\t\t\tans *= base;\n\t\t}  \n\t\tbase *= base;  // 关注点 2\n\t\texponent \u003e\u003e= 1;  \n\t}  \n\treturn ans;  \n}\n```\n\n我们来看关注点 1 和关注点 2 两个地方，分析得到这两个结论：\n\n1. 我们的快速幂算法其实并没有真正的优化乘法效率，而是通过二进制拆分，从而优化了乘法运算的次数，具体的表现就是 `base *= base` 来扩大乘子的基数；\n2. 在计算 `res` 的时候，`res *= base` 仍旧是一个累乘的过程，唯一的变化就是 `base` 在由于 `base *= base` 逐渐变化。这两个式子结合起来，其实就是 `res` 不断的去累乘多个 `base` 。\n\n有了这两点分析，我们就可以套用求模运算规律了。\n\n(a * b) % p = (a % p * b % p) % p\n\n我们在所有乘法表达式的地方增加求模运算，其实反映出来的结果就是 `res` 不断累乘时候每一项都做一次求模运算。\n\n有着以上思路我们来修改代码：\n\n```java\nstatic int byIteration(int base, int exponent) {\n\tint m = 1000000007  // 模数\n\tint ans = 1;  \n\twhile(exponent\u003e0) {  \n\t\tif ((exponent \u0026 1) == 1) {  // 关注点 1\n\t\t\tans = (ans * base) % m;\n\t\t}  \n\t\tbase = (base * base) % m\n\t\texponent \u003e\u003e= 1;  \n\t}  \n\treturn ans;  \n}\n```","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F":{"title":"快速排序","content":"\n# 快速排序\n\n快速排序是 [[3-计算机科学/0-数据结构与算法/冒泡排序|冒泡排序]] 的改进版本。\n\n快排的每一轮都是讲一个基数归为，所以外层要循环 n 次：\n![[z-oblib/z2-attachments/3.9-1.png]]\n\n## 时间复杂度\n\n快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。\n每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。\n这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。\n当然在最坏的情况下，仍可能是相邻的两个数进行了交换。\n因此快速排序的最差时间复杂度和冒泡排序是一样的都是 **O(N2)**，它的平均时间复杂度为 **O(NlogN)**。\n其实快速排序是基于一种叫做“二分”的思想。\n\n## 实现\n\n### 双指针版\n\n```java\n// 快速排序  \npublic void quickSort(int left, int right) {  \n    // 子集只有一个元素旧没必要继续切分快排了  \n    int lens = right - left + 1;  \n    if (lens\u003c2)  \n        return;  \n  \n    int base = num[left];  // 取区间第一个元素作base值  \n    int curLeft = left;  // 记录当前左区间下标，用于递归  \n    int curRight = right;  // 记录当前右区间下标，用于递归  \n    boolean leftReady = false, rightReady = false;  // 标志是否找到需要交换的数  \n    while (left!=right) {  \n        if (!rightReady) {  \n            if (num[right]\u003ebase)  // 右边的数都大于base  \n                right--;  \n            else                rightReady = true;  \n        }  \n        if (!leftReady) {  \n            if (num[left]\u003cbase)  // 左边的数都小于base  \n                left++;  \n            else                leftReady = true;  \n        }  \n        // 左右都找到需要交换的数，执行交换  \n        if (leftReady \u0026\u0026 rightReady) {  \n            swap(left, right);  \n            rightReady = false;  \n            leftReady = false;  \n        }  \n    }  \n    if (lens \u003e 2) {  \n        quickSort(curLeft, left);  \n        quickSort( left+1, curRight);  \n    }  \n}\n```\n\n### 无脑往右放版\n\n```java\n// 快排第二种写法  \npublic void quickSort2(int left, int right) {  \n    if (left\u003cright) {  \n        int pivot = partition(left, right);  \n        quickSort2(left, pivot-1);  \n        quickSort2(pivot+1, right);  \n    }  \n}  \n  \nint partition(int left, int right) {  \n    int pivot = left;  // 基准值  \n    // index指向最新不确定位\n    int index = pivot + 1;  \n    // left遍历到right，只要是小于num[pivot]的都放到右边去  \n    // 该方案交换时不考虑门当户对，所以中间可能有小于num[pivot]被暂时放到左边  \n    // 但因为是对整个区间进行遍历，所以最终还是会换到右边去  \n    // 效率没有双指针高，但逻辑稍微简单一点  \n    for (int i = index; i \u003c= right; i++) {  \n        if (num[i]\u003cnum[pivot])  \n            swap(i, index++);  \n    }  \n    swap(pivot, index-1);  \n    return index-1;  \n}\n```\n\n\u003e index 是指将 index 左侧的节点一个个换到 index 头处，被 index“吞下”，这样 index 身体里（左边）都是比 pivot 小的值。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84":{"title":"最短路径","content":"# 最短路径\n\n该算法的关键是： 找两个集合之间的最短路径，分别是已经确定的点的集合/未确定点的集合。 每次都在已确定点中的未知道路找最短的路。 因此可以将路都加入优先级队列，自动排序。\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Graph gp = testGraph();\n        Integer end = 4;  // 目的点\n        Integer start = 0;  // 起点\n        int length = 0;  // 路径长度\n        List\u003cInteger\u003e path = new ArrayList\u003c\u003e();  // 路径\n        //\u003c边权重，当前点，前序点\u003e\n        // 未选点集合到已选点集合的最短距离，重点是集合到集合的最短距离\n        // 每次加入集合的是目前能走的最短的边，而不是点\n        // 强行记录当前节点和前序节点即可保存路径\n        // 使用MyEntry是为了兼容jdk8，后续版本可以使用Map.entry直接返回Map.Entry对象\n        PriorityQueue\u003cMyEntry\u003cInteger, MyEntry\u003cInteger, Integer\u003e\u003e\u003e pq = new PriorityQueue\u003c\u003e((e1, e2) -\u003e {return e1.getKey() - e2.getKey();});\n        // 初始化访问记录\n        Map\u003cInteger, Boolean\u003e visited = new HashMap\u003c\u003e();\n        visited.put(0, false);\n        visited.put(1, false);\n        visited.put(2, false);\n        visited.put(3, false);\n        visited.put(4, false);\n        visited.put(5, false);\n\n        // 队列中添加起点\n        pq.add(new MyEntry\u003cInteger, MyEntry\u003cInteger, Integer\u003e\u003e(gp.getWeight(start, start), new MyEntry\u003cInteger, Integer\u003e(gp.getValue(start), gp.getValue(start))));\n\n\n        while(!pq.isEmpty()) {\n            MyEntry\u003cInteger, MyEntry\u003cInteger, Integer\u003e\u003e tmp_entry = pq.poll();\n            if (visited.get(tmp_entry.getValue().getKey()) == true) {\n                continue;\n            }\n            visited.put(tmp_entry.getValue().getKey(), true);\n            path.add(tmp_entry.getValue().getKey());\n\n            // 求路径长度，到达目的点就停止\n            if (tmp_entry.getValue().getKey()==end) {\n                length = tmp_entry.getKey();\n                break;\n            }\n            //遍历这个点的相邻节点并入队\n            for (int i=0; i\u003cgp.nodeNum(); i++) {\n                if (gp.getWeight(tmp_entry.getValue().getKey(), i)==0) {\n                    continue;\n                }\n                // （新加入点到起始点的距离，（新加入点变为当前点，当前点变为前序点））\n                pq.add(new MyEntry\u003cInteger, MyEntry\u003cInteger, Integer\u003e\u003e(tmp_entry.getKey() + gp.getWeight(tmp_entry.getValue().getKey(), i),new MyEntry\u003cInteger, Integer\u003e(gp.getValue(i),tmp_entry.getValue().getKey())));\n            }\n        }\n\n        System.out.println(length);\n        for (Integer i : path) {\n            System.out.print(\" \"+i+\" \");\n        }\n    }\n\n    public static Graph testGraph() {\n\n        // **1--\u003e2 的最短路径是：7\n        // **1--\u003e3 的最短路径是：9\n        // **1--\u003e4 的最短路径是：20\n        // **1--\u003e5 的最短路径是：20\n        // **1--\u003e6 的最短路径是：11 \n        // 1--\u003e2--\u003e3--\u003e6--\u003e4--\u003e5--\u003e\n\n        int n = 6; // 节点的个数\n        Integer vertexString[] = { 0,1,2,3,4,5 };\n        // 创建图对象\n        Graph gp = new Graph(n);\n        // 向图对象添加节点\n        for (Integer value : vertexString) {\n            gp.addVer(value);\n        }\n        // 添加边信息\n        gp.addNum(0, 1, 7);\n        gp.addNum(0, 2, 9);\n        gp.addNum(0, 5, 14);\n        gp.addNum(1, 0, 7);\n        gp.addNum(1, 2, 10);\n        gp.addNum(1, 3, 15);\n        gp.addNum(2, 0, 9);\n        gp.addNum(2, 1, 10);\n        gp.addNum(2, 3, 11);\n        gp.addNum(2, 5, 2);\n        gp.addNum(3, 1, 15);\n        gp.addNum(3, 2, 11);\n        gp.addNum(3, 4, 6);\n        gp.addNum(4, 3, 6);\n        gp.addNum(4, 5, 9);\n        gp.addNum(5, 0, 14);\n        gp.addNum(5, 2, 2);\n        gp.addNum(5, 4, 9);\n\n\n        // 显示图的矩阵\n        gp.show();\n        return gp;\n    }\n}\n\nclass Graph {\n    private ArrayList\u003cInteger\u003e vertexList; // 存放顶点集合\n    private int[][] edges; // 矩阵\n    private int num; // 边的数目\n\n    public Graph(int n) {\n        edges = new int[n][n];\n        vertexList = new ArrayList\u003cInteger\u003e(n);\n        num = 0;\n    }\n\n    // 插入节点\n    public void addVer(int vertex) {\n        vertexList.add(vertex);\n    }\n\n    // 添加边\n    public void addNum(int v1, int v2, int weight) {\n        // v1和v2指的是点的下标。weight表示权值\n        edges[v1][v2] = weight;\n        edges[v2][v1] = weight;\n        num++;\n    }\n\n    // 返回节点的个数\n    public int nodeNum() {\n        return vertexList.size();\n    }\n\n    // 返回边一共有多少条\n    public int edgeNum() {\n        return num;\n    }\n\n    // 通过索引返回值\n    public Integer getValue(Integer i) {\n        return vertexList.get(i);\n    }\n\n    // 返回v1和v2的权值\n    public int getWeight(int v1, int v2) {\n        return edges[v1][v2];\n    }\n\n    // 显示图对应的矩阵\n    public void show() {\n        for (int[] link : edges) {\n            System.err.println(Arrays.toString(link));\n        }\n    }\n}\n\n// 为了兼容java8，不能用Map.entry()\nfinal class MyEntry\u003cK, V\u003e implements Map.Entry\u003cK, V\u003e {\n    private final K key;\n    private V value;\n\n    public MyEntry(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n        return key;\n    }\n\n    @Override\n    public V getValue() {\n        return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n        V old = this.value;\n        this.value = value;\n        return old;\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8":{"title":"跳表","content":"# 跳表\n\n\u003ehttps://www.jianshu.com/p/9d8296562806\n\n针对顺序表，以某一概率在当前最上层选点构建新的一层，以此构建多层索引，由上往下逐层增加稠密度。\n\n![[z-oblib/z2-attachments/19063731-70b00aafa9f5b793.webp]]\n![[z-oblib/z2-attachments/19063731-4f4535e6d0959c32.webp]]\n![[z-oblib/z2-attachments/19063731-3852cc36af701f46.webp]]\n\n## 索引高度\n\n假设原始链表有n个元素，以每两个节点抽出一个节点为例，即某个点有1/2的概率被选中：\n- 1级索引节点数：n/2\n- 2级索引节点数：n/4\n- k级索引节点数：$n/2^k$\n此例中跳表索引高度为：$h = log_2{n} - 1$，-1是因为最上层不会有节点个数为1的层，所以减掉1。\n\n因此原始链表有n个元素，各级跳表的选取概率为p，则第k层的节点数 $m_k = m_{k-1} \\times 1/p$，索引的高度为$h = log_{1/p}{n} - 1$。\n\n## 查找时间复杂度\n\n时间复杂度 = 索引的高度 * 相邻索引间包含的下层索引个数（均值）。\n\n![[z-oblib/z2-attachments/19063731-5ec10e6ae2c32587.webp]]\n\n图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。\n\n可知各级索引个数和选取的概率相关，个数$q = 1/p + 1$，+1是因为上层索引进入下层索引时，会重复访问一次（例子中的w）。\n\n则时间复杂度为\n$$\n\\begin{split}\nO(h*q) \u0026= O((log_{1/p}{n} - 1) * (1/p + 1)) \\\\\n\u0026= O(log{n})\n\\end{split}\n$$\n最后简化的原因是，在具体实现上p会取一个确定的值，例如前例中的1/2，所以这里p是常数，而时间复杂度计算时可以省略常数。\n\n但在实际应用中，p的取值会影响具体算法实现的效率。Redis 的 zset 中 SKIPLIST_P 设定的 0.25，即隔4个取一下。\n\n#TODO \n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B+%E6%A0%91":{"title":"B+树","content":"# B+树\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81":{"title":"OJ常用代码","content":"# OJ常用代码\n\n## 进制转换\n\n### 任意进制转 10 进制\n\n对于一个 p 进制的 n 位数 y 来说, 其每一位$a_n$的关系是\n$$\ny = a_1 \\times p^{n-1} + n_2 \\times p^{n-2} + ... + a_{n-1} \\times p^1 + a_n \\times p^0\n$$\n\n转换代码实现:\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint y = 0, a = 0, p = 1, result = 0;  // p 初始为1, 代表p^0 \n\tcin\u003e\u003ey\u003e\u003ea;\n\twhile (y!=0)\n\t{\n\t    result += (y % 10) * a;  // 将最低位乘以p^n 再累加 \n\t    y /= 10;  //每次去掉最低位 \n\t    p *= a;  // 次数递增 \n    }\n    cout\u003c\u003cresult;\n\treturn 0;\n}\n```\n\n### 10 进制转任意进制\n\n采用除基取余法:\n- 基代表目标进制 q\n\n步骤:\n1. 每次将上一步的商除以目标进制 q\n1. 余数插入结果, 从左向右插入\n1. 直到商为 0 , 插入本次余数后停止\n\n代码实现(10进制数 y 转化为 q 进制数):\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint y = 0, q = 0, p = 1;\n    string result; \n\tcin\u003e\u003ey\u003e\u003eq;\n\t/* 商为0则停止, 为了保证最后一次余数的存储, 用 do..while */\n\tdo\n\t{\n\t    string str = to_string(y%q);  // 对 q 取余 \n\t    result.insert(0, str);\n\t    y /= q;\n    } while(y!=0);\n    \n    cout\u003c\u003cresult;\n\treturn 0;\n}\n```\n\n### 任意进制间转换\n\n将上面两个步骤结合起来即可.\n\n## 最小公因数\n\n递归实现:\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    return b==0 ? a : gcd(b, a%b);\n}\n```\n\n## 互质\n\n判断两个数互质或者是分数的化简:\n- 就是判断两个数的最小公因数是不是1\n\n## 最小公倍数\n\na,b两数求最小公倍数:\n1. 先求它们的最小公因数gcd\n1. 再算 $a * b / gcd$\n\n\n## 排序\n\n### 冒泡排序\n\n[[3-计算机科学/0-数据结构与算法/冒泡排序|冒泡排序]]\n\n1. 有n个元素则循环n-1次\n1. 好像传手帕一般, 每次将当前为固定数中最大的那个传到右边固定\n1. 最后一步则是根据情况交换第一和第二个元素\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint a[5] = {3,1,4,5,2};\n\tint n = sizeof(a) / 4;  // 元素个数 \n\tfor (int i=0; i\u003cn-1; i++)\n\t{\n\t    /* n个元素总共执行n-1次 */ \n\t    for (int j=0; j\u003cn-1-i; j++)\n\t    {\n\t        int temp;\n\t        /* 左大于右则交换为升序 */\n\t        /* 每一轮遍历都是将为固定中最大的移到右边固定 */ \n\t        if (a[j]\u003ea[j+1])\n\t        {\n\t            temp = a[j];\n\t            a[j] = a[j+1];\n\t            a[j+1] = temp;\n            }\n        }\n    }\n    for (int i=0; i\u003cn; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n```\n\n### 简单选择排序\n\n1. 外围循环为当前最小交换位标记\n1. 内层循环每次把当前最小的和标记位互换\n    1. 内循环结束一轮时标记位为当前子序列中最小的\n1. 依次从小到大放到左边\n\n实现:\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint a[5] = {3,1,4,5,2};\n\tint n = sizeof(a) / 4;  // 元素个数 \n\tfor (int i=0; i\u003cn; i++)  // 其实i\u003cn-1即可\n\t{\n\t    for (int j=i+1; j\u003cn; j++)\n\t    {\n\t        int temp;\n\t        if (a[i]\u003ea[j])\n            {\n                temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n            }\n        }\n    }\n    for (int i=0; i\u003cn; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n```\n\n### 直接插入排序\n\n1. 将第一个元素当作初始有序子序列, 从第二个元素开始遍历\n1. 暂存当前元素值\n1. 从当前遍历元素开始往回(左)遍历, 如果比当前元素小则往右挪\n    1. 如果挪动, 自然会覆盖掉当前元素的坑位\n1. 当前元素插入挪出的坑位, 左侧子序列还保持有序\n\n实现:\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint a[5] = {3,1,4,5,2};\n\tint n = sizeof(a) / 4;  // 元素个数 \n\tfor (int i=1; i\u003cn; i++)\n\t{\n\t    int temp = a[i];\n\t    int j = i;\n\t    /* 将比当前数字大的数往右移动一个, 给当前数留出坑位 */\n\t    /* 左侧序列保持有序, 所以一旦不大于当前数则不用继续遍历了 */ \n\t    for (; j\u003e=0 \u0026\u0026 a[j-1]\u003etemp; j--)\n        {\n            a[j] = a[j-1];\n        }\n        a[j] = temp;   // 当前数插入坑位 \n    }\n    for (int i=0; i\u003cn; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n```\n\n### 2路归并排序\n\n#### 递归版\n\n```c++\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid merge(int a[], int l1, int r1, int l2, int r2);\nvoid sort_merge(int a[], int left, int right);\n\nint main(void)\n{\n\tint a[6] = {5,2,4,1,3,6};\n\tfor (int i=0; i\u003c6; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\tprintf(\"\\n\");\n\tsort_merge(a, 0, 5);\n\tfor (int i=0; i\u003c6; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n\nvoid merge(int a[], int l1, int r1, int l2, int r2)\n{\n    int i = l1, j = l2;\n    int temp[100] = {0};  // 临时数组 \n    int index = 0;\n    /* 两个数组同时遍历, 一个遍历完则停止 */ \n    for (; i\u003c=r1 \u0026\u0026 j\u003c=r2;)\n    {\n        if (a[i]\u003ca[j])\n            temp[index++] = a[i++];\n        else\n            temp[index++] = a[j++];\n    }\n    /* 两个数组不等长则输出剩余元素(必定有序) */ \n    while(i\u003c=r1) temp[index++] = a[i++];\n    while(j\u003c=r2) temp[index++] = a[j++];\n    /* 将结果赋回原数组 */ \n    for (int i=0; i\u003cindex; i++)\n        a[l1+i] = temp[i];\n}\n\nvoid sort_merge(int a[], int left, int right)\n{\n    if (left\u003cright)  // 递归到被拆分数组只有一个元素时停止\n    {\n        int mid = (left + right) / 2;  // 从中间拆分数组 \n        /* 先算完左半边, 再算右半边 */ \n        sort_merge(a, left, mid);    // 对左半边数组递归 \n        sort_merge(a, mid+1, right);  // 对右半边数组递归 \n        merge(a, left, mid, mid+1, right);  // 有序归并两个数组 \n    }\n}\n```\n\n#### 循环版\n\n```c++\n#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\nusing namespace std;\n\nvoid merge(int a[], int l1, int r1, int l2, int r2);\n\nint main(void)\n{\n\tint a[5] = {5,2,4,1,3};\n\tint len = sizeof(a) / 4;\n\tfor (int i=0; i\u003clen; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\tprintf(\"\\n\");\n\t/* step相当于归并的数组大小, 从2开始, 2的指数增长 */\n\t/* step/2\u003clen 指必须要有一组数组完全位于总数组内,并且至少还要留给第二步1个元素(不取等号) */\n\t/* 例如step增长到4时, 分组为{1,2,3,4},{5}, 符合要求但不能继续增长 */ \n\tfor (int step=2; step/2\u003clen; step*=2)\n\t{\n\t    /* 对每个子组归并 */ \n\t    for (int i=0; i\u003c=len; i+=step)\n\t    {\n\t        /* 当前步子一分为二, 左右归并 */\n\t        int mid = i + step / 2 - 1;\n\t        /* 注意判断不要越界 */\n\t        merge(a,i, mid, mid+1, min(i+step, len));  // sort() 前闭后开 \n        }\n    }\n\t\n\tfor (int i=0; i\u003clen; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n\nvoid merge(int a[], int l1, int r1, int l2, int r2)\n{\n    int i = l1, j = l2;\n    int temp[100] = {0};  // 临时数组 \n    int index = 0;\n    /* 两个数组同时遍历, 一个遍历完则停止 */ \n    for (; i\u003c=r1 \u0026\u0026 j\u003c=r2;)\n    {\n        if (a[i]\u003ca[j])\n            temp[index++] = a[i++];\n        else\n            temp[index++] = a[j++];\n    }\n    /* 两个数组不等长则输出剩余元素(必定有序) */ \n    while(i\u003c=r1) temp[index++] = a[i++];\n    while(j\u003c=r2) temp[index++] = a[j++];\n    /* 将结果赋回原数组 */ \n    for (int i=0; i\u003cindex; i++)\n        a[l1+i] = temp[i];\n}\n```\n\n#### 循环模拟版\n\n```c++\n#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\nusing namespace std;\n\nint main(void)\n{\n\tint a[5] = {5,2,4,1,3};\n\tint len = sizeof(a) / 4;\n\tfor (int i=0; i\u003clen; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\tprintf(\"\\n\");\n\t/* step相当于归并的数组大小, 从2开始, 2的指数增长 */\n\t/* step/2\u003clen 指必须要有一组数组完全位于总数组内,并且至少还要留给第二步1个元素(不取等号) */\n\t/* 例如step增长到4时, 分组为{1,2,3,4},{5}, 符合要求但不能继续增长 */ \n\tfor (int step=2; step/2\u003clen; step*=2)\n\t{\n\t    /* 对每个子组排序, 相当于进行一次下级归并结果 */ \n\t    for (int i=0; i\u003c=len; i+=step)\n\t    { \n\t        /* 注意判断不要越界 */\n\t        if (i+step-1\u003c=len-1)\n\t           sort(a+i, a+i+step);  // sort() 前闭后开 \n\t        else sort(a+i, a+len);\n        }\n    }\n\t\n\tfor (int i=0; i\u003clen; i++)\n\t{\n\t    printf(\"%d \", a[i]);\n    }\n\treturn 0;\n}\n```\n\n### 快速排序\n\n[[3-计算机科学/0-数据结构与算法/快速排序|快速排序]]\n\n## sort()\n\n### cmp() 函数构造\n\n```c++\nbool cmp(a,b)\n{\n    return a\u003eb; // 降序\n    return a\u003cb  // 升序\n}\n```\n\n可以使用 `else if` 实现多条件排序.\n\n## 贪心算法\n\n## two pointers\n\n有序序列的两层循环, 可以想办法变成左右两个指针的移动, 减小时间复杂度.\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp":{"title":"kmp","content":"# kmp\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E6%99%B6%E4%BD%93%E7%AE%A1":{"title":"晶体管","content":"# 晶体管\n\n所有可以通过一个电流或电压控制另一个电流或电压的器件。","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8":{"title":"锁存器","content":"# 锁存器\n\n我们将能够存储一个状态的电路叫做**锁存器**。设想一个电路，初始输入为0，输出为0；然后输入为1，输出变为1（状态发生了变化）。对于迄今为止所有的电路，我们都能保证当输入回到0时，输出也会同时归0；但这个电路不同，它保持在了1，也就是状态没有发生变化，而是被存储了下来。此时，这种电路便可以被叫做锁存器。\n\n为了让电路拥有自己的”状态“，必须要有某种”反馈“机制，将输出输入形成一个闭环。\n\n## 分类\n\n- [[3-计算机科学/1-计算机硬件/0-基础元器件/RS锁存器|RS锁存器]]\n- ","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/CMOS":{"title":"CMOS","content":"# CMOS\n\nCMOS是Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）的缩写。\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/RS%E9%94%81%E5%AD%98%E5%99%A8":{"title":"RS锁存器","content":"# RS锁存器\n\nRS锁存器是一两输入、两输出的电路，其电路如下图a，其有两个互相交叉反馈相连的两个与非门构成，其两个输出为两个相反的输出（或称为互补输出）。\n\n![[z-oblib/z2-attachments/Pasted image 20220904151011.png]]","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/SRAM":{"title":"SRAM","content":"# SRAM\n\n静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失（被称为volatile memory），这与在断电后还能储存资料的ROM或闪存是不同的。\n\n\n## 存储结构\n\n![[z-oblib/z2-attachments/Pasted image 20220904150755.png]]\n\n6T:指的是由六个晶体管组成，如图中的M1、M2、 M3、M4、M5、M6. SRAM中的每一bit存储在由4个场效应管(M1, M2, M3, M4)构成两个交叉耦合的反相器中。另外两个场效应管(M5, M6)是存储基本单元到用于读写的位线(BitLine)的控制开关。\n\n6T电路等价于SR锁存器：\n\n![[z-oblib/z2-attachments/Pasted image 20220904150813.png]]\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/mcu/PUF":{"title":"PUF","content":"# PUF\n\n## 特点\n\n- 唯一性：每一个芯片都是随机分布的、唯一的。\n- 防克隆性：芯片本身就是在芯片制造过程中由于不确定因素提取出来的，无法重新复制相同的PUF值。误差本就是不可控因素，因此不能逆向去生成指定的“误差”。\n- 不可预测性：由于芯片在制造出来之前，没有办法来预测。\n- 防篡改性：芯片本身PUF值无法定位修改。\n- 无需存储：每次芯片启动只需要在电路结构中提取，无需存储器件来存储。\n\n## 实现分类\n\n![[z-oblib/z2-attachments/Pasted image 20220904144719.png]]\n\n- SRAM PUF\n\tSRAM PUF利用[[3-计算机科学/1-计算机硬件/0-基础元器件/SRAM|SRAM]] Cell，首尾相接的反相器，在制造过程中，虽然电路架构完全一样，但是电路驱动能力有强弱之分，导致SRAM在上电时的Cell上0,1的分布是随机分布的，因此，利用这个特征可以提取出PUF\n- 仲裁PUF\n\t仲裁PUF，同一个信号从起点到终点所用的时间（延迟），在制造过程中会存在误差。\n- RO PUF（环形振荡器）\n\t环形振荡器PUF，利用环形振荡器电路，在不同芯片制造出来之后，频率产生也会存在误差\n- VIA PUF\n\t实际设计中，VIA存在设计规则，利用设计规则，设计从小到大的孔洞，根据工艺的特性，来提取出VIA PUF\n\n## SRAM实现\n\n### 工作原理\n\n\u003e [[3-计算机科学/1-计算机硬件/0-基础元器件/锁存器|锁存器]]在初始无输入情况下，输出会因生成工业的不可控误差产生不同的初始输出值。\n\n利用半导体物理生产过程中自然发生的深亚微米变化，并赋予每个[[3-计算机科学/1-计算机硬件/0-基础元器件/晶体管|晶体管]]轻微的随机的电特性。这些独特的特性构成了芯片独特身份的基础。\n\n基于 SRAM 的 PUF 评估的是标准的 6T（6 个晶体管） SRAM 阵列的上电模式。阵列中的每个 SRAM 单元由两个理论和设计上匹配的 CMOS 反向器组成，它们是交叉耦合的（参见图 2）。但是在芯片制造时，由于在物理上无法控制的[[3-计算机科学/1-计算机硬件/0-基础元器件/CMOS|CMOS]] 工艺引入深亚微米变化，使每个晶体管具有略带随机的电气特性。 SRAM 单元的上电状态主要取决于 PMOS 晶体管 P1 和 P2 的阈值电压 （Vth） 之间的差异。 例如，考虑随机变化导致|Vth,P1|小于|Vth,P2|。 因此，在通电（Vdd 上升）阶段 P1 将在 P2 之前开始导通，导致 A 在逻辑上处于高位，并阻止 P2 打开。 因此，单元的上电状态为 A=1。Vth,P1和Vth,P2之间的不匹配越大，单元的上电优先权越强，因此通电后是另一个状态的概率越小。\n\n![[z-oblib/z2-attachments/Pasted image 20220904145457.png]]\n\nSRAM PUF基于任何数字芯片中都可以使用的标准 SRAM 存储器的行为。每次SRAM供电时，由于晶体管阈值电压的随机差异，每个SRAM单元都有自己的首选状态。因此，当SRAM存储器供电时，每一个单元都会产生一个独特且随机的0和1模式。这些模式就像芯片指纹，因为每个模式对于特定的SRAM都是唯一的，因此对于特定的芯片也是唯一的。\n\n\n![[z-oblib/z2-attachments/Pasted image 20220904142722.png]]\n\n### 噪声\n\n但是，在 SRAM每次上电后，一些其中晶体管的驱动能力很平衡的单元，可能其初始值是0还是1是不固定的。 这部分单元的数量除以阵列中总单元的数量定义为 SRAM PUF 噪声。单元翻转主要受局部温差、局部电源电压变化和老化的影响。\n\nVth,P1≈Vth,P2的单元有较高的概率在每次上电时它们的输出值也相对前一次上电的输出值发生改变，因此，在SRAM的PUF响应中会导致相应SARM单元比特翻转或噪声（这也是本文中对“噪声”的定义）。 由于阈值电压对温度、供电电压、老化等因素敏感，SRAM PUF的噪声也会对这些不断变化的条件敏感。 \n\n\n\n![[z-oblib/z2-attachments/Pasted image 20220904143849.png]]\n\n### 针对噪声的纠错\n\n\u003e 影响因素和对策详细参考：[Intrinsic ID基于SRAM的PUF可靠性分析 (ip-soc.com)](https://www.ip-soc.com/jishu/36.html)\n\n### 密钥提取\n\n为了将有噪声的SRAM PUF的响应转换为可靠而且安全的设备唯一的密钥，使用了模糊提取器或辅助数据算法。这种算法实现两个处理步骤：i）纠错和 ii） 随机提取。\n\n#### 纠错\n\n为了说明纠错的概念，以一个非常小的、由一个字节组成的 SRAM PUF为例。SRAM PUF 响应可以看作是一个八位组成的位串。为了简单起见，我们从这个八位的SRAM PUF 中提取一个机密位 （1 或 0），该位对应于 1/8 的码率。本示例中使用的纠错码是长度为 8 的重复代码。这意味着机密位'0'将被编码为码字C0=(00000000)和秘密位'1'将被编码为码字C1=(11111111)。\n\n![[z-oblib/z2-attachments/Pasted image 20220904145844.png]]\n\n#TODO \n\n\u003e [Intrinsic ID基于SRAM的PUF可靠性分析 (ip-soc.com)](https://www.ip-soc.com/jishu/36.html)\n\n\n\n### 方案优势\n\n与传统的非易失性内存(NVM)中的密钥存储相比，这种从SRAM属性中获取密钥的方式具有很大的安全优势。因为密钥不是永久存储的，所以当设备处于非活动状态时(在掉电状态时或者不需要使用密钥时，没有明文密钥)，密钥就不存在，因此攻击者无法打开设备并破坏其存储器内的内容。\n\n### 如何将SRAM PUF用作信任根\n\n设备，尤其是物联网的设备，需要密钥来保护其数据、IP 和操作。如果这些密钥的来源是可信的，并且密钥安全地存储在可以抵御攻击的硬件中，则它们将形成设备所谓的\"信任根\"。\n\n这些密钥可以由设备制造商（也称为 OEM）自己配置到设备上，也可以由芯片供应商在更早的阶段提供。当芯片供应商提供预先配置的芯片时，这就增加了他们销售给 OEM 的产品的价值。如果 OEM 决定自己进行配置，他们通常会购买成本更低的芯片。\n\n无论双方中哪一方负责提供加密密钥，执行这一任务都不是一件简单的事情。将密钥注入芯片需要值得信赖的工厂，这增加了生产过程的成本和复杂性，并限制了灵活性。这种复杂性可以通过在芯片内部创建密钥来避免，比如使用内部随机数生成器(RNG)或PUF。\n\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%B4%E7%95%8C%E5%8C%BA":{"title":"临界区","content":"\n# 临界区\n\ncritical  section\n\n一段代码块内如果存在堆共享资源的多线程读写操作，称这段代码块为临界区。\n\n```java\nstatic int counter = 0;\n\nstatic void increment()\n// 临界区\n{\n\tcounter++;\n}\n\nstatic void decrement()\n// 临界区\n{\n\tcounter--;\n}\n```\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B9%90%E8%A7%82%E9%94%81":{"title":"乐观锁","content":"# 乐观锁\n\n乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，[[3-计算机科学/2-计算机组成原理/线程|线程]]可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]的技术来保证线程执行的安全性。\n\n由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说**乐观锁天生免疫死锁**。\n\n乐观锁多用于“**读多写少**“的环境，避免频繁加锁影响性能；而[[3-计算机科学/2-计算机组成原理/悲观锁|悲观锁]]多用于”写多读少“的环境，避免频繁失败和重试影响性能。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8":{"title":"二级页表","content":"# 二级页表\n\n二级页表的作用：\n\n页表本身也占用内存空间，且还不小，而程序运行时也不一定要把所有页表都载入到内存。\n\n所以连页表本身也可以部分载入内存，这就需要对页表也分段，形成二级页表结构。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%8F%AB%E6%B3%95":{"title":"内存地址在不同场景下的花式叫法","content":"\n# 内存地址在不同场景下的花式叫法\n\n- 指针 -- c/c++语言等\n- 句柄 -- c/c++下就是一个对象的地址\n- 向量 -- 如中断向量，是指向中断号对应中断处理程序的地址\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%88%86%E6%AE%B5":{"title":"分段","content":"\n# 分段\n\n分页是针对程序内容的：\n**分段存储管理能反映程序的逻辑结构并有利于段的共享**\n\n程序按内存物理地址直接加载，内存的空间利用率不高，因为程序中的各个部分在执行时只有部分在发挥作用，并且程序能直接访问内存，安全性不高。\n\n因此将程序按自身的组织结构进行划分，例如划分出代码段、数据段等。\n\n在分段中，CPU产生一个包含段号和段偏移量的逻辑地址，如果段偏移量比`limits`小，则该地址为有效地址，否则会因为地址无效而引发计算错误。\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923202813.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%88%86%E9%A1%B5":{"title":"分页","content":"\n# 分页\n\n分页是针对内存空间的：\n**页式存储管理能有效地提高内存利用率**\n\n[[3-计算机科学/2-计算机组成原理/进程|进程]]的地址空间被划分为固定大小的块。[[3-计算机科学/2-计算机组成原理/虚拟内存|虚拟内存]]和物理内存都被划分成相等的固定大小的块。**虚拟内存中的块称为页，物理内存中的块称为页帧**。分页[[3-计算机科学/2-计算机组成原理/多级页表提高内存使用效率的原理|高效率]]地利用内存，可以运行比物理内存空间更大的程序。\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923202623.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"分页与分段的区别","content":"\n# 分页与分段的区别\n\n[[3-计算机科学/2-计算机组成原理/分页|分页]] VS [[3-计算机科学/2-计算机组成原理/分段|分段]]\n\n| 分页                        | 分段                     |\n|---------------------------|------------------------|\n| 在分页中，进程的地址空间被划分为固定大小的页面   | 在分段中，进程的地址空间被划分为大小不同的段 |\n| 操作系统负责分页                  | 编译器负责分段                |\n| 页大小由硬件决定                  | 段大小由用户给出               |\n| 速度比分段块                    | 分段速度慢                  |\n| 分页会导致内部碎片                 | 分段导致外部碎片               |\n| 分页中，逻辑地址被划分为页号和页偏移        | 分段中，逻辑地址被划分为段号和段偏移     |\n| 分页包含一个页表，页表包含每个页的基地址      | 分段包含段表，段表中包含段号和段偏移量    |\n| 分页对于用户不可见                 | 分段对于用户可见               |\n| 在分页中，处理器需要页号和页偏移来计算实际物理地址 | 分段中，处理器使用段号和段偏移量计算地址   |\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0":{"title":"可重入函数","content":"\n# 可重入函数\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221018165205.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%90%8C%E6%AD%A5":{"title":"同步","content":"# 同步\n\n所有的执行顺序都**严格地和代码书写的顺序一致**。\n\n## 以调用方角度\n\n需要等待结果返回，才能继续运行就是同步。\n\n## 线程同步\n\n线程同步是线程之间按照**一定的顺序**执行。\n\n## 优点\n\n同步最大的优点是思路清晰。你永远可以知道你的程序是按照怎样的顺序执行的，不用担心任何意料之外的情况。\n\n## 缺点\n\n在某些情境下，它会带来性能的浪费。\n\n以一个生活中的场景为例：你在网上下载一个文件，但是文件很大，需要很长时间才能下完。这时候，你肯定不会盯着进度条一点点走，而是去做点别的事情，读一会书，看一会电影，之类的。\n\n但如果有一个完全“同步”的人，他为自己设定的程序是下载这个文件，然后运行它，这样的话，他为了不让自己的运行逻辑乱掉，就会一直守在电脑前，直到文件下载完成才做下一步的工作。正常人肯定不能忍受这样无聊的等待，也不会希望自己的程序在这种无聊的事上浪费时间。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9B%9E%E8%B0%83":{"title":"回调","content":"# 回调\n\n\u003e A类a方法调用B类的b方法，b方法再调用A类的c方法\n\u003e 就是不光把工作内容交给别的线程做，还要把结果处理也交给别的线程做。\n\n回调的本质，是将一个任务分成两部分，在耗时操作之前的部分，和耗时操作之后的部分，后者是前者的继续，或者叫做[[续体]]（continuation）。回调式就是把续体写成回调函数的形式，传递到其他地方，这种操作又叫做续体传递（continuation-passing）。从这个层面上看，回调是续体传递风格（Continuation-Passing Style, CPS）的一种。\n\n## 举例\n\n现在领导要员工A做一件事，给他发布了任务，需要员工A做完后再通知领导。\n\n对于领导来说：发布任务（fabuTask）,获得结果（result）\n\n对于员工来说：处理任务（doSomthing）,通知领导结果（result）\n\n### 任务发布者\n\n\u003e 任务发布者定义了回调函数，回调函数的参数就是未来任务执行者提交的结果。\n\n```java\n/**\n * 回调的方法\n *\n */\npublic interface CallBack {\n\tvoid result(String result);\n}\n```\n\n领导发布的任务：让员工做事：\n\n```java\n/**\n * 领导发布任务、获得结果\n *\n */\npublic class Manager implements CallBack{\n \n\t@Override\n\tpublic void result(String result) {\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic void fabuTask(EmployeeInterfce employee) throws InterruptedException {\n\t\tSystem.out.println(\"领导发布任务\");\n\t\temployee.doSomthing(new Manager());\t\t\n\t\t\n\t}\n \n}\n```\n\n领导还有其它任务的话：\n\n```java\n/**\n * 领导发布任务、获得结果\n *\n */\npublic class Manager implements CallBack{\n \n\t@Override\n\tpublic void result(String result) {\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic void fabuTask(EmployeeInterfce employee) throws InterruptedException {\n\t\tSystem.out.println(\"领导发布任务\");\n\t\tnew Thread(new Runnable() {\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\temployee.doSomthing(new Manager());\t\n\t\t\t}\n\t\t}).start();\t\t\n\t}\n}\n```\n\n### 任务执行者\n\n\u003e 任务执行者计算出结果后，会调用发布者的回调函数，并将结果作为参数传递。\n\u003e 这里任务执行完毕后不会回到原来的线程再执行，而是在工作线程中new了一个发布者并调用回调函数处理结果。\n\n员工处理事情，需要接收一个CallBack参数,这样才能知道要向谁反馈\n\n```java\n/**\n * 员工做事、通知领导\n *\n */\npublic class Employee implements EmployeeInterfce{\n\t\n\t@Override\n\tpublic void doSomthing(CallBack callBack) {\n\t\tString result = \"做完了\";\n\t\tcallBack.result(result);\n\t}\n}\n```\n\n```java\npublic class Test {\n \n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tEmployee employee = new Employee();\n\t\tManager manager = new Manager();\n\t\tmanager.fabuTask(employee);\n\t\tSystem.out.println(\"领导继续做事\");\n\t}\n \n}\n```\n\n可以看到，领导在发布玩任务后，就不用管员工是否做完就可以接着做自己的事，这种就是异步调用 。\n\n## 总结\n\n感觉回调函数就是一个处理结果的函数，任务发布者将任务抛给其它线程的同时，定义了自己未来接收到结果后的行为。\n当其它线程工作完毕，就会调用这个回调函数让发布者处理结果。\n\n\u003e 处理结果的逻辑从任务发布者的线程转移到了任务执行者的线程中了。\n\u003e 任务发布者就不用为了等待结果而阻塞了。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87%E7%9A%84%E5%8E%9F%E7%90%86":{"title":"多级页表提高内存使用效率的原理","content":"\n# 多级页表提高内存使用效率的原理\n\n## 提高寻址效率\n\n不分页： 16\n均分两页：16 --\u003e 8+8，8 * 8 = 64；\n以此类推...\n\n假设两级[[3-计算机科学/2-计算机组成原理/分页|分页]]，一级用于定位在第几个二级[[3-计算机科学/2-计算机组成原理/页表|页表]]，每个二级页表又能定位某一块内存空间，即 8**=64；\n\n## 提高空间效率\n\n[[3-计算机科学/2-计算机组成原理/进程|进程]]的地址空间很少有完全映射的情况。正是因为省却了大量未映射的页表项使得页表的空间大幅减少。\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923203858.png]]\n\n## 参考\n\n[页表是啥以及为啥多级页表能够节省空间_wx61307a0120efd的技术博客_51CTO博客](https://blog.51cto.com/u_15352922/3742181)\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F":{"title":"寻址方式","content":"# 寻址方式\n\n\u003e 寻址方式: 指令中指明操作数存放位置的表达方式.  \n\n## 指令中操作数的数据存放位置情况\n\n- 存放指令中 (立即数)\n    - 操作数包含在指令中\n    - 备操作数据直接表示在指令的操作数字段中\n    - 紧跟在操作码之后\n    - 例如 `MOV AL, 10H`\n- 存放于寄存器中 (寄存器操作数) \n    - 数据存放在 CPU 的一个寄存器中\n    - 例如 `INC CX`\n- 存放于存储器中 (存储器操作数)\n    - 数据再内存或 I/I 端口中\n    - 存放数据的偏移地址以某种方式表示在指令中\n    - 例如 `MOV AX, [2500H]`\n        - 其中 [2500] 为存储器操作数\n        - 存储器操作数中操作的数字段指示此操作数的偏移地址\n        - 段地址由某个段寄存器提供\n        - 默认为 DS 提供\n\n## 寻址方式分类\n\n- 立即数寻址\n    - 操作数为立即数\n    - 直接存放在指令的操作数字段\n    - 只允许源操作数为立即数\n    - 目标操作数必须是寄存器或存储单元\n        - 给寄存器或存储单元赋值\n- 寄存器寻址\n    - 直接在指令中写出寄存器名称\n- 存储器寻址\n    - 直接寻址\n        - 操作数存在内存中, 操作数的偏移地址直接表示在指令中\n        - 表示格式: [偏移地址]\n        - 默认操作数存放在内存的数据段中\n        - 例如 `MOV AL, [1064H]`\n        - 段超越指明使用的段\n    - 寄存器间接寻址\n    - 基址加变址寻址\n    - 相对加基址变址寻址","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B9%B6%E5%8F%91":{"title":"并发","content":"# 并发\n\n并发（concurrent）是同一时间应对（dealing with）多件事情的能力。\n操作系统通过任务调度器组件，将CPU的时间片（win下最小15ms）分给不同的任务使用。CPU在多个任务之间快速切换，时间非常短，让人产生了一种多个任务在同时执行的错觉，实际上任务还是串行执行。\n\n![[z-oblib/z2-attachments/Pasted image 20220525143804.png]]","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B9%B6%E8%A1%8C":{"title":"并行","content":"# 并行\n\n并行（parallel）是同一时间动手做（doing）多件事情的能力。\n两个CPU核心真正同时运行两个任务（线程）。\n\n![[z-oblib/z2-attachments/Pasted image 20220525143900.png]]\n\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%BC%82%E6%AD%A5":{"title":"异步","content":"# 异步\n\n## 以调用方角度\n\n不需要等待结果返回，就能继续运行就是异步。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%82%B2%E8%A7%82%E9%94%81":{"title":"悲观锁","content":"# 悲观锁\n\n悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对**每次数据操作加上锁**，以保证临界区的程序同一时间只能有一个[[3-计算机科学/2-计算机组成原理/线程|线程]]在执行。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C":{"title":"指令级并行","content":"# 指令级并行\n\n## 名词解释\n\n### Clock Cycle Time \n主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.25 ns，作为对比，我们墙上挂钟的Cycle Time 是 1s。\n例如，运行一条加法指令一般需要一个时钟周期时间。\n### CPI \n有的指令需要更多的时钟周期时间，所以引出了 CPI （Cycles Per Instruction）指令平均时钟周期数。\n### IPC \nIPC（Instruction Per Clock Cycle） 即 CPI 的倒数，表示每个时钟周期能够运行的指令数。\n### CPU 执行时间 \n程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示。\n程序 CPU 执行时间 = 指令数 * CPI * Clock Cycle Time\n## 鱼罐头的故事\n\n加工一条鱼需要 50 分钟，只能一条鱼、一条鱼顺序加工...\n![[z-oblib/z2-attachments/Pasted image 20220531001400.png]]\n\n可以将每个鱼罐头的加工流程细分为 5 个步骤：\n- 去鳞清洗 10分钟\n- 蒸煮沥水 10分钟\n- 加注汤料 10分钟\n- 杀菌出锅 10分钟\n- 真空封罐 10分钟\n\n![[z-oblib/z2-attachments/Pasted image 20220531001700.png]]\n\n即使只有一个工人，最理想的情况是：他能够在 10 分钟内同时做好这 5 件事，因为对第一条鱼的真空装罐，不会影响对第二条鱼的杀菌出锅...\n\n## 指令重排序优化\n\n事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这 5 个阶段。\n\n```java\n// 可以重排的例子\nint a = 10; // 指令1\nint b = 20; // 指令2\nSystem.out.println( a + b );\n \n// 不能重排的例子\nint a = 10; // 指令1\nint b = a - 5; // 指令2\n```\n\n现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。\n\n![[z-oblib/z2-attachments/Pasted image 20220531005822.png]]\n优化为\n![[z-oblib/z2-attachments/Pasted image 20220531005812.png]]\n\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F":{"title":"指令重排序","content":"# 指令重排序\n\n计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。\n\n**为什么指令重排序可以提高性能？**\n\n简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，**流水线技术**产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。\n\n但是，流水线技术最害怕**中断**，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。\n\n我们分析一下下面这个代码的执行情况：\n\n```java\na = b + c;\nd = e - f;\n```\n\n先加载b、c（**注意，即有可能先加载b，也有可能先加载c**），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。\n\n为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。\n\n综上所述，**指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。**\n\n指令重排一般分为以下三种：\n\n- **编译器优化重排**\n    编译器在**不改变单[[3-计算机科学/2-计算机组成原理/线程|线程]]程序语义**的前提下，可以重新安排语句的执行顺序。\n- **指令并行重排**\n    现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。\n- **内存系统重排**\n    由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据[[3-计算机科学/2-计算机组成原理/同步|同步]]存在时间差。\n\n**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8":{"title":"标志寄存器","content":"# 标志寄存器\n\n结构：\n![[z-oblib/z2-attachments/Pasted image 20220912223816.png]]\n\n\n含义：\n![[z-oblib/z2-attachments/Pasted image 20220912223822.png]]\n\n- 状态标志\n    - 用于记录程序运行结果的状态信息\n        - CF 进位标志 (Carry Flag)\n            - 当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0\n        - ZF 零标志 (Zero Flag)\n            - 弱运算结果为 0, 则置 1, 否则 0\n        - SF 符号标志 (Sign Flag)\n            - 若运算结果最高位(符号位)为 1, 则置 1, 否则 0\n        - PF 奇偶标志 (Parity Flag)\n            - 运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0\n        - OF 溢出标志 (Overflow Flag)\n            - 运算结果有溢出, 则置 1, 否则 0\n            - 溢出: 有符号数的运算结果不正确\n        - AF 辅助进位标志 (Auxiliary Carry Flag)\n            - 运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0\n- 控制标志\n    - 用于控制处理器执行指令\n        - DF 方向标志 (Direction Flag)\n            - 用于串操作指令, 控制地址的变化方向\n            - 1 则存储器地址自动增加\n            - 0 则存储器地址自动减少\n            - `CLD` 用于复位 DF = 0\n            - `STD` 用于置位 DF = 1\n        - IF 终端允许标志 (Interrupt-enable Flag)\n            - 0 禁止中断\n            - 1 允许中断\n            - `CLI` 用于复位 IF = 0\n            - `STI` 用于置位 IF = 1\n        - TF 陷阱标志 (Trap Flag)\n            - 0 处理器正常工作\n            - 1 处理器单步执行\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%A0%88%E5%B8%A7":{"title":"栈帧","content":"\n# 栈帧\n\n当前函数可用的栈空间，称为该函数的栈帧。\n\n函数的局部变量和形参会分配在栈帧中。\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8":{"title":"段寄存器","content":"# 段寄存器\n\n- 8086CPU 有 4 个段寄存器\n- 每个段寄存器用来确定一个逻辑段的起始位置\n- 每种逻辑段均有自己的用途\n    - CS: 代码段寄存器 (Code Segment)\n        - 利用 CS:IP 取得下一条要执行的指令\n    - DS: 数据段寄存器 (Data Segment)\n        - 利用 DS:EA 存取数据段中的数据\n    - SS: 栈段寄存器 (Stach Segment)\n        - 利用 CS:IP 操作堆栈顶的数据\n    - ES: 附加段寄存器 (Extra Segment)\n        - 利用 ES:EA 存取附加段中的数据\n\n- EA 是偏移地址, 称之为有效地址 EA\n- 若操作数在主存中, 存取的方式有:\n\t- 直接寻址\n\t- 寄存器间接寻址\n\t- 寄存器相对寻址\n\t- 基址变址寻址\n\t- 相对基址变址寻址\n\n- 没有指明段前缀时, 一般的数据访问在 DS (u数据) 段\n    - `MOV AX, [1000H]` == `MOV AX,DS:[1000H]`\n        - 从默认的 DS 段中取出数据\n    - `MOV AX,CS:[1000H]`\n        - 从指定的 CS 段取出数据\n\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-1":{"title":"段寄存器","content":"\n# 段寄存器\n\n段寄存器是因为对内存的[[3-计算机科学/2-计算机组成原理/分段|分段]]管理而设置的。\n计算机需要对内存分段，以分配给不同的程序使用。在描述内存分段时，需要有如下段的信息：\n1. 段的大小\n2. 段的起始地址\n3. 段的管理属性（禁止写入/禁止执行/系统专用等）。\n\n需要用8个字节（64位）存储这些信息，但段寄存器只有16位，因此段寄存器中只能存储段号（segment selector，也译作“段选择符”），再由段号映射到存在内存中的[[3-计算机科学/3-操作系统/Linux/GDT|GDT]]，读取段的信息。\n\n## 寄存器值\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923214544.png]]\n\n段寄存器包含index、LDT/GDT、PL\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%AE%B5%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F":{"title":"段的组织方式","content":"\n# 段的组织方式\n\n操作系统要求编写的程序进行[[3-计算机科学/2-计算机组成原理/分段|分段]]，C/CPP编译器帮我们做了这个操作。\n\n## 段的形成\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20221002203843.png]]\n\n多个同类型的.o文件的区间（节）会合并成一个段。\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20221002211006.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86":{"title":"段页式内存管理","content":"\n# 段页式内存管理\n\n结合了[[3-计算机科学/2-计算机组成原理/分段|分段]]和[[3-计算机科学/2-计算机组成原理/分页|分页]]的优点：\n\n将程序分为多个逻辑段，在**每个段里面又进行分页**，即将分段和分页组合起来使用。\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923210822.png]]\n\n## 实现\n\n在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量：\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923210848.png]]\n通过在哪一段的那一页的偏移多少来定位内存位置。\n\n系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）。系统中还应有一个段寄存器，指出作业的段表起始地址和段表长度。\n\n## 地址变换\n\n首先通过**段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址**。如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923212952.png]]\n\n## 参考\n\n[(1条消息) 段页式内存管理_~青萍之末~的博客-CSDN博客_段页式内存管理](https://blog.csdn.net/daaikuaichuan/article/details/88649113)\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%81":{"title":"流","content":"# 流\n\n\u003e [2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)](https://www.cnblogs.com/The-explosion/articles/12246297.html)\n\n在C语言中引入了流(stream)的概念。它**将数据的输入输出看做是数据的流入和流出**，这样不管是磁盘文件或者是物理设备（打印机，显示器，键盘等）都可以看做一种流的源和目的地，视他们为同一种东西，而不管其具体的物理结构，即对他们的操作，就是数据的流入和流出。这种把数据的输入输出作为操作对象，抽象化为一种流，而不管它的具体结构的方法有利于编程，而设计流的输出操作的函数可用于各种对象，与具体的实体无关，即具有通用性。\n\n标准I/O库的所有操作都是围绕流来进行的，在标准I/O中流用FILE *来描述。\n\n标准I/O的核心对象就是流。当用标准I/O打开一个文件时，就会创建一个FILE结构体描述该文件（或者理解为创建一个FILE结构体和实际打开的文件关联起来）。我们把这个FILE结构体形象的称为流。标准I/O函数都基于流进行各种操作。\n\nC语言将每个文件简单地作为顺序字节流(如下图)。\n\n![[z-oblib/z2-attachments/Pasted image 20220802234132.png]]\n\n每个文件用文件结束符结束，或者在特定字节数的地方结束，这个特定的字节数可以存储在系统维护的管理数据结构中。\n当打开文件时，就建立了和文件的关系。在开始执行程序的时候，将自动打开3个文件和相关的流：标准输入流、标准输出流和标准错误。**流提供了文件和程序的通信通道**。例如，标准输入流使得程序可以从键盘读取数据，而标准输出流使得程序可以在屏幕上输出数据。\n\n打开一个文件将返回指向FILE结构(在stdio.h中定义)的指针，它包含用于处理文件的信息，也就是说，这个结构包含[[3-计算机科学/3-操作系统/Linux/文件描述符|文件描述符]]。标准输入、标准输出和标准错误是用[[3-计算机科学/3-操作系统/Linux/文件指针|文件指针]]stdin、stdout和stderr来处理的。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%A8%8B%E5%BA%8F":{"title":"程序","content":"\n# 程序\n\n程序是计算机指令的集合，存放在磁盘中。\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6":{"title":"竞态条件","content":"# 竞态条件\n\nrace condition\n\n多个[[3-计算机科学/2-计算机组成原理/线程|线程]]在[[3-计算机科学/2-计算机组成原理/临界区|临界区]]内执行，由于代码的执行序列不同，而导致的结果无法预测。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BA%BF%E7%A8%8B":{"title":"线程","content":"# 线程\n\n线程是进程中的子任务，同一个进程的线程之间共享进程占有的内存空间和I/O。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81":{"title":"线程状态","content":"# 线程状态\n\n操作系统层面有5种状态：\n\n![[z-oblib/z2-attachments/Pasted image 20220526173846.png]]\n\n- 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联。\n- 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行。\n- 【运行状态】指获取了 CPU 时间片运行中的状态。\n\t- 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换\n- 【阻塞状态】。\n\t- 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】。\n\t- 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。\n\t- 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们。\n- 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%87%AA%E6%97%8B":{"title":"自旋","content":"# 自旋\n\n不断尝试去获取锁，一般用循环来实现。\n\n自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。 ^f17d9d","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98":{"title":"虚拟内存","content":"\n# 虚拟内存\n\n对于程序来说，理论上可以生成整个内存寻址范围这么大的内存，但实际上内存是多个程序共享的。\n\n虚拟是指：操作系统骗程序我给你了整片空间，但实际物理内存并没有分配，为了防止程序发觉到问题，操作系统通过虚拟内存映射和交换内存的方式，将虚拟内存按需映射到物理内存，暂时不用的就放到磁盘上，用到了就赶紧拿过来放到内存里。\n\n为了加速虚拟内存地址和物理内存地址的转换，使用专门的硬件设备来做映射：MMU。\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B":{"title":"进程","content":"\n# 进程\n\n进程是[[3-计算机科学/2-计算机组成原理/程序|程序]]运行的实例，对程序运行时对计算机资源使用情况的描述。\n进程是资源分配的基本单位。\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"进程与线程的区别","content":"# 进程与线程的区别\n\n- [[3-计算机科学/2-计算机组成原理/进程|进程]]基本上相互独立的，相互之间独占内存地址空间和系统资源（I/O等）；而[[3-计算机科学/2-计算机组成原理/线程|线程]]存在于进程内，是进程的一个子集。\n- 进程拥有共享的资源，如内存空间等，供其内部的线程共享。\n- 进程间通信较为复杂。\n\t- 同一台计算机的进程通信称为 IPC（Inter-process communication）。\n\t- 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。\n- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。\n- 进程管理开销更大，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度。\n- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低，线程只需要保存寄存器和栈信息。\n\n## 不同平台和语言下的区别\n\n- Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。\n- 在 windows 中进程是不活动的，只是作为线程的容器。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%A1%B5%E8%A1%A8":{"title":"页表","content":"\n# 页表\n\n\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923202638.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%BC%93%E5%AD%98":{"title":"CPU缓存","content":"# CPU缓存\n\n![[z-oblib/z2-attachments/Pasted image 20220602143516.png]]\n\n| 从 cpu 到 | 大约需要的时钟周期                 |\n|------------|-----------------------|\n| 寄存器 | 1 cycle (4GHz 的 CPU 约为0.25ns) |\n| L1| 3~4 cycle                      |\n| L2| 10~20 cycle                    |\n| L3| 40~45 cycle                    |\n| 内存| 120~240 cycle                  |\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/DMA":{"title":"DMA","content":"\n# DMA\n\nDirect Memory Access 直接内存访问控制器\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/MESI":{"title":"MESI","content":"# MESI\n\n**M：代表已修改（Modified）**：Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面；  \n**E：代表独占（Exclusive）**：Cache Block 里面的数据和主内存里面的数据是一致的；  \n**S：代表共享（Shared）**：Cache Block 里面的数据和主内存里面的数据是一致的；  \n**I：代表已失效（Invalidated）**：Cache Block 里面的数据已经失效了，不可以相信这个 Cache Block 里面的数据；\n\n![[z-oblib/z2-attachments/24483793-3cef70653d60cdf9.webp]]\n\n## 问题\nCPU操作分为两种：load（读）、store（写），加入缓存的目的是提前缓存内存的数据，提高load的效率，但是store的速度降低了，因为CPU将数据store到内存多了写缓存的步骤，并且需要同步所有CPU的私有缓存。这样store操作会严重阻塞后续的load操作，这样加缓存的意义完全就没有了，不仅没能提高load的效率，反而阻塞了load。为了解决load被阻塞的问题，在CPU中加入了新的组件store buffer（写队列）；\n\n![[z-oblib/z2-attachments/24483793-80300b10191392a0.webp]]\n每个CPU都有一个store buffer，当CPU需要执行store操作时，会将store操作先放入store buffer中，不会立即执行store操作，等待`合适的时机`再执行（store buffer满了等等情况会真正执行store操作），在store后面的load操作不用再等store真正执行完毕才能执行，只要store放入了store buffer中，load就可以执行了。\n\n## 总结\n\nMESI协议的引入会导致缓存的写入效率降低，所以引入了store buffer等部件，store buffer将store操作缓存起来，不会立即写入缓存，**导致多CPU内的值同步会有一定延迟**，间接导致cpu的操作[[3-计算机科学/2-计算机组成原理/指令重排序|重排序]]，多cpu的共享变量的操作会发生混乱，所以JMM中可以使用[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]强制刷新store buffer，让多CPU中的值[[3-计算机科学/2-计算机组成原理/同步|同步]]没有延迟，保证多CPU共享变量不会发生混乱。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/MMU":{"title":"MMU","content":"\n# MMU\n\nMemory Management Unit，内存管理单元。\n虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制，在较为简单的计算机体系结构中，负责总线的仲裁以及存储体切换（bank switching，尤其是在8位的系统上）。\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/TLB":{"title":"TLB","content":"\n# TLB\n\nTranslation Lookaside Buffer，[[3-计算机科学/2-计算机组成原理/页表|页表]]缓存，转址旁路缓存。由[[3-计算机科学/2-计算机组成原理/MMU|MMU]]用于改进虚拟地址到物理地址的转译速度。\n\n为了加快MMU规则匹配的处理过程，有效地址和实际物理地址的对应表通常保存在一块单独的高速缓存中，\n","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/x86%E5%AF%84%E5%AD%98%E5%99%A8":{"title":"x86寄存器","content":"# x86寄存器\n\n![[z-oblib/z2-attachments/Pasted image 20220912222502.png]]\n\n这八个寄存器的名称如下：EAX（累加器）、EBX（基址）、ECX（计数）、EDX（数据）、ESP（栈指针）、EBP（基址指针）、ESI（源变址）、EDI（目的变址）。","lastmodified":"2023-01-23T15:37:51.542678635Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E4%BF%A1%E5%8F%B7":{"title":"信号","content":"\n# 信号\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005234142.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005234938.png]]\n\nLinux中的绝大多数信号都是由内核发送的，所以在发送信号给某[[3-计算机科学/2-计算机组成原理/进程|进程]]之前，需要先陷入内核。\n\nLinux中定义了很多信号类型，这些信号都有默认的处理方式（例如红灯亮的信号，人的默认处理方式是停下），但程序内也可以自定义信号的处理方式（例如，红灯亮了偏不停）。当内核将相关信号发送给进程，该进程接收到这些信号后，会触发对应的信号处理程序去处理该信号，从而打断该进程的正常执行流程。\n\n在shell中，也支持信号机制，可通过kill命令发送信号给指定进程。可能这里会出现一个疑惑，刚才说信号绝大多数是由内核发送的，为什么kill命令（bash下有两个kill命令，一个是bash内置kill命令，一个是外置kill命令，但无论如何，都是用户进程）对应的进程能够发送信号给其它进程？这是因为kill发送的信号先是传递给内核的，内核再将这个信号传递给对应进程。所以这里需要进行一次[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]。\n\n![[z-oblib/z2-attachments/Pasted image 20220803161416.png]]\n\n\n1-31是不可靠信号，之后的是可靠信号。可靠是指阻塞时发送信号会在重新接收信号后全部收到而不丢失。\n\n## 编程接口\n\n子进程会继承父进程的信号处理函数，子进程可以注册新的信号处理函数，覆盖父进程提供的行为。\n\n### 注册信号处理函数\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005235717.png]]\n\n### 产生信号\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006000842.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006000914.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006005101.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006010248.png]]\n\n### 未决信号\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006010520.png]]\n\n### 信号集类型\n\n本质是数组，为了方便理解看成一个类型：\n有2个信号集，阻塞信号，未决信号。\n信号到达并且在阻塞信号集中，则该信号是一个未决信号。\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006010756.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006010911.png]]\n\nset、delete前信号集必须初始化：\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006010941.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006011030.png]]\n\n### 设置进程信号掩码集（需要屏蔽的信号集合）对某信号阻塞\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006011355.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006011530.png]]\n\n### 获取进程未决信号集\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006012305.png]]\n\n### 阻塞信号\n\n就是将信号加入到屏蔽信号集。\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E4%BF%A1%E5%8F%B7%E9%87%8F":{"title":"信号量","content":"# 信号量\n\n信号量（[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Semaphore|Semaphore]]）也称为信号灯，典故来源于荷兰：火车根据旗标来决定是否通行。\n通过红绿灯理解[[3-计算机科学/3-操作系统/Linux/信号|信号]]和信号量，感觉它们似乎是一样的。但是，**信号量机制是根据红绿灯的事件让人等待（进程阻塞）或不等待（进程继续运行），只有这两种行为**；而**信号机制是根据红绿灯事件做出任何可能的处理，并不一定是等待（阻塞）或前行（不阻塞）**。\n\n![[z-oblib/z2-attachments/Pasted image 20220803161603.png]]\n\n信号量有很多种变体，下面简单描述其中一种信号量的规则：\n\n\u003e在荷兰文中，通过叫passeren，释放叫vrijgeven，PV操作因此得名。\n\n1. 如果一个进程请求P操作(减1操作，即请求一个信号灯)，如果减去之后信号量的数值为负数，则该进程被阻塞，如果减去之后为0或正数，则放行该进程\n2. 如果一个进程请求V操作(加1操作，即释放或增加一个信号灯)，进程直接放行\n3. 如果请求V操作，如果加1之后仍为0或负数，则放行该进程的同时还唤醒另一个被阻塞的进程。如果加1后为正数，则直接添加一个信号灯资源\n\n总结起来很简单：如果当前没有信号灯资源(小于或等于0)，那么消费信号灯(P原语)的进程就会被阻塞；如果有信号灯资源(大于0)，就直接放行。如果一个进程是来生产信号灯资源的(V原语)，那么这个进程当然要放行；因为添加了一个信号灯，那么还可以拥有唤醒一个被阻塞进程的能力(如果有被阻塞进程的话)。\n\n最简单的信号量当然是初始时只使用1个信号灯，从而实现互斥锁（也称为互斥量）机制：P是申请锁操作，只有在有值为1的时候才能申请锁，否则被阻塞；V是释放锁，一直被放行。\n\n## 编程接口\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103103419.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103103430.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103104219.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103104243.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103104551.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221103104901.png]]\n\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B":{"title":"僵尸进程","content":"\n# 僵尸进程\n\n进程终止后，剩余的部分系统资源例如[[3-计算机科学/3-操作系统/Linux/PCB|PCB]]等，没有被父进程[[3-计算机科学/3-操作系统/Linux/Linux进程资源回收|回收]]。\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98":{"title":"共享内存","content":"\n# 共享内存\n\n共享内存（Shared Memory）是直接从内核维护的内存中划分一片内存，并将该内存映射到一个或多个[[3-计算机科学/2-计算机组成原理/进程|进程]]中。\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006014232.png]]\n\n因为可能多个进程映射到同一共享内存，所以某进程对此内存数据的修改会直接影响其它进程，这样就能在进程之间传递消息。但也正因为如此，在使用共享内存时，应当保证没有两个或以上的进程同时修改共享内存数据。\n\n共享内存是效率最高的进程间通信方式，它完全内存化操作，且没有任何内存拷贝行为，此外，内存映射到不同进程之后，操作系统就不再参与该片内存的操作，用户进程可以有权访问这段内存。\n\n内存共享和[[3-计算机科学/3-操作系统/Linux/文件映射|文件映射]]非常像，不同之处就在**于共享内存没有对具体的磁盘文件进行映射，而是直接映射物理内存到进程中**。所以，它也映射在进程堆栈中间的那片未分配内存上。如图。\n\n![[z-oblib/z2-attachments/Pasted image 20220803160824.png]]\n\n## 编程接口\n\n### 创建svipc对象\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006155122.png]]\n\n### 创建共享内存\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006161526.png]]\n\n### 共享内存与进程关联\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006162428.png]]\n\n### 共享内存与进程解绑\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006165944.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D":{"title":"写时拷贝","content":"\n# 写时拷贝\n\n共享映射时，写操作会发生在拷贝空间，避免其它线程对共享内存的读。\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004011513.png]]\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83":{"title":"变量命名规范","content":"\n# 变量命名规范\n\n## H\n\n- hdr = HeaDeR = header\n\t- 常出现在[[3-计算机科学/3-操作系统/Linux/ELF|elf]]结构定义中，如shdr为 section header\n\n## R\n\n- rel = relocation = 重定位\n\t- rel.text指text段对应的[[3-计算机科学/3-操作系统/Linux/重定位表|重定位表]]\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%9F%BA%E5%9C%B0%E5%9D%80":{"title":"基地址","content":"# 基地址\n\n## 计算\n\n\u003e [linux - ELF的基地址 | 码农俱乐部 - Golang中国 - Go语言中文社区 (mlog.club)](https://mlog.club/article/241831)\n\u003e [ELF 文件 - CTF Wiki (ctf-wiki.org)](https://ctf-wiki.org/executable/elf/structure/basic-info/#-base-address)\n\n### 文件的默认加载基地址\n\n通过 `readelf -l a.out` 可以查看到程序的头信息，第一个类型为`LOAD`的段的虚拟地址就是基地址：\n![[z-oblib/z2-attachments/1L)((}ZXMQ(U$39~Z`AM53R.png]]\n\n但这个地址可能并不是程序内存镜像中实际的虚拟地址。\n\n### 内存镜像的基地址\n\n地址无关代码使用段之间的相对地址来进行寻址，内存中的虚拟地址之间的差必须与文件中的虚拟地址之间的差相匹配。\n\n内存中任何段的虚拟地址与文件中对应的虚拟地址之间的差值对于任何一个可执行文件或共享对象来说是一个单一常量值。这个差值就是基地址，基地址的一个用途就是在动态链接期间重新定位程序。\n\n要计算基地址，首先拿到文件默认加载基地址，之后把该地址缩小为与之最近的最大页面的整数倍即是内存基地址。根据要加载到内存中的文件的类型，内存地址可能与 p_vaddr 相同也可能不同。\n\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%A5%97%E6%8E%A5%E5%AD%97":{"title":"套接字","content":"# 套接字\n\n套接字（Socket）用于协调不同计算机上的[[3-计算机科学/2-计算机组成原理/进程|进程]]间通信，也就是基于网络的通信。当然，也可以在本机上使用套接字进行进程间的通信。\n\n套接字通信的方式非常多，有Unix域套接字、TCP套接字、UDP套接字、链路层套接字等等。但最常用的肯定是TCP套接字。所以，这里介绍下TCP Socket通信方式，稍后再单独介绍Unix域套接字。\n\nTCP Socket用于客户端、服务端的基于TCP协议的通信，所以在客户端和服务端均需要创建一个套接字。创建TCP套接字时会返回这个套接字的文件描述符，可通过这个[[3-计算机科学/3-操作系统/Linux/文件描述符|文件描述符]]对套接字进行读和写操作。\n\n对比一下，当一个程序需要对一个磁盘文件同时进行读写操作（在命令行下似乎没有找到这种命令，但通过编程方式是很容易实现的）时，由于只通过单个文件描述符同时负责读和写，很可能需要通过不断移动文件指针的方式来改变读写的位置，否则数据很容易错乱。\n\n而TCP套接字也是通过单个文件描述符进行读写套接字的，为了保证读和写的位置不错乱，操作系统在内核空间为**每个TCP套接字维护了两个buffer空间**，一个buffer用于写、一个buffer用于读。提供读的buffer空间称为recv buffer，提供写的buffer空间称为send buffer，它们统称为socket buffer。\n\n所以，服务端和客户端通过两个套接字通信就简单了，一端向send buffer写数据，该buffer的数据会通过已经建立好的TCP连接发送到另一端的recv buffer，于是另一端只需从recv buffer中读数据即可实现不同计算机上的进程间通信。过程如图。\n\n![[z-oblib/z2-attachments/Pasted image 20220803132920.png]]","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8":{"title":"字符串表","content":"# 字符串表\n\n字符串表节包含以空字符结尾的字符序列，通常称为字符串。目标文件使用这些字符串表示符号和节的名称。可以将字符串作为字符串表节的索引进行引用。\n\n第一个字节（索引零）包含空字符。同样，字符串表的最后一个字节也包含空字符，从而确保所有字符串都以空字符结尾。根据上下文，索引为零的字符串不会指定任何名称或指定空名称。\n\n允许使用空字符串表节。节头的 sh_size 成员值为零。对于空字符串表，非零索引无效。\n\n节头的 sh_name 成员包含节头字符串表的节索引。节头字符串表由 ELF 头的 e_shstrndx 成员指定。下图显示了具有 25 个字节的字符串表，并且其字符串与各种索引关联。\n\n## 举例\n\nELF 字符串表：\n![[z-oblib/z2-attachments/Pasted image 20220911030139.png]]\n\n ELF 字符串表索引：\n\n| 索引 | 字符串      |\n|----|----------|\n| 0  | 无        |\n| 1  | name     |\n| 7  | Variable |\n| 11 | able     |\n| 16 | able     |\n| 24 | 空字符串     |\n\n## 特点\n\n字符串表索引可以指向节中的任何字节。一个字符串可以出现多次。可以存在对子字符串的引用。一个字符串可以多次引用。另外，还允许使用未引用的字符串。","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B":{"title":"孤儿进程","content":"\n# 孤儿进程\n\n父进程终止但子进程未结束，子进程的父进程会变为init进程，该子进程为孤儿进程，init为孤儿院。\n","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%AF%BC%E5%85%A5%E8%A1%A8":{"title":"导入表","content":"# 导入表\n\n\u003e [(34条消息) PE导入表和IAT表的原理及工作关系_C4cke的博客-CSDN博客_pe文件iat表](https://blog.csdn.net/qq_35289660/article/details/107329444)\n\n## 分类\n\n- IAT: Import Address Table 导入（函数）地址表\n- INT: Import Name Table 导入（函数）名称表\n\n## 结构\n\nImport Descriptor 导入表，是记录PE文件中用到的动态连接库的集合，一个dll库在导入表中占用一个元素信息的位置，这个元素描述了该导入dll的具体信息。如dll的最新修改时间、dll中函数的名字/序号、dll加载后的函数地址等。而一个元素即一个结构体，一个导入表即该结构体的数组，其结构体如下所示：\n\n```cpp\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n    union {\n        DWORD   Characteristics;            //导入表结束标志\n        DWORD   OriginalFirstThunk;         //RVA指向一个结构体数组(INT表)\n    };\n    DWORD   TimeDateStamp;                  //时间戳\n    DWORD   ForwarderChain;                 // -1 if no forwarders\n    DWORD   Name;                           //RVA指向dll名字，以0结尾\n    DWORD   FirstThunk;                     //RVA指向一个结构体数组(IAT表)\n} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;\n```\n\n## 作用\n\n说到导入表，肯定就是对应导出表。而导出表的作用是自身提供一张清单，表明自己又哪些函数，大多是dll为exe提供函数，存在导出表。那相反，exe为了表明自身需要哪些dll的函数，也会生成一张表，那这张表就是导入表。\n\n有些dll一会需要使用别的dll的函数，那这类dll也会有导入表。\n\n同样，导出表是提供的自身要导出的函数的地址，对应导入表，也是为了提供的要导入的dll的函数的地址，只不过由于这个地址不固定，所以每次都会重新修正。\n\n## 工作原理\n\n导入表在目录项中的第二项（导出表之后）。对应目录项中的VirtualAddress（RVA）即指向的导入表。\n\n![[z-oblib/z2-attachments/Pasted image 20220907164948.png]]\n\n\u003e 上图PE文件在加载前的样子。\n\n上面涉及到的IMAGE_THUNK_DATA这个结构数组，其实就是一个4字节数，本来是一个union类型，能表示4个数，但我们只需掌握两种即可，其余两种已经成为历史遗留了。\n\n### OriginalFirstThunk\n\n\u003e original意思是：由name查到address，所以name是原始的。\n\nOriginalFirstThunk这个RVA所指向的是INT表（Import Name Table），这个表每个数据占4个字节。顾名思义就是表示要导入的函数的名字表。\n\n**导出函数可以以名字导出，亦可以序号导出**。所以为了方便区分，就将这INT表的每个值做了细微调整：\n\nINT：如果这个4字节数的**最高位**（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。\n\n`IMAGE_IMPORT_BY_NAME`: 前两个字节是一个序号，不是导入序号，一般无用，后面接着就是导入函数名字的字符串，以0结尾。\n\n![[z-oblib/z2-attachments/Pasted image 20220907181810.png]]\n\n### Name\n\n这个结构体变量也是一个RVA，直接指向一个字符串，这个字符串就是这个**导入表对应的DLL的名字**。说到这，大家明白，**一个导入表只对应一个DLL**。那肯定会有多个导入表。所以对应目录项里的VirtualAddress（RVA）指向的是所有导入表的首地址，每个导入表占20字节，挨着。最后以一个空结构体作为结尾（20字节全0结构体）。\n\n### FirstAddress\n\nFirstAddress（RVA）指向的就是IAT表！IAT表也是每个数据占4个字节。最后以4字节0结尾。\n\n注意上图PE文件加载前，IAT表和INT表的完全相同的，所以此时IAT表也可以判断函数导出序号，或指向函数名字结构体。\n\n而在加载后，差别就是IAT表发生变化，系统会先根据结构体变量Name加载对应的dll（拉伸），读取dll的导出表，对应原程序的INT表，匹配dll导出函数的地址，返回其地址，贴在对应的IAT表上，挨个修正地址（也就是GetProcAddress的功能）。\n\n所以上文说到，IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。\n\n![[z-oblib/z2-attachments/Pasted image 20220907181908.png]]\n\n\u003e 注意IAT表发生变化。","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%AF%BC%E5%87%BA%E8%A1%A8":{"title":"导出表","content":"# 导出表\n\n导出表的作用是自身提供一张清单，表明自己又哪些函数，大多是dll为exe提供函数，存在导出表。","lastmodified":"2023-01-23T15:37:51.730680336Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88":{"title":"文件指针","content":"# 文件指针\n\n\u003e [2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)](https://www.cnblogs.com/The-explosion/articles/12246297.html)\n\n\"文件指针(file pointer)\"指向进程用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符值。而文件描述符值是文件描述符表中的一个索引。从某种意义上说文件指针就是句柄的句柄。\n每个被使用的文件都在内存中开辟了一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，该结构体类型是由系统定义的，取名为FILE。\n\n\n\n```c\n/*FILE结构体*/\n#ifndef _FILE_DEFINED\nstruct _iobuf \n{\n    char *_ptr;       //文件输入的下一个位置 \n    int  _cnt;        //当前缓冲区的相对位置 \n    char *_base;      //指基础位置(即是文件的其始位置) \n    int  _flag;       //文件标志 \n    int  _file;       //文件的有效性验证 \n    int  _charbuf;    //检查缓冲区状况,如果无缓冲区则不读取 \n    int  _bufsiz;     //缓冲区大小 \n    char *_tmpfname;  //临时文件名\n};\ntypedef struct _iobuf FILE;\n```\n\n实际上，FILE结构是间接地操作系统的文件控制块 (FCB)来实现对文件的操作的，如下图：\n\n![[z-oblib/z2-attachments/Pasted image 20220802233104.png]]\n\n上面图中的_file实际上是一个描述符，作为进入打开文件表索引的整数。\n\n文件是存放在物理磁盘上的，包括文件控制块(FCB)和数据块。文件控制块通常包括文件权限、日期（创建、读取、修改）、拥有者、文件大小、数据块信息。数据块用来存储实际的内容。对于打开的文件，操作系统是这样管理的：系统维护了两张表，一张是系统级打开文件表【指向i节点】，一张是进程级打开文件表（每个进程有一个）【指向FILE结构体】。系统级打开文件表复制了文件控制块的信息等；进程级打开文件表保存了指向系统级文件表的指针及其他信息。\n\n系统级文件表每一项都保存一个计数器，即该文件打开的次数。我们初次打开一个文件时，系统首先查看该文件是否已在系统级文件表中，如果不在，则创建该项信息，否则，计数器加1。当我们关闭一个文件时，相应的计数也会减1，当减到0时，系统将系统级文件表中的项删除。 \n\n进程打开一个文件时，会在进程级文件表中添加一项。每项的信息包括当前文件偏移量（读写文件的位置）、存取权限、和**一个指向系统级文件表中对应文件项的指针**。系统级文件表中的每一项通过文件描述符（一个非负整数）来标识。\n\n通过上面所讲述的可以发现：FILE结构体中的_file成员应该是指向进程级打开文件表，然后，**通过进程级打开文件表可以找到系统级打开文件表**，进而可以通过FCB操作物理磁盘上面的文件。","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6":{"title":"文件描述符","content":"\n文件描述符表项的下标，就是文件描述符。\n\n# 文件描述符\n\n\u003e [2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)](https://www.cnblogs.com/The-explosion/articles/12246297.html)\n\n**文件描述符在形式上是一个非负整数**。实际上，它是一个**索引值**，指向内核为每一个进程所维护的该进程打开文件的**记录表**。该表的记录值是一个**file_struct对象**，成员字段记录了文件的状态信息、读写位置、路径等。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221002224808.png]]\n\n\u003e文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。\n\n系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。\n\n具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。内核使用3种数据结构表示打开的文件，他们之间的关系决定了在文件共享方面一个进程对另一个进程的影响。\n\n1. 进程级的文件描述符表。每个进程在进程表中都有一个纪录项，纪录项中包含一张打开文件描述符表，每个文件描述符各占一项，与每个文件描述符相关的是：\n\t1. 文件描述符标志\n\t2. 指向一个文件表项的指针\n2. 系统级的打开文件描述符表。内核为所有打开文件维护一张文件表项，每个文件表项包含：\n\t1. 文件状态(读 写 同步 非阻塞等)\n\t2. 当前文件偏移量\n\t3. 指向改文件inode（Linux）节点(v节点unix )的指针\n4. 文件系统的i-node表。每打开一个文件或设备，都有一个inode节点结构，inode节点包含了文件类型和对此文件进行操作函数的指针，对于大多数文件，inode节点还包含了文件的i节点索引节点，这些信息是在打开文件时从磁盘读入内存的，所以，文件的所有文件信息都是随时可用的。inode节点包含了文件的所有者，文件长度，指向文件实际数据块在磁盘上位置的指针等。\n5. \n\n## file_struct的存放\n\n从文件描述符表的前端开始找到第一个没有被使用的单元格。\n\n\n## 不同的进程打开同一个文件\n\n  不同的进程打开同一个文件，那么他们应该有各自对应的文件表表项。因为文件表表项记录了进程读写文件时的偏移量和存取权限。多个进程不可能共享一个文件偏移量。另外他们各自打开文件的权限也可能是不同的，有的是为了读、有的为了写，有的为了读写。所以，他们应该有不同的文件表表项。\n\n此外，因为是同一个文件，所以，多个进程会共享同一个索引结点表项。即他们的文件表表项指针会指向同一个索引结点，最终，如下图所示：\n\n![[z-oblib/z2-attachments/Pasted image 20220803012527.png]]\n\n## 同一个进程多次打开同一个文件\n\n每打开一次同一个文件，内核就会在文件表中增加一个表项。这是因为每次open文件时使用了不同的读写权限，而读写权限是保存在文件表表项里面的。所以，效果如下所示：\n\n![[z-oblib/z2-attachments/Pasted image 20220803012609.png]]\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84":{"title":"文件映射","content":"# 文件映射\n\n文件映射（Memory-mapped file）是将磁盘上文件的某段数据映射到内核的一段物理内存上，然后将此物理内存映射到一个或多个进程的虚拟内存中。映射了文件的进程可以直接读、写这段内存来达到读、写磁盘文件的功能。如果多个进程请求映射的文件区段相同，则只映射一次。\n\n所以，文件映射进行了两次映射，一次映射是将属于磁盘文件的部分或全部数据块映射到物理内存页中，另一次映射是将物理内存页映射到进程的虚拟页上。\n\n如图，图中假设磁盘数据块大小和内存页大小相同，将某文件中的6个数据块（可能只是该文件的一部分数据）映射到物理内存的页1、2、3、4、5、6中，并且两个进程都映射该磁盘文件相同的数据区域，所以两个进程都指向相同的物理内存页。\n\n![[z-oblib/z2-attachments/Pasted image 20220803141346.png]]\n\n使用文件映射时，最开始该内存区是空的。当访问这段内存时，如果访问的数据不在内存中（例如第一次访问），将出现page fault，于是会从磁盘中读取相应的数据块拷贝到这段内存（基于操作系统提供的预读优化，可能一次性会多读一些数据到映射的内存中）。当**向此内存区写数据时，会自动写入到磁盘文件对应的数据块中**（可以设置为其它写方式）。\n\n此外，通过设置文件映射方式，还支持**写时复制**。某进程要向该映射区的某内存页写数据时，会拷贝该页到自己的虚拟内存中，然后写数据到该副本页，而不会影响映射区的数据，而且以后该进程对该页的操作都将使用该副本。\n\n既然每个进程都能访问到文件映射的物理内存，那么这段物理内存分配在进程虚拟内存布局的哪一部分呢？这个简单思考下即可得知答案，进程的虚拟内存中，只有堆内存和堆栈中间的未分配地址空间是可以由用户进程自由使用的地址区域，如果将文件映射到堆中，假如映射的文件数据较大，已分配的堆内存中空闲页很可能不足以映射该文件，操作系统需要为其分配更多的堆内存，另一方面，就算当前堆内存能放下文件映射，但也很可能因此而导致空闲页所剩不多，进程之后的运行很可能还是要请求分配新的堆内存，如此看来，倒不如直接映射在堆栈中间那片未分配的地址空间，并且为堆和栈都预留一段未分配空间。图中给出文件映射在进程内存布局中的位置。\n\n![[z-oblib/z2-attachments/Pasted image 20220803141403.png]]\n\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90":{"title":"文件权限","content":"\n# 文件权限\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003222654.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003222943.png]]\n\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F":{"title":"条件变量","content":"\n# 条件变量\n\n## 编程接口\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221022013734.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221022013742.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221102011938.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221102011949.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221102012001.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221102012023.png]]\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97":{"title":"消息队列","content":"# 消息队列\n\n消息队列（Message Queue）用于在[[3-计算机科学/2-计算机组成原理/进程|进程]]之间传递较小的数据，进程可以向一个或多个消息队列中放入数据（消息），其它进程可以从消息队列中按照各种方式（例如最典型的先进先出FIFO方式）取出消息，从而实现进程间通信。\n\n消息队列是一种[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/生产者消费者|生产者消费者]]模型，生产者生产消息放入队列，等待被消费者消费走。如果消息队列已满，生产者被阻塞，如果队列已空，消费者被阻塞。当然，按照不同设计方式，可能会以通知的方式替代阻塞行为。\n\n在分布式系统中，也常使用消息队列模型（如RabbitMQ、Kafka）在多个服务程序之间异步地传递消息。\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E7%AC%A6%E5%8F%B7%E8%A1%A8":{"title":"符号表","content":"# 符号表\n\n## 作用\n\n\u003e 一张“查询表。\n\n符号表包含了**一些通用的符号**，这部分信息在进行了 `strip` 操作后就会消失。这些符号信息可能包括变量名、函数名。\n符号表本质就是一个映射表，举个例子：某行二进制汇编代码映射到源码第几行。\n\n符号表的作用：\n\n1. 调试：汇编--查找--\u003e源码位置\n2. 重定位：函数名--查找--\u003e汇编位置\n\n### 调试\n\n- window工程有一个*.pdb文件,里面编包含调试符号.可参阅wiki window pdb格式。\n- 在java工程会使用一个叫混淆的技术，混淆后会生成混淆前后的映射文件mapping.txt,这个也可以理解为符号表的一种。\n- 在linux有一个dwarf的文件格式也是专门用于调试的文件。参阅wiki DWARF。\n\n\n### 重定位\n\n重定位可以大致分为两种类别`动态重定位`与`静态重定位`\n\n#### 动态重定位\n\n假设A程序需要`xxx.so`中的`yyyy`函数那么就需要从`xxx.so`中的符号表进行读取。\n\n#### 静态重定位\n\n[[3-计算机科学/3-操作系统/Linux/静态重定位|静态重定位]]\n\n## 基本结构\n\nELF文件中的符号表往往是文件中的一个段，段名一般叫\".symtab\"。符号表的结构很简单，它是一个符号表项数组数组，每个符号表项结构对应一个符号。这个数组的第一个元素，也就是下标0的元素为无效的\"未定义\"符号。\n\nElf32_Sym的结构定义如下：\n\n```cpp\ntypedef struct {  \n\tElf32_Word st_name;  \n\tElf32_Addr st_value;  \n\tElf32_Word st_size;  \n\tunsigned char st_info;  \n\tunsigned char st_other;  \n\tElf32_Half st_shndx;  \n} Elf32_Sym;\n```\n\n| 名称       | 描述                                                                      |\n|----------|-------------------------------------------------------------------------|\n| st_name  | 符号名。这个成员包含了该符号名在字符串表中的下标（还记得字符串表吧？）                                     |\n| st_value | 符号相对应的值。这个值跟符号有关，可能是一个绝对值，也可能是一个地址等，不同的符号，它所对应的值含义不同，见下文“符号值”。          |\n| st_size  | 符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个double型的符号它占用8个字节。如果该值为0，则表示该符号大小为0或未知。 |\n| st_info  | 符号类型和绑定信息，见下文“符号类型与绑定信息”                                                |\n| st_other | 该成员目前为0，没用                                                              |\n| st_shndx | 符号所在的段，见下文“符号所在段”                                                       |\n\n\nElf64_Symbol定义如下：\n\n```cpp\ntypedef struct { \n    int   name;      /* String table offset */ \n    char  type:4,    /* Function or data (4 bits) */ \n    binding:4;       /* Local or global (4 bits) */ \n    char  reserved;  /* Unused */  \n    short section;   /* Section header index */\n    long  value;     /* Section offset or absolute address */ \n    long  size;      /* Object size in bytes */ \n} Elf64_Symbol; \n```\n\n注意：  \n有三类伪节是没有节头表条目的\n- `ABS` \n    不需要重定位的符号，比如源代码的路径名；\n- `COMMON` \n    未初始化的全局变量；  \n    `.bss`保存的是未初始化的静态变量，及初始化为0的全局变量和静态变量；\n- `UND` \n    在目标文件`m`中引用，但定义在别的文件中的符号；\n\n其中，符号表中下标 0 存储了符号表的一个元素，同时这个元素也相对比较特殊，作为所有未定义符号的索引，具体如下：\n| 名称       | 取值 | 说明       |\n|----------|----|----------|\n| st_name  | 0  | 无名称      |\n| st_value | 0  | 0 值      |\n| st_size  | 0  | 无大小      |\n| st_info  | 0  | 无类型，局部绑定 |\n| st_other | 0  | 无附加信息    |\n| st_shndx | 0  | 无节区      |\n\n\n## st_info[¶](https://ctf-wiki.org/executable/elf/structure/symbol-table/#st_info \"Permanent link\")\n\nst_info 中包含符号类型和绑定信息，这里给出了控制它的值的方式具体信息如下\n\n`#define ELF32_ST_TYPE(i)    ((i)\u00260xf) #define ELF32_ST_INFO(b, t) (((b)\u003c\u003c4) + ((t)\u00260xf))`。\n\n## 符号类型和绑定信息（st_info）\n\n该成员低4位表示符号的类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）\n\n符号绑定信息：\n| 宏定义名       | 值 | 说明                |\n|------------|---|-------------------|\n| STB_LOCAL  | 0 | 局部符号，对于目标文件的外部不可见 |\n| STB_GLOBAL | 1 | 全局符号，外部可见         |\n| STB_WEAK   | 2 | 弱引用，详见“弱符号与强符号”   |\n\nst_info 的低 4 位表示符号类型：\n| 宏定义名        | 值 | 说明                 |\n|-------------|---|--------------------|\n| STT_NOTYPE  | 0 | 未知类型符号             |\n| STT_OBJECT  | 1 | 该符号是个数据对象，比如变量、数组等 |\n| STT_FUNC    | 2 | 该符号是个函数或其他可执行代码    |\n| STT_SECTION | 3 | 该符号表示一个段，这种符号必须是   |\n|             |   | STB_LOCAL的         |\n| STT_FILE    | 4 | 该符号表示文件名，一般都是该目标文  |\n|             |   | 件所对应的源文件名，它一定是     |\n|             |   | STB_LOCAL类型的，并且它的  |\n|             |   | st_shndx一定是SHN_ABS |\n\n### 符号所在段（st_shndx）\n\n如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊：\n特殊常量：\n| 宏定义名       | 值      | 说明                                                                                                                   |\n|------------|--------|----------------------------------------------------------------------------------------------------------------------|\n| SHN_ABS    | 0xfff1 | 表示该符号包含了一个绝对的值。比如表示文件名的符号就属于这种类型的                                                                                    |\n| SHN_COMMON | 0xfff2 | 表示该符号是一个“COMMON块”类型的符号，一般来说，未初始化的全局符号定义就是这种类型的，比如SimpleSection.o里面的global_uninit_var。 |\n| SHN_UNDEF  | 0      | 表示该符号未定义。这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中。                                                                           |\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90":{"title":"符号解析","content":"# 符号解析\n\n## 作用\n\n确定符号引用关系，将每个模块中引用的符号与某个目标模块的定义符号建立关联。\n\n在我们通常的观念里,之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件,所以要将它们链接起来。比如我们直接使用ld来链接“a.o”,而不将“b.o”作为输入。链接器就会发现 shared和swap两个符号没有被定义,没有办法完成链接工作：\n![[z-oblib/z2-attachments/Pasted image 20220911163933.png]]\n这也是我们平时在编写程序的时候最常碰到的问题之一,就是链接时符号未定义。导致这个问题的原因很多,最常见的一般都是链接时缺少了某个库,或者输入目标文件路径不正确或符号的声明与定义不一样。所以从普通程序员的角度看,符号的解析占据了链接过程的主要内容。\n重定位过程也伴随着符号的解析过程,每个目标文件都可能定义一些符号也可能引用到定义在其他目标文件的符号。重定位的过程中,每个重定位的入口都是对一个符号的引用,那么当链接器须要对某个符号的引用进行重定位时,它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表,找到相应的符号后进行重定位。比如我们查看“a.o”的符号表：\n![[z-oblib/z2-attachments/Pasted image 20220911164046.png]]\nGLOBAL”类型的符号,除了“main”函数是定义在代码段之外,其他两个“ shared和“swap”都是“UND”,即“undefined”未定义类型,这种未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后,所有这些未定义的符号都应该能够在全局符号表中找到,否则链接器就报符号未定义错误。\n\n## 流程\n\n\u003e [《程序员的自我修养》番外笔记——符号解析与重定位 - SegmentFault 思否](https://segmentfault.com/a/1190000021551701)\n\n重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找**由所有输入目标文件**的[[3-计算机科学/3-操作系统/Linux/符号表|符号表]]组成的**全局符号表**，找到相应的符号后进行重定位。\n\n![[z-oblib/z2-attachments/Pasted image 20220911033037.png]]\n![[z-oblib/z2-attachments/Pasted image 20220911033032.png]]\n\n通过命令查看“a.o”的符号表：\n![[z-oblib/z2-attachments/Pasted image 20220911033013.png]]\n\n可以看到shared和swap的类型都是“UND”，即“undefined”未定义类型，在链接器扫描完所有的输入目标文件后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报**符号未定义**错误。这种一般都是链接时**缺少了某些库**，或者输入目标文件**路径不正确**或符号的**声明与定义不一样**。\n\n## 指令修改方式\n\n- 不同的处理器指令对于地址的格式和方式都不一样。\n- 对于32位x86平台下的[[3-计算机科学/3-操作系统/Linux/ELF|ELF]]文件的重定位入口所修正的指令寻址方式只有两种：\n    - 绝对近址32位寻址。\n    - 相对近址32位寻址。\n- 这两种重定位方式指令修正方式每个被修正的位置的长度都是32位。\n\n这两种方式的定义：\n\n![[z-oblib/z2-attachments/Pasted image 20220911033329.png]]\n\n- 通过前面的[[3-计算机科学/3-操作系统/Linux/重定位表|重定位表]]可以看到swap符号的类型为R_386_PC32，这是一条相对位移调用指令。而shared符号的类型为R_386_32，它修正的是一条传输指令的源，即shared的绝对地址。\n- 假设在将a.o和b.o链接成最终可执行文件后，main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000，shared变量的虚拟地址为0x3000。\n- 首先看偏移为0x18的这条mov指令的修正，它是绝对寻址修正，它修正后的结果是S+A。\n    - S是符号shared的实际地址，即0x3000。\n    - A是被修正位置的**原始值**（默认填充值），即0x00000000。\n- 所以它的修正后的地址为：0x3000+0x00000000=0x3000。\n\t![[z-oblib/z2-attachments/Pasted image 20220911033447.png]]\n- 再来看偏移为0x26的这条call指令的修正，它是相对寻址修正，它修正后的结果是S+A-P。\n    - S是符号swap的实际地址，即0x2000。\n    - A是被修正位置的值，即0xFFFFFFFC(-4)。\n    - P为被修正的位置，当链接成可执行文件时，**这个值应该是被修正位置的虚拟地址**，即0x1000+0x27。\n- 所以它的修正后的地址为0x2000+(-4)-(0x1000+0x27)=0xFD5。\n\t![[z-oblib/z2-attachments/Pasted image 20220911033509.png]]\n- 这条相对位移调用指令的调用地址是该指令下一条指令的起始地址加上偏移量，即：0x102b+0xfd5=0x2000，刚好是swap函数的地址。\n- 从这两个例子可以看出来，绝对寻址修正和相对寻址修正的区别：是否减被修正位置的地址：\n\t- **绝对**寻址修正后的地址为**该符号的实际地址**\n\t- **相对**寻址修正后的地址为**符号距离被修正位置的地址差**","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E7%AE%A1%E9%81%93":{"title":"管道","content":"\n# 管道\n\n管道是操作系统提供的一种最基本的进程间通信方式。每创建一个管道，就有两个文件描述符，一个是负责读管道的，一个是负责写管道的。所以，使用管道通信时，可以看作是**两个文件描述符加一段内核空间中的内存**，如图。\n\n![[z-oblib/z2-attachments/Pasted image 20220803110054.png]]\n\n管道只能协调有亲缘关系的进程间通信，所谓亲缘，比如**父子进程、兄弟进程**。当某进程创建一个管道后，它就拥有了这个管道的两个文件描述符，它的子进程会继承这两个文件描述符，所以子进程也能读写这个管道。如图。\n\n![[z-oblib/z2-attachments/Pasted image 20220803110138.png]]\n\n但为了让管道通信更安全、更方便，一般管道两端的每个进程都会各自关闭一个管道的文件描述符，例如父进程关闭读描述符，这样父进程只能向管道写数据，子进程关闭写描述符，这样子进程只能从管道读数据。或者相反。如图。\n\n![[z-oblib/z2-attachments/Pasted image 20220803110147.png]]\n\nShell也提供了管道，只需使用一根竖线连接两个命令即可。例如：\n\n```shell\nps -elf | grep \"sshd\"\n\ncat a.log | grep \"hello world\"\n```\n\n在shell下，这种管道称为**匿名管道**，即没有名称的管道。它对于编写命令行来说非常方便，且逻辑清晰易懂，shell脚本和shell命令行几乎靠它打下了半壁江山。\n\n在shell下，还支持使用mkfifo命令创建**命名管道**（named pipe），即有名称的管道，它也称为FIFO，它可以协调任意进程间的数据通信。\n\n例如，创建命名管道文件a.fifo，a.fifo就是这个命名管道的名称。虽然它以文件的方式存在于磁盘上，但它传递数据的方式**不会经过磁盘IO**，而是**直接在内存中传递**，所以速度非常快，文件名仅仅只是这个命名管道的名称而已，是**引用这个管道的入口和出口**。\n\n```shell\n$ mkfifo a.fifo\n$ ls -l a.fifo\nprw-r--r-- 1 root root 0 Apr 30 23:52 a.fifo  # 文件类型为p\n```\n\n命名管道是阻塞式的双向通信管道，任意一方都可以读、写，但是只有读、写端同时打开了命名管道时，数据才会写入并被读取。例如，下图中显示了在未打开读端命名管道的时候，所有写命名管道的操作都被阻塞。果cat a.fifo按下回车键打开读端命名管道，写和读操作都将正常执行。同理，只打开读端而未打开写端命名管道时，读操作也会被阻塞。\n\n![[z-oblib/z2-attachments/Pasted image 20220803110301.png]]\n\n## 编程接口\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005231142.png]]\n\n### 无名管道\n\n\u003e 该管道是单向的。\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005231241.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005231305.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005231452.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005231535.png]]\n\n### 有名管道\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005232835.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5":{"title":"运行时动态链接","content":"# 运行时动态链接\n\n## PLT与GOT关系\n\nPLTPLT表中的数据就是GOTGOT表中的一个地址，可以理解为一定是一一对应的：\nPLTPLT表中的每一项的数据内容都是对应的GOTGOT表中一项的地址这个是固定不变的。\n\n![[z-oblib/z2-attachments/Pasted image 20220908214812.png]]\n\n## 流程\n\n\u003e [(35条消息) PWN基础15：GOT表 和 PLT表_prettyX的博客-CSDN博客_查看got表](https://blog.csdn.net/prettyX/article/details/107404509?spm=1001.2101.3001.4242.2\u0026utm_relevant_index=4)\n\n1. 程序加载\n2. 触发重定向\n\t1. 修改GOT表[0]，向其填充PLT表首地址，用于触发查找\n\t2. 修改GOT表[2]，向其填充连接器查找函数地址，用于查找目标函数真实地址\n3. 首次调用目标动态连接函数，假设目标函数标号为n：\n4. PLT跳转到GOT[n]\n5. GOT[n]初始填充的是PLT[n]后一条地址，接着两条指令：\n\t1. push 编号n\n\t2. 跳转到PLT[0]\n6. PLT[0] 包含两条指令：\n\t1. push GOT[1] -- 填充的是[[3-计算机科学/3-操作系统/Linux/运行时动态链接#link_map|link_map]]的地址\n\t2. 跳转到GOT[2]内填充的地址空间  -- 链接器\n3. 此时一共push了2个参数，一个目标函数ID，一个link_map地址，正好是_dl_runtime_resolve的两个参数。\n4. \\_dl_runtime_resolve 找到动态链接函数真实地址，回填到GOT[n]。\n\t\u003e [_dl_runtime_resolve - 简书 (jianshu.com)](https://www.jianshu.com/p/57f6474fe4c6)\n\n## link_map\n\nGOT[1]：一个指向内部数据结构的指针，类型是 link_map，在动态装载器（[[3-计算机科学/3-操作系统/Linux/_dl_runtime_resolve|_dl_runtime_resolve()]]）内部使用，包含了进行[[3-计算机科学/3-操作系统/Linux/符号解析|符号解析]]需要的当前 ELF 对象的信息。\n\n## 2次调用对比\n\n![[z-oblib/z2-attachments/Pasted image 20220908214703.png]]\n\n![[z-oblib/z2-attachments/Pasted image 20220908214706.png]]","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E9%81%97%E8%A8%80%E5%87%BD%E6%95%B0":{"title":"遗言函数","content":"\n# 遗言函数\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005023226.png]]\n\n## 注册遗言函数\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005023259.png]]\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8":{"title":"重定位表","content":"# 重定位表\n\n\u003e 一张“需求表”：告诉链接器哪些指令即该指令的哪些部分要调整。\n\n重定位表（Relocation Table）用于在程序加载到内存中时，进行内存地址的修正。\n\n对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述**如何修改相应的段里的内容**。\n\n对于**每个要重定位的ELF段都有一个对应的重定位表**，而一个重定位表往往就是ELF文件中的一个段，所以其实重定位表也可以叫重定位段。\n\n## 结构\n\n比如代码段“text”如有要被重定位的地方,那么会有一个相对应叫“, rel.text”的段保存了代码段的重定位表;如果代码段“data”有要被重定位的地方,就会有一个相对应叫“ rel.data\"”的段保存了数据段的重定位表。我们可以使用 objdump来查看目标文件的重定位表。\n![[z-oblib/z2-attachments/Pasted image 20220911164434.png]]\n\n每个要被重定位的地方叫一个重定入口( Relocation Entry,我们可以看到“a.o\"里面有两个重定位入口。\n\n重定位入口的偏移(Oset)表示该入口在要被重定位的**段中的位置**,\n`RELOCATION RECORDS FOR .text`表示这个重定位表是代码段的重定位表，所以**偏移表示代码段中须要被调整的位置**。\n对照反汇编结果可以知道，这里的0xlc和0x27分别就是代码段中“mov”指令和“call”指令的地址部分。\n\n对于32位的 Intel x86系列处理器来说,重定位表的结构也很简单,它是一个El32 Rel 结构的数组,每个数组元素对应一个重定位入口。Ef32Rel的定义如下：\n\n```c\ntypedef uint32_t Elf32_Addr;\ntypedef uint32_t Elf32_Word;\n\ntypedef struct\n{\n  Elf32_Addr    r_offset;       /* Address */\n  Elf32_Word    r_info;         /* Relocation type and symbol index */\n} Elf32_Rel;\n\ntypedef uint64_t Elf64_Addr;\ntypedef uint64_t Elf64_Xword;\ntypedef int64_t  Elf64_Sxword;\n\ntypedef struct\n{\n  Elf64_Addr    r_offset;       /* Address */\n  Elf64_Xword   r_info;         /* Relocation type and symbol index */\n  Elf64_Sxword  r_addend;       /* Addend */\n} Elf64_Rela;\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220911164813.png]]\n\n32 位程序使用 REL，而 64 位程序使用 RELA。\n\n下面的宏描述了 r_info 是怎样被解析和插入的：\n\n```c\n/* How to extract and insert information held in the r_info field.  */\n\n#define ELF32_R_SYM(val)        ((val) \u003e\u003e 8)\n#define ELF32_R_TYPE(val)       ((val) \u0026 0xff)\n#define ELF32_R_INFO(sym, type)     (((sym) \u003c\u003c 8) + ((type) \u0026 0xff))\n\n#define ELF64_R_SYM(i)          ((i) \u003e\u003e 32)\n#define ELF64_R_TYPE(i)         ((i) \u0026 0xffffffff)\n#define ELF64_R_INFO(sym,type)      ((((Elf64_Xword) (sym)) \u003c\u003c 32) + (type))\n```\n\n举个例子：\n\n```c\nELF32_R_SYM(Elf32_Rel-\u003er_info) = (Elf32_Rel-\u003er_info) \u003e\u003e 8\n```\n\n每个符号使用 Elf_Sym 结构体来描述，存在于 `.dynsym` 段和 `.symtab` 段中，而 `.symtab` 在 strip 之后会被删掉：\n\n```c\ntypedef struct\n{\n  Elf32_Word    st_name;        /* Symbol name (string tbl index) */\n  Elf32_Addr    st_value;       /* Symbol value */\n  Elf32_Word    st_size;        /* Symbol size */\n  unsigned char st_info;        /* Symbol type and binding */\n  unsigned char st_other;       /* Symbol visibility */\n  Elf32_Section st_shndx;       /* Section index */\n} Elf32_Sym;\n\ntypedef struct\n{\n  Elf64_Word    st_name;        /* Symbol name (string tbl index) */\n  unsigned char st_info;        /* Symbol type and binding */\n  unsigned char st_other;       /* Symbol visibility */\n  Elf64_Section st_shndx;       /* Section index */\n  Elf64_Addr    st_value;       /* Symbol value */\n  Elf64_Xword   st_size;        /* Symbol size */\n} Elf64_Sym;\n```\n\n下面的宏描述了 `st_info` 是怎样被解析和插入的：\n\n```c\n/* How to extract and insert information held in the st_info field.  */\n\n#define ELF32_ST_BIND(val)      (((unsigned char) (val)) \u003e\u003e 4)\n#define ELF32_ST_TYPE(val)      ((val) \u0026 0xf)\n#define ELF32_ST_INFO(bind, type)   (((bind) \u003c\u003c 4) + ((type) \u0026 0xf))\n\n/* Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field.  */\n#define ELF64_ST_BIND(val)      ELF32_ST_BIND (val)\n#define ELF64_ST_TYPE(val)      ELF32_ST_TYPE (val)\n#define ELF64_ST_INFO(bind, type)   ELF32_ST_INFO ((bind), (type))\n```\n\n## 工作方式\n\n![[z-oblib/z2-attachments/Pasted image 20220911032644.png]]\n\n- \"main\"的起始地址为0x00000000，这是因为在未进行空间分配之前，目标文件代码段中的起始地址以0x00000000开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。\n- 偏移为0x18的地址上是一条mov指令，总共8个字节，它的作用是将“shared”的地址赋值到esp寄存器+4的偏移地址中去，前面4个字节“c7442404”是mov的指令码，后面4个字节是“shared”的地址。\n- 偏移为0x26的地址上是一条调用指令，它表示对swap函数的调用。这条指令共5个字节，前面的0xe8是操作码，这是一条**近址相对位移调用指令**，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。在没有重定位之前，相对偏移被置为0xFFFFFFFC（小端），它是常量“-4”的补码形式。\n\n通过命令可以查看目标文件的重定位表：\n![[z-oblib/z2-attachments/Pasted image 20220911032735.png]]\n\nOFFSET是重定位的入口偏移，表示**该入口在要被重定位的段中的位置**。“.text”表示这个重定位表示代码段的重定位表，所以偏移表示代码段中需要被调整的位置。这里的0x1c和0x27分别就是代码段中“mov”指令和“call”指令所在行的**地址部分**，即参数。\n\n","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E9%94%81":{"title":"锁","content":"# 锁\n\n计算机领域中，锁机制使用的非常多。它主要是为了避免多个进程访问同一资源时，可能出现的数据不一致问题。\n\n例如，cat命令输出一个比较大的文件内容，cat命令的特性是需要先将所有磁盘文件数据读取到内存后再输出，所以cat输出一个大文件可能需要花费一些时间。如果在cat在加载文件时，在另一个终端上向这个文件追加了一行数据，那么cat最终加载的数据会包含这行新追加的数据吗？\n\n再更简单的一个示例是，两个用户同时用vim打开一个文件去修改数据，那么以谁修改的数据为准呢？所以，vim为了避免这种问题，每次打开一个文件的时候，都会在文件的同一个目录下创建一个隐藏的.swp临时文件（例如vim a.log时会生成一个.a.log.swp的文件），如果有其它用户用vim去打开同一个文件，会检查这个隐藏文件是否存在，如果存在说明有人正在编辑这个文件。\n\n锁的内容非常多，这里简单介绍下它最基本也最实用的基础知识。\n\n如果不使用锁，也就是允许多个进程同时更新、读取同一份数据，将可能出现以下问题：\n\n1. 脏读：读取到脏数据。例如用户A用vim将文件中的字母x修改为了y，用户B在vim保存之前通过cat读取，得到的这个字母将是x，这种现象称为脏读。但其实A已经将它修改为了y，只不过该修改只存在于A的vim缓存中，还没有保存到磁盘文件中。通常，**将缓存中修改后但没有保存的数据称为脏数据**。\n2. 更新丢失：某用户的数据更新操作被其它用户覆盖。例如，用户A和用户B同时修改同一文件中的最后一个字符a，A将a修改为x，B将a修改为y，那么A先保存的话，B的修改将覆盖A的修改，最终保存的结果是y，如果B先保存的话，A的修改将覆盖B的修改，最终结果得到字符x。所以，同时修改数据时，有一个进程的更新被覆盖了，也就是丢失了。\n\n除这两个问题之外，在多进程同时更新、读取同一份数据时，还可能会出现其它现象，这里不再多做描述。下面介绍一下锁的机制。\n\n![[z-oblib/z2-attachments/Pasted image 20220803161908.png]]\n\n当需要读数据时，将申请读锁，当需要修改数据时，将申请写锁。\n\n申请锁的时候，需要先检查该资源上是否已经有锁，如果有锁，检查已存在的锁与待申请的锁是否可以兼容共存。\n\n1. 当多个进程都只是读取同一份资源（即都申请S锁），因为没有修改数据，所以可以**允许它们同时读取**，所以S锁与S锁是可以共存的。\n2. 如果有一个进程修改数据，它将申请X锁，这时显然不能让其它进程读取或写入数据，所以X锁与S锁、X锁和X锁都是互斥的。\n3. 如果一个进程正在读取数据（即已申请S锁），其它进程想修改数据，也是不允许的，所以S锁和X锁是互斥的。\n\n此外，使用锁需要考虑锁的粒度，即对多少资源量上锁。例如，对于一个文件来说，可以直接对整个文件上锁，也可以只对文件中想要访问的那部分数据上锁。如果直接对整个文件上锁，其它进程申请该文件的互斥锁将总是被阻塞，而如果只是锁定该文件中的前10K数据，那么其它进程如果申请的互斥锁从第20K开始的数据，就不会收到影响。\n\n所以，锁的粒度越大，阻止其它进程的可能性就越大，多进程并发的能力就越差。锁的粒度越小，阻止其它进程的可能性就越小，并发的能力就越强。\n\n但是，锁的粒度太小也不一定好，因为每个锁都是需要额外管理的，粒度越小，需要维护的锁数量越多。比如频繁创建锁和频繁释放锁的开销并不一定小，甚至在极端的时候比维护单个粗粒度的锁效率更低。\n\n在shell命令行下，提供了一个flock命令，它可以通过某个文件来实现锁机制：运行某个命令时在某个文件上申请锁（读锁或写锁），另外一个命令运行时也申请该文件上的锁（读锁或写锁），如果锁可以共存，则第二个命令可以执行，否则默认阻塞。\n\n下面是shell命令行下flock命令的简单用法，更详细内容可man flock自行探索。\n\n```shell\n# 以下代码在终端1上执行\n# 在/tmp/a.lock上申请共享锁（-s），申请成功就运行sleep 10命令\n# 因为此时/tmp/a.lock上还没有任何锁，所以申请成功\n$ flock -s /tmp/a.lock sleep 10\n\n# 以下代码在终端2上执行\n# 在/tmp/a.lock上申请互斥锁（-x），申请成功就运行cat /etc/passwd命令\n# 因为/tmp/a.lock上已经有共享锁，所以阻塞，直到10s后共享锁释放\n$ flock -x /tmp/a.lock cat /etc/passwd\n```","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D":{"title":"静态重定位","content":"# 静态重定位\n\n```cpp\n//mainA.c\n\nint globalvar=0x123;\nfun test(){\n}\n\n//mainB.c\nextern test();\nextern int globalvar;\nfun testFunB(){\n\ttest();\n\tprintf(\"I am  %d\\r\\n\",globalvar)\n}\n```\n\n我们程序有两个源代码，我们知道我编译的时候我们首先先将程序编译成目标文件。\n也就是mainB.o mainA.o，在目标文件中mainB.o不知道test函数和globalvar变量的地址，因此我们需要在链接时修正mainB.o函数调用地址。\n\n在编译成目标文件时，编译器会把文件中所有的函数与变量地址放入一个[[3-计算机科学/3-操作系统/Linux/符号表|符号表]]中。\n在链接时把所有目标文件的符号表合成一个，然后利用[[3-计算机科学/3-操作系统/Linux/重定位表|重定位表]]和符号表完成函数调用地址修正。\n\n我们看链接前示意图：\n![[z-oblib/z2-attachments/Pasted image 20220911031654.png]]\n链接后：\n![[z-oblib/z2-attachments/Pasted image 20220911031703.png]]","lastmodified":"2023-01-23T15:37:51.734680372Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/ELF":{"title":"ELF","content":"# ELF\n\n## 文件格式\n\n目标文件既会参与程序链接又会参与程序执行。出于方便性和效率考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下：\n![[z-oblib/z2-attachments/Pasted image 20220912001910.png]]\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/GDT":{"title":"GDT","content":"\n# GDT\n\nGDT段描述符类似一个可以理解为一个List，这个List保存的是Long值（64位），可假设为`List\u003cLong\u003e list = new ArrayList\u003cLong\u003e();`\n\n这个List刚开始的时候由操作系统创建，放在内存的某个位置，位置地址会保存到GDTR寄存器中，结构如下：\n\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923205651.png]]\n![[3-计算机科学/2-计算机组成原理/z-attachments/Pasted image 20220923205738.png]]\n这里段基地址和段属性拆分是为了兼容16位程序，一开始只有右半段，后来加了左边的。\n\n## 参考\n\n[「Coding Master」第28话 从实模式到保护模式的切换代码_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1a54y1G7Re/?spm_id_from=333.337.search-card.all.click\u0026vd_source=dc239faaaafac9ea3e7880710bece137)\n[GDT、GDTR和段寄存器的关系 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/512150749)\n","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/GOT%E8%A1%A8":{"title":"GOT表","content":"# GOT表\n\n\u003e [深入理解GOT表和PLT表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/130271689)\n\nGOT(Global Offset Table)全局偏移表，链接器为外部符号填充的实际偏移地址表。\n\n位于数据段，内容可修改。\n\n## 结构\n\n- GOT[1]：一个指向内部数据结构的指针，类型是 link_map，在动态装载器内部使用，包含了进行[[3-计算机科学/3-操作系统/Linux/符号解析|符号解析]]需要的当前 ELF 对象的信息。在它的 `l_info` 域中保存了 `.dynamic` 段中大多数条目的指针构成的一个数组，我们后面会利用它。\n- GOT[2]：一个指向动态装载器中 [[3-计算机科学/3-操作系统/Linux/_dl_runtime_resolve|_dl_runtime_resolve]] 函数的指针。","lastmodified":"2023-01-23T15:37:51.550678708Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6":{"title":"Linux关闭文件","content":"\n# Linux关闭文件\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003231213.png]]\n\n通过引用计数来确定有几个[[3-计算机科学/3-操作系统/Linux/文件描述符|文件描述符]]表引用了该文件描述，如果本次关闭后对应文件的底层文件描述引用计数位0，则内核释放该文件资源。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B":{"title":"Linux创建进程","content":"\n# Linux创建进程\n\n## fork\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005015332.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005015435.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005020045.png]]\n\n2.4内核下fork时会拷贝进程映像，及代码段、数据段、栈段、堆等。\n2.6内核会采用写时复制技术，不全量复制PCB，节省内存空间。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE":{"title":"Linux文件元数据","content":"\n# Linux文件元数据\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004222858.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004225821.png]]\n\n数据块表是一个长度为15的整型数组，每个单元存放一个数据块编号。其中前11个直接存放数据块，后4个是块链的形式，其中每个块（4K情况）可以存放1024个整数代表其它块的编号。\n\n1K * 1K * 4K = 4G\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E5%A4%B9":{"title":"Linux文件夹","content":"\n# Linux文件夹\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005003720.png]]\n\n## 代码操作\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005003841.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005004007.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005004012.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84":{"title":"Linux文件映射","content":"\n# Linux文件映射\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004003539.png]]\n\n## mmap\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004003800.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004005826.png]]\n返回的是虚拟地址。\n\n## munmap\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004011854.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90":{"title":"Linux文件权限","content":"\n# Linux文件权限\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004232406.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B":{"title":"Linux文件类型","content":"\n# Linux文件类型\n\n## 类型检测\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001659.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001956.png]]\n\n左侧0代表8进制，右侧4个0代表文件权限，\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005003454.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E9%94%81":{"title":"Linux文件锁","content":"\n# Linux文件锁\n\n多进程异步访问文件需要使用文件锁实现同步。\n\n## 过程\n\n进程打开文件时，内核会产生一个对应的struct file变量，硬链接到对应inode。\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005004428.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005004553.png]]\n\n## fcntl使用\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005004626.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005005033.png]]\n\n\t\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%9A%82%E5%81%9C%E8%BF%9B%E7%A8%8B":{"title":"Linux暂停进程","content":"\n# Linux暂停进程\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221006005459.png]]\n\n任意信号到达后（信号不能被忽略）都会打断休眠。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%9B%B4%E6%96%B0%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F":{"title":"Linux更新进程映像","content":"\n# Linux更新进程映像\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005181438.png]]\n\n## execve系统调用\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005181921.png]]\n\n## 库函数\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005183604.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005194047.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005195339.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF":{"title":"Linux查看进程信息","content":"\n# Linux查看进程信息\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005012151.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F":{"title":"Linux环境变量","content":"\n# Linux环境变量\n\n每个进程都有一个属于自己的环境变量列表。进程使用这些变量的值去使用系统提供的资源。本节主要介绍使用库函数操作进程的环境变量。\n\n```\nchar *getenv(const char *name);\n\n功能：获取环境变量name的值\n\n参数：name 指定环境变量的名字。\n\n返回值：成功   返回环境变量name的值的首地址    \n\t\t返回NULL    代表没有找到这个环境变量\n\t\t\nint putenv(char *string);\n\n     功能：将字符串设置为进程的环境变量\n\n     参数：string 以格式name=value的字符串，将这个字符串设置到进程的环境变量列表中。  如果进程中有和name同名的环境变量，则使用value的值替换掉原来的值。如果没有  同名的环境变量，则将字符串设置为进程的环境变量\n\n     返回值：成功   返回 0    \n\n        错误   返回非0    errno被设置为相应的错误值\n\n切记：只是将字符串设置到进程环境变量列表中，而不是拷贝。如果string指向的字符串的内容改变，则值做相应的改变\n\n      int setenv(const char *name, const char *value, int overwrite);\n\n     功能：如果环境变量存在，根据overrite的值对环境变量操作。如果不存在，创建环境变量\n\n     参数：name  环境变量的名字\n\n     value  环境变量的值\n\n     overwrite  0  如果环境变量已经在列表中，不改变环境变量的值\n\n          非0  如果环境变量已经在列表中，使用value的值替换掉原来的值\n\n     返回值：成功   返回 0    \n\n        错误   -1   errno被设置为相应的错误值\n\n    int unsetenv(const char *name);\n\n     功能：从环境变量列表中删除环境变量，如果环境变量不存在，什么都不做\n\n     参数：name  环境变量的名字\n\n     返回值：成功   返回 0    \n\n        错误   -1   errno被设置为相应的错误值\n\n     int clearenv(void);\n\n    功能：清除进程的环境变量列表并将全局变量environ设置为NULL。\n\n     返回值：成功    0      错误   非0\n```\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84":{"title":"Linux用户和用户组","content":"\n# Linux用户和用户组\n\n## 用户\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005000840.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001013.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001044.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001117.png]]\n\n## 用户组\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001417.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005001508.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E6%95%B0":{"title":"Linux硬连接数","content":"\n# Linux硬连接数\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004232553.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%BA%BF%E7%A8%8B":{"title":"Linux线程","content":"\n# Linux线程\n\n## 编程接口\n\t\n### 创建线程\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012013033.png]]\n\n### 获取自身tid\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012013146.png]]\n\n### 终止线程\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012013612.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012014007.png]]\n\n### 线程分离与汇合\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012014015.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012014124.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012014146.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5":{"title":"Linux线程同步","content":"\n# Linux线程同步\n\n- mutex锁\n- 条件变量\n- 信号量\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B":{"title":"Linux终止进程","content":"\n# Linux终止进程\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005020247.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91":{"title":"Linux输入输出重定向","content":"\n# Linux输入输出重定向\n\n重定向本质就是[[3-计算机科学/3-操作系统/Linux/文件描述符|文件描述符]]的复制。\n\n## 文件描述符复制\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004000920.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004000951.png]]\n\n## 举例\n\n某个bash进程的文件描述符表：\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004001748.png]]\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004002145.png]]\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004002250.png]]\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81":{"title":"Linux进程状态","content":"\n# Linux进程状态\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005012919.png]]\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005013249.png]]\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6":{"title":"Linux进程资源回收","content":"\n# Linux进程资源回收\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005162512.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005163152.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005164405.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005164513.png]]\n\n\nwait等待的是子进程结束后发送的SIGCHLD信号。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF":{"title":"Linux进程间通讯","content":"\n# Linux进程间通讯\n\n想要进行进程间通讯，需要借助内核空间。\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005230322.png]]\n\n单机操作系统上的[[3-计算机科学/2-计算机组成原理/进程|进程]]可以分为两类：\n\n1. 独立进程：这类进程不会和其它进程有任何交[[3-计算机科学/2-计算机组成原理/流|流]]。\n2. 协作进程：两个或多个进程之间需要交流。\n\n例如，`ls /tmp`命令是独立运行的，不依赖于其它进程，而`cat a.log | grep 'abc'`命令中的两个进程是协作进程，grep进程依赖于cat进程，grep只有等待到了cat进程产生的数据才能继续执行下去。\n\n对于单机上不同进程之间的协作，各进程之间需要进行数据的交流，这种行为称为进程间通信（Inter-process communication，IPC），即进程与进程的通信。\n\n除了单机上的多个进程可能需要进程间通信，多计算机之间的进程有时候也需要进行进程间的通信，这很常见，例如本机上的QQ客户端进程需要和腾讯的QQ服务器上的进程进行数据传输，浏览器浏览网页时，浏览器进程需要和网页所在的服务端进程进行数据传输，等等。\n\n进程间通信的方式有很多种。从广义上讲，只要进程间能共享数据或传递数据就算是进程间通信。下面列出常见的进程间通信方式：\n\n| 进程间通信方式                                            | 描述                                                 |\n|----------------------------------------------------|----------------------------------------------------|\n| 文件（File）                                           | 多个进程可以获取到同一个文件的数据                                  |\n| [[3-计算机科学/3-操作系统/Linux/管道 \\| 管道]]（pipe）                                           | 单方向传输数据的管道，只能一方写，另一方读                              |\n| [[3-计算机科学/3-操作系统/Linux/套接字\\|套接字]]（Socket）                                        | 多机进程间通信，当然也可以在本机让两个进程使用socket通信                    |\n| [[3-计算机科学/3-操作系统/Linux/Unix域套接字\\|Unix域套接字]]（Unix Domain Socket）                       | 单机进程间通过域套接字模式通信，可看作是双向管道                           |\n| [[3-计算机科学/3-操作系统/Linux/共享内存\\|共享内存]]（Shared Memory，shm）                            | 在物理内存上划分一片内存，多个进程共享这片内存                            |\n| [[3-计算机科学/3-操作系统/Linux/文件映射\\|文件映射]]（Memory-maped file）                            | 将文件中的一段数据映射到物理内存，多个进程共享这片内存                        |\n| [[3-计算机科学/3-操作系统/Linux/消息队列\\|消息队列]]（Message Queue）                                | 某进程将消息放入消息队列，其它进程从队列中接收消息                          |\n| [[3-计算机科学/3-操作系统/Linux/信号\\|信号]]（Signal）                                         | 通过发送某些信号通知其它进程，进程收到信号做出不同的处理                       |\n| [[3-计算机科学/3-操作系统/Linux/信号量\\|信号量]]（Semaphore）                                     | 就是信号灯。应用方式有多种，其作用概括起来就是，根据是否有信号灯或信号灯的数量多少来决定是否阻塞进程 |\n| [[3-计算机科学/3-操作系统/Linux/锁\\|锁]]（Lock）                                            | 对资源上锁，如果资源已被某进程锁住，则其它进程想要修改甚至读取这些资源，都将被阻塞，直到锁被打开。  |\n| [[3-计算机科学/3-操作系统/Linux/system_v_ipc\\|system_v_ipc]]                                            |   |\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6":{"title":"Linux链接文件","content":"\n# Linux链接文件\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221004232735.png]]\n\nfileC是fileB的软链接，fileA和fileB是硬链接。\n\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux_TCP%E7%BC%96%E7%A8%8B":{"title":"Linux_TCP编程","content":"\n# Linux_TCP编程\n\n## 编程模型\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006193131.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006193853.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006193901.png]]\n\n## 主要接口\n\n### socket\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006193943.png]]\n\n### bind\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006194037.png]]\n\n### listen\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006194147.png]]\n\n客户端连接到来后会把连接放入未决连接队列中。\n\n### accept\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006194258.png]]\n\n### connect\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006195543.png]]\n\n### 通用地址家族\n\n```c\nstruct sockaddr{\n  sa_family_t sa_family;\n  char sa_data[14];\n};\n```\n\n### ipv4地址家族\n\n```c\n     struct sockaddr_in {\n\n       sa_family_t  sin_family; /* address family: AF_INET */\n\n       in_port_t    sin_port; /* port in network byte order */\n\n       struct in_addr sin_addr;   /* internet address */\n\n};\n\n/* Internet address. */\n\nstruct in_addr {\n\n     uint32_t   s_addr;     /* address in network byte order */\n\n};\n```\n\n### ipv6地址家族\n\n```c\n    struct sockaddr_in6 {\n\n       sa_family_t     sin6_family;   /* AF_INET6 */\n\n       in_port_t       sin6_port;     /* port number */\n\n       uint32_t    sin6_flowinfo; /* IPv6 flow information */\n\n       struct in6_addr sin6_addr;     /* IPv6 address */\n\n       uint32_t    sin6_scope_id; /* Scope ID (new in 2.4) */\n\n};\n\nstruct in6_addr {\n\n       unsigned char   s6_addr[16];   /* IPv6 address */\n\n};\n```\n\n### 字节序转换\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006195021.png]]\n\n### 地址转换\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006195141.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006214207.png]]\n\n## 案例\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006195719.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221006195805.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux_UDP%E7%BC%96%E7%A8%8B":{"title":"Linux_UDP编程","content":"\n# Linux_UDP编程\n\n## 编程模型\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012002622.png]]\n\n### 服务端\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012002909.png]]\n\n### 客户端\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012004639.png]]\n\n## 编程接口\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012004717.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012004748.png]]\n\n## 案例\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221012005303.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/PCB":{"title":"PCB","content":"\n# PCB\n\nProcess Control Block，进程控制块，记录了进程使用到的计算机资源的情况。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/PLT%E8%A1%A8":{"title":"PLT表","content":"# PLT表\n\n\u003e [深入理解GOT表和PLT表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/130271689)\n\nPLT（Procedure Linkage Table）过程链接表，位于代码段，内容不可修改。\nPLT表通过引用GOT表中的函数的绝对地址，来把控制转移到实际的函数。\n在实际的可执行程序或者共享目标文件中，PLT表在名称为.plt的section中。\n\n## 结构\n\nPLT[0]：保存一段操作，操作内容：push目标函数编号，跳转到GOT[2]\n\n## 来源\n\n\u003e [GOT表和PLT表知识详解_77458的博客-CSDN博客_got表](https://blog.csdn.net/qq_18661257/article/details/54694748)\n\n这个函数是编译系统自己加的，大家可以通过`disas gets`看看里面的代码，如下图：\n\n![[z-oblib/z2-attachments/Pasted image 20220907230615.png]]\n\n这个函数只有三行代码，第一行跳转，第二行压栈，第三行又是跳转，解释：\n第一行跳转，它的作用是通过PLT表跳转到GOT表，而在第一次运行某一个函数之前，这个函数PLTPLT表对应的GOT表中的数据为@plt@plt函数中第二行指令的地址，针对图中来说步骤如下：\n\n1. jmp 指令跳转到 GOT 表\n2. GOT 表中的数据为0x400486\n3. 跳转到指令地址为0x400486\n4. 执行push 0x3 (这个为在GOTGOT中的下标序号)\n5. 再执行jmp 0x400440\n6. 而0x400440为PLT[0]的地址\n7. PLT[0]的指令会进入动态链接器的入口\n8. 执行一个函数将真正的函数地址覆盖到[[3-计算机科学/3-操作系统/Linux/GOT表|GOT表]]中\n\n## 问题\n\n### PLT[0]处到底做了什么，按照我们之前的思路它不是应该跳转到GOT[0]吗？\n\n![[z-oblib/z2-attachments/Pasted image 20220907230947.png]]\n\n\n我们尝试着查看0x400440地址的数据内容发现一个问题，从0x400440−0x400450之间的数据完全不知道是什么，而真正的PLT[x]中的数据是从0x400450开始的，从这里才有了@plt为后缀的地址，但是我们disas gets看代码的时候是从0x400440开始的，我们可以通过x /5i 0x400440查看0x400440处的代码：\n\n![[z-oblib/z2-attachments/Pasted image 20220907231232.png]]\n\n后面的#之后又一个1616进制数，一看便可以知道是GOT表的地址，为什么这么肯定呢，因为我们可以通过`objdump -R ./a.out`查看一个程序的GOT函数的地址，如下图：\n\n![[z-oblib/z2-attachments/Pasted image 20220907231301.png]]\n\n这里都是些GOTGOT地址，我们发现都是0x601...0x601...这些，所以可以断定图77中的也是GOTGOT地址，那么我们可以猜想出，在正式存储一个函数的GOT地址前，我们的PLTPLT表前面有一项进行一些处理，我们暂且不具体深入剖析这些代码有什么用，但是我们可以肯定puts@pltputs@plt前面那1616个字节也算是PLTPLT表中的内容，这其实就是我们的PLT[0]，正如我们之前问题提到的那样，我们的PLT[0]根本没有跳转到GOT[0]，它不像我们的PLT[1]这些存储的是GOT表项的地址，它是一些代码指令，换句话说，PLT[0]是一个函数，这个函数的作用是通过GOT[1]和GOT[2]来正确绑定一个函数的正式地址到GOT表中来。\n\n本来按照最开始的思路PLT[1]也是跳转到GOT[1]的，GOT[2]同理，但是这两个数据好像被PLT[0]利用了，同时GOT[0]好像消失了，这里GOT[0]暂且不说它的作用是什么，针对GOT[1]和GOT[2]被PLT[0]利用，所以我们程序中真实情况其实是从PLT[1]到GOT[3],PLT[2]到GOT[4]，所以我们推翻了之前的图，建立一张新的处理表：\n\n![[z-oblib/z2-attachments/Pasted image 20220907231548.png]]\n\n而plt[0]代码做的事情则是：由于GOT[2]中存储的是动态链接器的入口地址，所以通过GOT[1]中的数据作为GOT[2]参数，跳转到GOT[2]所对应的函数入口地址，这个动态链接器会将一个函数的真正地址绑定到相应的GOT[x]中。\n\n这就是PLT表和GOT表，总而言之，我们调用一个函数的时候有两种方法，一个是通过PLT表调用，一个则是通过GOT表调用，因为PLT表最终也是跳转GOT表，GOT表中则是一个函数真正的地址，这里需要注意的是，在一个函数没有运行一次之前，GOT表中的数据为@plt函数中下一条指令的地址，图55有说。\n\n### 为什么中间要进行push压栈操作？\n\n中间进行的压栈是为了确定PLT对应的GOT表项，即是PLT[1]−\u003eGOT[3]，0x3就是GOT的下标3，也就是说压栈后我们跳转到PLT[0],接着PLT[0]中的指令会通过这次压栈的序号来确定操作的GOT表项为多少。\n\n### 压入的序号为什么为0x3，不是最开始应该为0x0吗？\n\n这里压入0x3的原因是因为，我们的GOT[0],GOT[1],GOT[2]都有额外用处。要从GOT[3]开始。","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97":{"title":"Unix域套接字","content":"# Unix域套接字\n\nUnix域套接字是[[3-计算机科学/3-操作系统/Linux/套接字|套接字]]的一种，**用于本机进程间通信**，一般用来实现**双向**通信的管道。Unix域套接字是比网络套接字**轻量级且高效**的多，因为它不涉及网络通信，不需要监听连接，不需要绑定地址，不需要关心协议类型，等等。\n\n创建Unix域套接字后返回两个[[3-计算机科学/3-操作系统/Linux/文件描述符|文件描述符]]，这两个文件描述符均对套接字可读、可写，从而实现全双工的双向通信。\n\n同样的，为了避免使用单个文件描述符同时读、写造成的数据错乱，Unix域套接字也有两个buffer空间。\n\n\u003e 创建了两个方向不同的半双工缓冲区，拼在一起组成所谓全双工。单一buffer不会涉及同时的写入操作。\n\n![[z-oblib/z2-attachments/Pasted image 20220803133056.png]]","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/VFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F":{"title":"VFS文件系统","content":"\n# VFS文件系统\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221005010403.png]]\n\ntask_stuct就是进程的PCB。\nf_entry是文件的路径，一般会先指向一个缓冲，图中便于理解直接指向了dentry（directory entry）。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/_dl_runtime_resolve":{"title":"_dl_runtime_resolve","content":"# _dl_runtime_resolve\n\n1. 首先用`link_map`访问`.dynamic`，分别取出`.dynstr`、`.dynsym`、`.rel.plt`的地址\n2. `.rel.plt`+参数`relic_index`，求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel`\n3. `rel-\u003er_info` \u003e\u003e `8` 作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym`\n4. `.dynstr` + `sym-\u003est_name`得出符号名 字符串指针\n5. 在动态链接库查找这个函数的地址，并且把地址赋值给`*rel-\u003er_offset`，即`GOT`表\n6. 最后调用这个函数\n\n![[z-oblib/z2-attachments/Pasted image 20220911014856.png]]\n\n## 方法过程\n\n[6.1.3 pwn XDCTF2015 pwn200 · CTF All In One (gitbooks.io)](https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/6.1.3_pwn_xdctf2015_pwn200.html)\n\n```asm\ngdb-peda$ disassemble 0xf7fec370\nDump of assembler code for function _dl_runtime_resolve:\n   0xf7fec370 \u003c+0\u003e:     push   eax\n   0xf7fec371 \u003c+1\u003e:     push   ecx\n   0xf7fec372 \u003c+2\u003e:     push   edx\n   0xf7fec373 \u003c+3\u003e:     mov    edx,DWORD PTR [esp+0x10]\n   0xf7fec377 \u003c+7\u003e:     mov    eax,DWORD PTR [esp+0xc]\n   0xf7fec37b \u003c+11\u003e:    call   0xf7fe6080 \u003c_dl_fixup\u003e\n   0xf7fec380 \u003c+16\u003e:    pop    edx\n   0xf7fec381 \u003c+17\u003e:    mov    ecx,DWORD PTR [esp]\n   0xf7fec384 \u003c+20\u003e:    mov    DWORD PTR [esp],eax\n   0xf7fec387 \u003c+23\u003e:    mov    eax,DWORD PTR [esp+0x4]\n   0xf7fec38b \u003c+27\u003e:    ret    0xc\nEnd of assembler dump.\n```\n\n该函数在 `glibc/sysdeps/i386/dl-trampoline.S` 中用汇编实现，先保存寄存器，然后将两个值分别传入寄存器，调用 `_dl_fixup`，最后恢复寄存器。\n这里传递的参数就是动态链接时压入的两个参数：\n\n```asm\ngdb-peda$ x/w $esp+0x10\n0xffffd598:     0x00000020\ngdb-peda$ x/w $esp+0xc\n0xffffd594:     0xf7ffd900\n```\n\n一个是在 `\u003cwrite@plt+6\u003e: push 0x20` 中压入的偏移量，一个是 PLT[0] 中 `push DWORD PTR ds:0x804a004` 压入的 GOT[1]。\n\n函数 `_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)`，其参数分别由寄存器 `eax` 和 `edx` 提供。\n即使我们使用单步进入，也不能调试 `_dl_fixup`，它直接就执行完成并跳转到 write 函数了，而此时，GOT 的地址已经被覆盖为实际地址：\n\n```\ngdb-peda$ x/w 0x804a01c\n0x804a01c:      0xf7ea3100\n```\n\n再强调一遍：fixup 是通过寄存器取参数的，这似乎违背了 32 位程序的调用约定，但它就是这样，上面 gdb 中显示的参数是错误的，该函数对程序员来说是透明的，所以会尽量少用栈去做操作。\n\n既然不能调试，直接看代码吧，在 `glibc/elf/dl-runtime.c` 中：\n\n```c\nDL_FIXUP_VALUE_TYPE\nattribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE\n_dl_fixup (\n# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\n       ELF_MACHINE_RUNTIME_FIXUP_ARGS,\n# endif\n       struct link_map *l, ElfW(Word) reloc_arg)\n{\n  // 分别获取动态链接符号表和动态链接字符串表的基址\n  const ElfW(Sym) *const symtab\n    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);\n  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);\n\n  // 通过参数 reloc_arg 计算重定位入口，这里的 DT_JMPREL 即 .rel.plt，reloc_offset 即 reloc_arg\n  const PLTREL *const reloc\n    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);\n\n  // 根据函数重定位表中的动态链接符号表索引，即 reloc-\u003er_info，获取函数在动态链接符号表中对应的条目\n  const ElfW(Sym) *sym = \u0026symtab[ELFW(R_SYM) (reloc-\u003er_info)];\n  const ElfW(Sym) *refsym = sym;\n  void *const rel_addr = (void *)(l-\u003el_addr + reloc-\u003er_offset);\n  lookup_t result;\n  DL_FIXUP_VALUE_TYPE value;\n\n  /* Sanity check that we're really looking at a PLT relocation.  */\n  assert (ELFW(R_TYPE)(reloc-\u003er_info) == ELF_MACHINE_JMP_SLOT);\n\n   /* Look up the target symbol.  If the normal lookup rules are not\n      used don't look in the global scope.  */\n  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-\u003est_other), 0) == 0)\n    {\n      const struct r_found_version *version = NULL;\n\n      if (l-\u003el_info[VERSYMIDX (DT_VERSYM)] != NULL)\n    {\n      const ElfW(Half) *vernum =\n        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\n      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u003er_info)] \u0026 0x7fff;\n      version = \u0026l-\u003el_versions[ndx];\n      if (version-\u003ehash == 0)\n        version = NULL;\n    }\n\n      /* We need to keep the scope around so do some locking.  This is\n     not necessary for objects which cannot be unloaded or when\n     we are not using any threads (yet).  */\n      int flags = DL_LOOKUP_ADD_DEPENDENCY;\n      if (!RTLD_SINGLE_THREAD_P)\n    {\n      THREAD_GSCOPE_SET_FLAG ();\n      flags |= DL_LOOKUP_GSCOPE_LOCK;\n    }\n\n#ifdef RTLD_ENABLE_FOREIGN_CALL\n      RTLD_ENABLE_FOREIGN_CALL;\n#endif\n      // 根据 strtab+sym-\u003est_name 在字符串表中找到函数名，然后进行符号查找获取 libc 基址 result\n      result = _dl_lookup_symbol_x (strtab + sym-\u003est_name, l, \u0026sym, l-\u003el_scope,\n                    version, ELF_RTYPE_CLASS_PLT, flags, NULL);\n\n      /* We are done with the global scope.  */\n      if (!RTLD_SINGLE_THREAD_P)\n    THREAD_GSCOPE_RESET_FLAG ();\n\n#ifdef RTLD_FINALIZE_FOREIGN_CALL\n      RTLD_FINALIZE_FOREIGN_CALL;\n#endif\n\n      /* Currently result contains the base load address (or link map)\n     of the object that defines sym.  Now add in the symbol\n   offset.  */\n\n      // 将要解析的函数的偏移地址加上 libc 基址，得到函数的实际地址\n      value = DL_FIXUP_MAKE_VALUE (result,\n                   sym ? (LOOKUP_VALUE_ADDRESS (result)\n                      + sym-\u003est_value) : 0);\n    }\n  else\n    {\n      /* We already found the symbol.  The module (and therefore its load\n     address) is also known.  */\n      value = DL_FIXUP_MAKE_VALUE (l, l-\u003el_addr + sym-\u003est_value);\n      result = l;\n    }\n\n  /* And now perhaps the relocation addend.  */\n  value = elf_machine_plt_value (l, reloc, value);\n\n  // 将已经解析完成的函数地址写入相应的 GOT 表中\n  if (sym != NULL\n      \u0026\u0026 __builtin_expect (ELFW(ST_TYPE) (sym-\u003est_info) == STT_GNU_IFUNC, 0))\n    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));\n\n  /* Finally, fix up the plt itself.  */\n  if (__glibc_unlikely (GLRO(dl_bind_not)))\n    return value;\n\n  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);\n}\n```","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/bash%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4":{"title":"bash内部命令和外部命令","content":"\n# bash内部命令和外部命令\n\n内部命令：命令的代码写在bash程序中，内部命令执行的时候和bash是同一个进程。\n外部命令：外部命令是一个独立的可执行程序，在命令执行的时候和bash不是同一个进程。\n\n在bash上执行一个外部命令的时候，bash首先调用fork(2)创建一个子进程，然后调用exec(3)家族的函数，在子进程的空间里加载外部命令的代码。bash再调用wait(2)等待子进程的结束。子进程终止以后，向父进程发送SIGCHLD信号，并将自己的退出状态码返回给bash。\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/call":{"title":"call","content":"# call\n\n- `push eip+4`\n- `mov eip, func`","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/cmpxchg":{"title":"cmpxchg","content":"# cmpxchg\n\n\u003ehttps://zhuanlan.zhihu.com/p/34556594\n\n## 底层实现\n\nlinux_x86的实现：\n\n![[z-oblib/z2-attachments/v2-918101df747ba9d03815cefff3955d74_1440w.jpg]]\n\nwindows_x86的实现：\n\n![[z-oblib/z2-attachments/v2-cd24129a2b8f106ec3179083d3e8cfd1_1440w.jpg]]\n\nmp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。\n\n1.  如果当前系统是多处理器，该函数返回1。\n2.  否则，返回0。\n\nLOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。\n\n1.  如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。\n2.  否则，不加lock前缀。\n\n这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。\n\n  \n\nintel手册对lock前缀的说明如下：\n\n1.  确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会**锁住总线**，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做**缓存锁定**（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。\n2.  禁止该指令与之前和之后的读和写指令[[3-计算机科学/2-计算机组成原理/指令重排序|重排序]]。\n3.  把写缓冲区中的所有数据刷新到内存中。\n\n## 在Java中\n\n上面的第1点保证了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]读和volatile写的内存语义。","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/epoll":{"title":"epoll","content":"# epoll\n\n## 特性\n\n### 触发模式\n\n#### 水平触发\n\n水平触发为Level Triggered，简称LT。  \n水平触发关心的是缓冲区的状态，当缓冲区可读的时候，就会发出通知，也就是当缓冲区中只要有数据就会发出通知。\n\n#### 边缘触发\n\n边缘触发为Edge Triggered，简称ET。  \n边缘触发关心的是缓冲区状态的变化，当缓冲区状态发生变化的时候才会发出通知，比如缓冲区中来了新的数据。\n\n#### 区别\n\n设想这样一个场景，当一次read()读取没有读取完缓冲区中的数据时，LT和ET的区别：  \n1、LT，此时缓冲区中还有数据，会继续发通知\n\n2、ET，此时缓冲区状态并没有发生变化，并没有来新的数据，就不会发通知，在新数据到来之前，之前剩余的数据就无法取出。\n\n所以在ET模式下，当读取数据的时候，一定要循环读取数据，直到缓冲区中的数据**全部读取**完成，一次性将数据取出。\n\n\n## 原理流程\n\n\u003e 类似java [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/ReentrantLock|ReentrantLock]] 的实现，或者像[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|Monitor]]管程的设计。线程访问资源就到等待室中等待；准备好了的资源会放入红黑树便于检索；有资源好了操作系统就会唤醒等待室中的线程。\n\n### 1、创建epoll对象\n\n如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。\n\n内核创建eventpoll对象：\n![[z-oblib/z2-attachments/v2-e3467895734a9d97f0af3c7bf875aaeb_720w.jpg]]\n\n创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。\n\n### 2、维护监视列表\n\n创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。\n\n添加所要监听的socket：\n\n![[z-oblib/z2-attachments/v2-b49bb08a6a1b7159073b71c4d6591185_720w 1.jpg]]\n\n当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。\n\n### 3、接收数据\n\n当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。\n\n给就绪列表添加引用：\n![[z-oblib/z2-attachments/v2-18b89b221d5db3b5456ab6a0f6dc5784_720w.jpg]]\n\neventpoll对象相当于是socket和进程之间的中介，socket的数据接收并**不直接影响进程**，而是通过改变eventpoll的就绪列表来改变进程状态。\n\n当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，**阻塞**进程。\n\n### 4、阻塞和唤醒进程\n\n假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。如下图所示，内核会将进程A放入eventpoll的**等待队列**中，阻塞进程。\n\nepoll_wait阻塞进程：\n![[z-oblib/z2-attachments/v2-90632d0dc3ded7f91379b848ab53974c_720w.jpg]]\n\n当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态（如下图）。也因为rdlist的存在，进程A可以**知道哪些socket发生了变化**。\n\nepoll唤醒进程：\n![[z-oblib/z2-attachments/v2-40bd5825e27cf49b7fd9a59dfcbe4d6f_720w.jpg]]\n\n## 实现细节\n\neventpoll的数据结构是什么样子？\n就绪队列应该应使用什么数据结构？\neventpoll应使用什么数据结构来管理通过epoll_ctl添加或删除的socket？\n\n如下图所示，eventpoll包含了lock、mtx、wq（等待队列）、rdlist等成员。rdlist和rbr是我们所关心的。\n\nepoll原理示意图：\n![[z-oblib/z2-attachments/v2-e63254878f67751dcc07a25b93f974bb_720w.jpg]]\n图片来源：《深入理解Nginx：模块开发与架构解析(第二版)》，陶辉\n\n### 就绪列表的数据结构\n\n\u003e 就绪队列 --\u003e 双向链表\n\n就绪列表引用着就绪的socket，所以它应能够快速的**插入**数据。\n\n程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。\n\n所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll使用**双向链表**来实现就绪队列（对应上图的rdllist）。\n\n### 索引结构\n\n\u003e 索引结构 --\u003e 红黑树\n\n既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要**便于搜索**，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（对应上图的rbr）。\n\n\u003e ps：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist并非直接引用socket，而是通过epitem间接引用，红黑树的节点也是epitem对象。同样，文件系统也并非直接引用着socket。为方便理解，本文中省略了一些间接结构。\n\n## 结论\n\nepoll在select和poll（poll和select基本一样，有少量改进）的基础引入了eventpoll作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。\n\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/gcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93":{"title":"gcc编译动态链接库","content":"\n# gcc编译动态链接库\n\n`gcc -shared -fPIC xxx.c -o libxxx.so`\n\n- -shared告诉gcc我正在编译一个dll而不是一个可执行文件，不要去找main函数等生成入口点。\n- -fPIC 表示生成地址无关代码，实际上是\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/leave":{"title":"leave","content":"# leave\n\n- `mov esp, ebp` 清空当前函数栈以还原栈空间（直接移动栈顶指针 **esp** 到当前函数的栈底 **ebp** ）；\n- `pop ebp` 还原栈底（将此时 **esp** 所指的上层函数栈底 old ebp 弹入 **ebp** 寄存器内）；","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/mutex%E9%94%81":{"title":"mutex锁","content":"\n# mutex锁\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221018173135.png]]\n\n## 编程接口\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221018173154.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221018173201.png]]\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221018173230.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/ret":{"title":"ret","content":"# ret\n\n- `pop eip` 还原执行流（将此时 **esp** 所指的上层函数调用foo时的地址弹入 **eip** 寄存器内）；","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/system_v_ipc":{"title":"system_v_ipc","content":"\n# system_v_ipc\n\n通过内核中的[[3-计算机科学/3-操作系统/Linux/共享内存|共享内存]]完成进程间通讯。\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221006013354.png]]\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221006013446.png]]\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221006013548.png]]\n\n## 获取键值\n\n![[3-计算机科学/3-操作系统/z-attachments/Pasted image 20221006013755.png]]\n\nproj_id采用8位最低有效。257=1\n\n## 具体通讯方式\n\n- [[3-计算机科学/3-操作系统/Linux/共享内存|共享内存]]\n- \n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/unistd_lseek":{"title":"unistd_lseek","content":"\n# unistd_lseek\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003234354.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/unistd_read":{"title":"unistd_read","content":"\n# unistd_read\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003234253.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/unistd_write":{"title":"unistd_write","content":"\n# unistd_write\n\n![[3-计算机科学/3-操作系统/Linux/z-attachments/Pasted image 20221003234323.png]]\n","lastmodified":"2023-01-23T15:37:51.554678744Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83":{"title":"协议数据单元","content":"\n# 协议数据单元\n\nActually, there are five words commonly used when we talk about layers of reference models (or protocol stacks): `data`, `segment`, `packet`, `frame` and `bit`. And the term PDU (`Protocol Data Unit`) is a generic term used to refer to the packets in different layers of the OSI model. Thus PDU gives an abstract idea of the data packets. The PDU has a different meaning in different layers still we can use it as a common term.\n\nWhen we come to your question, we can call all of them by using the general term `PDU`, but if you want to call them specifically at a given layer:\n\n- **Data:** PDU of Application, Presentation and Session Layers\n- **Segment:** PDU of Transport Layer\n- **Packet:** PDU of network Layer\n- **Frame:** PDU of data-link Layer\n- **Bit:** PDU of physical Layer\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B":{"title":"三次握手","content":"\n# 三次握手\n\n客户端、服务端都要确认两件事：\n1. 我发出去的包对面能不能收到\n2. 对面发给我的包我能不能收到\n\n\u003e 这也是因为网络是全双工的，所以可以想成有两条道，双方都要确认这两条道路通畅。\n\n1. 客户端向服务端发送一个控制位ACK=0，SYN=1的数据包表示请求建立连接，发送后客户端进入SYN-SENT状态。\n\t1. 此时，客户端虽然发出了数据，但是并不知道任何可用的信息。\n2. 服务端接收到数据包后，分配缓存空间，并返回给客户端一个ACK=1，SYN=1的数据包，确认号ack为客户端数据包序列号加一，服务端进入SYN-RCVD状态。\n\t1. 服务端收到客户端的包后知道了：**客户端发给我的包，我能收到**。\n\t2. 客户端收到服务端的响应后知道：**服务端发给我的包，我能收到**。\n\t3. 根据包的ack和syn字段客户端还能知道：**我发给服务端的包，服务端能收到**。\n\u003e 这一步客户端一方想要的信息都齐了，但服务端还差一点。\n3. 客户端接收到数据包后，返回给客户端ACK=1的数据包，进入Establish状态，传输连接正式建立。\n\t1. 服务端收到最终一步的包后知道：**我发给客户端的包，客户端能收到**。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2-%E4%BC%A0%E8%BE%93%E5%B1%82/tcp/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B":{"title":"四次挥手","content":"\n# 四次挥手\n\n1. **我要走了**：客户端完成所有数据传输，向服务端发送一个FIN=1的终止连接报文，并设置序列号为传输数据的最后一个字节序号，发送后客户端进入FIN-Wait一阶段。\n2. **知道了，最后一点东西给你打包带上，稍等**：服务端接收到终止连接报文，并返回给客户端一个ACK确认报文，此时客户端进入FIN-Wait二阶段，客户端无法再进行数据传输，然而服务端可能还存在没有发送给客户端的数据，因此不能立刻关闭连接。\n3. **所有东西都在这里了，拿好**：服务端在发送完所有数据后，再发送一个ACK=1，FIN=1的终止确认给客户端，此时服务端进入LAST-ACK状态。\n4. **好的，你忙吧2MSL不找我，我就自己走了**：客户端收到响应后，返回给服务端一个ACK=1的响应，并进入TIME-WAIT状态，等待时间为2MSL，即两倍的最大数据段传输时间。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-%E5%BA%94%E7%94%A8%E5%B1%82/dhcp":{"title":"dhcp","content":"\n# dhcp\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3-%E5%BA%94%E7%94%A8%E5%B1%82/mqtt%E7%AE%80%E4%BB%8B":{"title":"mqtt简介","content":"\n# mqtt简介\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84":{"title":"IP数据包结构","content":"\n# IP数据包结构\n\n![[3-计算机科学/4-计算机网络/z-attachments/Pasted image 20221116105529.png]]\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/flow":{"title":"flow","content":"\n# flow\n\nflow是指`五元组`\u003c协议类型、源IP地址、目的IP地址、源端口号、目的端口号\u003e相同的数据包。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95":{"title":"索引","content":"# 索引\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2":{"title":"联合查询","content":"# 联合查询\n\n\u003e 联合索引就是复合索引、组合索引、多列索引。\n\n联合查询是在[[3-计算机科学/5-数据库系统/索引|索引]]的基础上，一个节点压缩放入多个列。类似一个多条件联合的if语句\n\n![[z-oblib/z2-attachments/3f7c0b118d08445d9a66131124ec2276.png]]\n\n```java\nif (name==Bill \u0026\u0026 age==30 \u0026\u0026 role==dev)\n```\n\n**重复值越少的越放前面**，比如一个列 95%的值都不重复，那么一般可以将这个列放最前面。另外，**复合索引的字段数尽量不要超过 3个**，一旦超过，要慎重考虑必要性。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E9%9D%9E%E8%8E%B7%E5%8F%96%E5%8C%B9%E9%85%8D":{"title":"非获取匹配","content":"\n# 非获取匹配\n\n![[3-计算机科学/6-应用开发/0-软件语言/正则表达式/z-attachments/Pasted image 20221118003943.png]]\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/ARM%E7%9A%8437%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6":{"title":"ARM的37个寄存器和异常处理机制","content":"\n# ARM的37个寄存器和异常处理机制\n\n## 参考\n\n[(1条消息) ARM的37个寄存器和异常处理机制详解_正在起飞的蜗牛的博客-CSDN博客](https://blog.csdn.net/weixin_42031299/article/details/114737622)\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/CPSR":{"title":"CPSR","content":"\n# CPSR\n\nCPSR(current program status register)寄存器，**32位**状态寄存器。\n\nCPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。\n\n## 各位含义\n\n- CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位。\n- N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行。\n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/arm/z-attachments/Pasted image 20220923161543.png]]\n\n### 条件码\n\n| 标志位 | 含                                义                                                                                                                                                  |\n|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| N   | 当用两个补码表示的带符号数进行运算时，N=1表示运算的结果为负数；N=0表示运算的结果为正数或零                                                                                                                                    |\n| Z   | Z=1表示运算的结果为零，Z=0表示运算的结果非零。                                                                                                                                                          |\n| C   | 可以有4种方法设置C的值：\u003cbr/\u003e加法运算（包括CMP）：当运算结果产生了进位时（无符号数溢出），C=1，否则C=0。\u003cbr/\u003e减法运算（包括CMP）：当运算时产生了借位时（无符号数溢出），C=0，否则C=1。\u003cbr/\u003e对于包含移位操作的非加/减运算指令，C为移出值的最后一位。\u003cbr/\u003e对于其它的非加/减运算指令，C的值通常不会改变。\u003cbr/\u003e\u003cbr/\u003e |\n| V   | 可以有2种方法设置V的值：\u003cbr/\u003e对于加减法运算指令，当操作数和运算结果为二进制的补码表示的带符号数时，V=1表示符号位溢出\u003cbr/\u003e对于其它的非加/减运算指令，V的值通常不会改变。\u003cbr/\u003e                                                                                   |\n| Q   | 在ARM V5及以上版本的E系列处理器中，用Q标志位指示增强的DSP运算指令是否发生了溢出。在其它版本的处理器中，Q标志位无定义                                                                                                                    |\n\n### 控制位\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/FIQ":{"title":"FIQ","content":"\n# FIQ\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/MSR":{"title":"MSR","content":"\n# MSR\n\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8":{"title":"x86汇编快速入门","content":"\n# x86汇编快速入门\n\n## 寄存器\n\n### CS : IP\n\n- 物理地址 = 段地址 X 10H + 偏移地址\n    - 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H\n- 同一个物理地址可以由不同的段地址和偏移地址构成\n\n#### 段寄存器\n\n- CS: 代码段寄存器 (Code Segment)\n    - 主要关注此寄存器\n- DS: 数据段寄存器 (Data Segment)\n- SS: 栈段寄存器 (Stach Segment)\n- ES: 附加段寄存器 (Extra Segment)\n\n#### 程序执行\n\n任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:  \n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151311.png]]\n\n#### 修改 CS:IP 控制流程\n\n1. 修改 CS 和 IP\n    1. `jmp 段地址:偏移地址`\n        - `jmp  2AE3:3` -\u003e 从 2AE33H 处读取指令\n        - `jmp  3:0B16` -\u003e 从 00B46H 处读取指令\n1. 只修改 IP\n    1. `jmp 某合法寄存器`\n        - `jmp  bx`\n            - 执行前: bx = 0B16H, CS = 2000H, IP = 0003H\n            - 执行后: BX = 0B16H, CS = 2000H, IP = 0B16H\n        - `jmp  bx` 类似 `mov   IP, bx` (把寄存器的值当作 IP)\n\n## Winodws 下的汇编工具\n\n### 准备\n\n- DOSBox 环境模拟器\n- debug.exe\n    - win7 及以上系统不自带\n\n### 环境配置\n\n1. 安装 DOSBox0.74-win32-installer.exe\n1. 自动配置 DOSBox 操作目录\n    1. 运行安装目录中的 `DOSBox 0.74 Options.bat`\n    1. 弹出的配置文件中加入如下内容:\n\t\n\t```\n\tMOUNT C E:\\masmpro         # 将后面的目录挂载到dos的c盘符下\n\tset PATH=$PATH$;E:\\masmpro # $PATH$代表已有环境变量, 后面是当前目录\n\t目录不能带中文和空格.\n\t```\n\t\n\n1. 手动配置 DOSBox 操作目录\n    1. 启动 dosbox\n    1. 手动输入 `MOUNT C E:\\masmpro`\n2. 配置 masmpro\n    1. 将 debug.exe 等软件拷贝到目录下\n\n### debug 工具\n\n- debug 是 Dos, Windows 提供的实模式 (8086方式) 程序的调试工具\n- debug 功能\n    - 查看 CPU 各个寄存器内容\n    - 查看内存情况\n    - 在机器码级别跟踪程序的运行\n- 常用操作\n    - `R` 查看更改 cpu 寄存器内容\n        1. `R AX`\n        1. 出现 `:` 后输入要写入的数据\n        1. 回车\n        1. 再按 `R` 查看修改情况\n    - `D` 查看内存内容\n        - `D 段地址:偏移地址`\n    - `E` 改写内存内容\n    - `U` 将内存中机器指令翻译为汇编指令\n    - `T` 执行一条机器指令\n    - `A` 以汇编格式在内存中写入一条指令  \n\n    \n    ```\n    参考 王爽 \u003c汇编语言第三版\u003e p35.\n    ```\n    \n\n## 分段管理及标志寄存器\n\n- 一个存储单元有一个物理地址\n    - 一个存储单元的编号\n    - 每个物理存储单元都有一个 20 位编号\n    - 8086CPU 物理地址范围: 00000H ~ FFFFFH\n    - 物理地址为逻辑地址左移 4 位 (乘以10h), 加上偏移地址\n        - `1230:100`, `1030:2100`, `1100:1400` 对应的物理地址都是 `12400`\n- 一个存储单元对应多个逻辑地址\n    - 用户编程时, 采用逻辑地址\n        - `段基地址 : 段内偏移地址`\n\n### 段寄存器和逻辑段\n\n- 8086CPU 有 4 个段寄存器\n- 每个段寄存器用来确定一个逻辑段的起始位置\n- 每种逻辑段均有自己的用途\n    - CS: 代码段寄存器 (Code Segment)\n        - 利用 CS:IP 取得下一条要执行的指令\n    - DS: 数据段寄存器 (Data Segment)\n        - 利用 DS:EA 存取数据段中的数据\n    - SS: 栈段寄存器 (Stach Segment)\n        - 利用 CS:IP 操作堆栈顶的数据\n    - ES: 附加段寄存器 (Extra Segment)\n        - 利用 ES:EA 存取附加段中的数据\n\n    \n    ```\n    - EA 是偏移地址, 称之为有效地址 EA\n    - 若操作数在主存中, 存取的方式有:\n        - 直接寻址\n        - 寄存器间接寻址\n        - 寄存器相对寻址\n        - 基址变址寻址\n        - 相对基址变址寻址\n    ```\n    \n- 没有指明段前缀时, 一般的数据访问在 DS (u数据) 段\n    - `MOV AX, [1000H]` == `MOV AX,DS:[1000H]`\n        - 从默认的 DS 段中取出数据\n    - `MOV AX,CS:[1000H]`\n        - 从指定的 CS 段取出数据\n\n## 标志寄存器\n\n结构图:  \n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151340.png]]\n\n含义:  \n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151353.png]]\n\n- 状态标志\n    - 用于记录程序运行结果的状态信息\n        - CF 进位标志 (Carry Flag)\n            - 当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0\n        - ZF 零标志 (Zero Flag)\n            - 弱运算结果为 0, 则置 1, 否则 0\n        - SF 符号标志 (Sign Flag)\n            - 若运算结果最高位(符号位)为 1, 则置 1, 否则 0\n        - PF 奇偶标志 (Parity Flag)\n            - 运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0\n        - OF 溢出标志 (Overflow Flag)\n            - 运算结果有溢出, 则置 1, 否则 0\n            - 溢出: 有符号数的运算结果不正确\n        - AF 辅助进位标志 (Auxiliary Carry Flag)\n            - 运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0\n- 控制标志\n    - 用于控制处理器执行指令\n        - DF 方向标志 (Direction Flag)\n            - 用于串操作指令, 控制地址的变化方向\n            - 1 则存储器地址自动增加\n            - 0 则存储器地址自动减少\n            - `CLD` 用于复位 DF = 0\n            - `STD` 用于置位 DF = 1\n        - IF 终端允许标志 (Interrupt-enable Flag)\n            - 0 禁止中断\n            - 1 允许中断\n            - `CLI` 用于复位 IF = 0\n            - `STI` 用于置位 IF = 1\n        - TF 陷阱标志 (Trap Flag)\n            - 0 处理器正常工作\n            - 1 处理器单步执行\n\n## 指令及寻址方式\n\n- 零操作数指令\n- 一操作数指令\n- 二操作数指令\n    - `操作码 目的操作数 源操作数`\n\n### 七种寻址方式\n\n\u003e 寻址方式: 指令中指明操作数存放位置的表达方式.  \n\n指令中操作数的数据存放位置有 3 种情况:\n\n- 存放指令中 (立即数)\n    - 操作数包含在指令中\n    - 备操作数据直接表示在指令的操作数字段中\n    - 紧跟在操作码之后\n    - 例如 `MOV AL, 10H`\n- 存放于寄存器中 (寄存器操作数) \n    - 数据存放在 CPU 的一个寄存器中\n    - 例如 `INC CX`\n- 存放于存储器中 (存储器操作数)\n    - 数据再内存或 I/I 端口中\n    - 存放数据的偏移地址以某种方式表示在指令中\n    - 例如 `MOV AX, [2500H]`\n        - 其中 [2500] 为存储器操作数\n        - 存储器操作数中操作的数字段指示此操作数的偏移地址\n        - 段地址由某个段寄存器提供\n        - 默认为 DS 提供\n\n### 寻址方式分类\n\n- 立即数寻址\n    - 操作数为立即数\n    - 直接存放在指令的操作数字段\n    - 只允许源操作数为立即数\n    - 目标操作数必须是寄存器或存储单元\n        - 给寄存器或存储单元赋值\n- 寄存器寻址\n    - 直接在指令中写出寄存器名称\n- 存储器寻址\n    - 直接寻址\n        - 操作数存在内存中, 操作数的偏移地址直接表示在指令中\n        - 表示格式: [偏移地址]\n        - 默认操作数存放在内存的数据段中\n        - 例如 `MOV AL, [1064H]`\n        - 段超越指明使用的段\n    - 寄存器间接寻址\n    - 基址加变址寻址\n    - 相对加基址变址寻址\n\n## 常见汇编指令\n\n### 数据传送指令\n\n#### 通用传送指令\n\n\u003e 所有通用传送指令都不影响标志位.  \n\n- MOV DST, SRC;\n    - 将 SRC 内容赋值给 DST\n    - 存储器操作数之间不能直接传递\n        - 反例: `MOV [1000H], [DI]`\n        - 应改为: `MOV AX, [DI]`; `MOV [1000H], AX`\n    - 立即数不能直接给段寄存器\n        - 反例: `MOV DS, 2000H`\n        - 应改为: `MOV AX, 2000H`, `MOV DS, AX`\n    - 段寄存器之间不能直接传递\n    - CS 值可以作为源操作数\n    - 源操作数和目的操作数宽度必须相等\n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151408.png]]\n\n#### 堆栈指令\n\n\u003e 后进先出.  \n\u003e 赋值遵循高高低低原则.\n\n- PUSH src\n    1. (SP) \u003c- (SP) - 2\n        - 堆栈操作以字为单位, 所以 -2\n    1. ((SP)+1,(SP)) \u003c- (src)\n- POP\n    - 把 SP 所指向的堆栈顶部的一个字送入目的地址, 同时谢盖堆栈指针\n    1. (dst) \u003c- ((SP)+1,(SP))\n    1. (SP) \u003c- (SP)+2\n\n#### 交换指令\n\n- XCHG dst, src\n    - 可以实现寄存器之间, 寄存器和存储器之间的交换操作\n    - 存储器之间不能直接交换\n    - 段寄存器不能作为操作数\n    - 允许字或字节操作\n\n#### 输入指令\n\n- IN\n    - 用于 CPU 从外设端口接收数据\n\n#### 输出指令\n\n- OUT\n    - 用于 CPU 向外设端口传输数据\n\n#### 目的地址传送指令\n\n- LEA reg16, mem\n    - reg16 -- 16位通用寄存器\n    - mem -- 存储单元\n    - 将元操作数的偏移地址传给目的操作数\n    - 源操作数必须以寄存器间接寻址, 变址寻址, 基址加变址寻址等方式表示的存储器操作数\n- LDS reg16, mem\n\n#### 标志传送指令\n\n- LAHF\n    - 将标志寄存器低八位传送给 AH\n- SAHF\n    - 将 AH 赋值给标志寄存器低八位\n- PUSHF\n    - 标志进栈\n- POPF\n    - 标志出栈\n\n### 算数运算类指令\n\n#### 加法指令\n\n- ADD (Addition) 加法指令\n    - `ADD dest, src`\n    - (data) \u003c- (dest) + (src)\n    - 源和目的不能同时为存储器, 不能为段寄存器\n- ADC (Add with Carry) 带进位加法指令\n    - `ADC dest, src`\n    - (dest) \u003c- (dest) + (src) + C\n    - C 是上一条指令的进位结果\n    - 用于多字节拆分运算\n- INC (Increment) 加 1 指令\n    - `INC dest`\n    - (dest) \u003c- (dest) + 1\n    - 多用于循环中修改地址指针和循环次数\n    - 影响标志位 S, Z, A, P, O\n\n#### 减法指令\n\n- SUB\n    - `SUB dest, src`\n    - (data) \u003c- (dest) - (src)\n- SBB\n    - `SBB dest, src`\n    - (dest) \u003c- (dest) - (src) - C\n- DEC\n    - `DEC dest`\n    - (dest) \u003c- (dest) - 1\n    - 多用于循环中修改地址指针和循环次数\n    - 影响标志位 S, Z, A, P, O\n\n#### 求补指令\n\n- `NEG dest`\n    - (dest) \u003c- 0 - (dest)\n    - 把操作数按位求反再加一\n\n#### 比较指令\n\n- `CMP dest, src`\n    - (dest) - (src)\n    - 结果不保留, 只用来影响标志位\n        - A, C, O, P, S, Z\n    - 比较两个数的大小关系\n        - Z: 判断两者是否相等\n        - C: 判断两个无符号数的大小\n        - S, O: 判断两个带符号数的大小\n    - cmp 算术减法运算结果为零,就把ZF(零标志)置1\n\n#### 乘法指令\n\n- MUL 无符号乘法\n    - `MUL SRC`\n    - 字节操作数: AX \u003c- (AL) * (SRC)\n    - 字操作数: DX:AX \u003c- (AX) * (SRC)\n- IMUL 带符号乘法\n    - 与上面类似\n\n#### 除法指令\n\n- DIV 无符号除法\n    - `DIV SRC`\n    - 字节除法:\n        - AL \u003c- (AX) / (SRC) 的商\n        - AL \u003c- (AX) / (SRC) 的余数\n    - 字除法:\n        - AL \u003c- (DX:AX) / (SRC) 的商\n        - AL \u003c- (DX:AX) / (SRC) 的余数\n- IDIV 有符号除法\n    - 与上面类似\n\n### 逻辑运算指令 (位操作)\n\n- AND dest, src\n    - (dest) \u003c- (dest) and (src)\n- TEST dest, src\n    - 与 and 类似\n    - 不保存结果, 只改变标志位\n    - test逻辑与运算结果为零,就把ZF(零标志)置1\n- OR dest, src\n    - 与 and 相反\n- XOR dest, src\n    - 相同为 0\n- NOT dest\n    - 按位取反\n\n### 移位指令 (位操作)\n\n- SAL (Shift Arithmetic Left) 算术左移\n    - 相当于无符号乘以2^n\n    - 最低位填充 0\n- SAR (shift arithmetic right) 算术右移\n    - 最高位不变\n    - 最低位移入寄存器 CL\n- SHL (shift logical left) 逻辑左移\n    - 相当于无符号乘以2^n\n    - 最低位填充 0\n- SHR (shift logical right) 逻辑右移\n    - 相当于无符号除以2^n\n    - 最高位填充 0\n    - 最低位进入寄存器 CF\n- ROL (rotate left) 循环左移\n    - 最高位放入最低位\n    - 最高位复制到 CF\n- ROR (rotate right) 循环右移\n    - 最低位放入最高位\n    - 最低位复制到 CF\n- RCL (rotate left with carry) 带进位循环左移\n    - CF 进位值放低位\n    - 高位放 CF\n- RCR (rotate right with carry) 带进位循环右移\n    - CF 进位值放高危\n    - 低位放 CF\n\n指令格式:  \n\n```x86arm\n操作码 reg/mem, count   # count=1或CL, 指定移位次数\n```\n\n### 串操作\n\n\u003e 串是内存中一段地址相连的字节或字.\n\n- 串操作也叫数据块操作\n- 可实现存储器数据间的直接传送\n- 8086 有 5 种基本串操作\n- 对字操作以 B 结尾, 对字节操作以 W 结尾\n    - MOVS (move string) 串传送\n    - CMPS (compare string) 串比较\n    - SCAS (scan string) 串扫描\n    - LODS (load from string) 取串\n    - STOS (store in to string) 存串\n    - REP 重复串操作执行过程\n        - 当 CX != 0 则执行 CX \u003c- CX - 1, 再执行后续串指令\n        - 当 CX == 0, 结束 REP, 执行下一条指令\n\n```\n可以不借助寄存器直接在存储器间传递数据.\n```\n\n### 控制类指令\n\n#### 非条件转移\n\n- JMP \n    - `JMP 位置`\n\n#### 条件转义\n\n- 根据单个条件标志\n    - Z 标志\n        - JZ / JNZ (jump on zero; jump on no zero)\n    - C 标志\n        - JC / JNC (jump if carry)\n    - p 标志\n        - JP (JPE) / JNP (JPO) (jump on parity; jump on even; jump on odd)\n    - S 标志\n        - JS (负号跳转) / JNS\n    - 0\n        - JO (溢出跳转) / JNO\n- 根据两个无符号数大小关系\n    - JB 低于跳转\n    - JBE 不高于跳转\n    - JA 高于跳转\n    - JAE 高于等于跳转\n    - JNB 不低于跳转\n- 根据两个带符号数比较结果\n    - JL (JNGE) 小于跳转\n    - JNL (JGE) 不小于跳转\n\n```\n所有条件转义指令都是段内 (-128 ~ +127) 范围内转移\n```\n\n#### 过程(子程序)调用\n\n- 自程序调用\n    - CALL 子过程名\n- 返回指令\n    - RET\n        - 在子程序的结尾\n        - 用于返回主程序\n\n#### 无条件循环\n\n- LOOP 语句标号\n    - CX \u003c- CX - 1\n    - 若 CX != 0 转向目标地址去执行\n    - 否则执行 LOOP 之后的指令\n    - 过程解释\n        1. 首先执行 CX = CX - 1\n        1. 判断 CX 的值\n        1. 若 CX != 0 则转移到 Lable 处执行\n        1. 否则向下继续\n\n#### 条件循环\n\n- LOOPZ / LOOPE 语句标号\n    - CX \u003c- CX - 1\n    - 若 CX != 0 且 ZF == 1, 转向目标地址执行\n    - 否则执行之后的语句\n    - 过程解释\n        - 首先执行 CX = CX - 1\n        - 判断 CX != 0 和 ZF == 1 满足则转到 Lable 执行\n        - 否则向下继续\n\n#### 中断指令\n\n- 中断调用\n    - INT n\n    - n为中断号, 0 ~ 255\n- 中断返回\n    - IRET\n\n#### 标志处理指令\n\n- CLC (clear carry flag) 清 C\n- STC (set carry flag) 置 C\n- CMC (complement carry flag) C 求反\n- CLD (clear direction flag) 清 D\n- STD (set direction flag) 置 D\n- CLI (clear interrupt flag) 清 I\n- STI (set interrupt enable flag) 置 I\n\n#### 其它处理机控制指令\n\n- NOP (no operation)\n\n## OPCode\n\n- 一个 opcode 不一定对应一条汇编指令\n- 一条汇编指令不一定对应一个 opcode\n\n### OPCode 主要数据域\n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917151425.png]]\n\n- 以上只有 Code 域是必须存在的\n- 其它数据域视指令格式而定有无\n- 一个指令的长度在 `1Byte ~ 16Byte` 之间\n- 实际正常的最长指令为 `13Byte`\n\n### 指令前缀\n\n- 前缀(Prefixes)大小为 `Byte, 可以被划分为 5 个集合\n    - 切换操作数大小 66\n    - 切换地址大小 67\n        - 切换是特指在 2 种状态间切换, 而非切换到特指的某状态\n    - 重复操作前缀 F2/F3\n    - 修改默认段 2E/36/3E/26/64/65\n        - 将默认值修改为其它段\n    - 锁定前缀 F0\n- 这些指令独此一份, 不可能为其它机器码\n- 如果有多个 prefixes, 顺序可能是乱序\n- 如果 prefixes 不能对后续的 opcode 起作用, 那就被忽略\n- 出现特定操作码时用作补充说明, 一般是指令冒号前的部分\n\n### ModR/M\n\n- 辅助说明操作码的操作数\n    - 操作数的个数\n    - 操作数的种类 [寄存器, 内存地址, 常量]\n\n### D-SIB\n\n- 用来辅助说明 ModR/M\n- 辅助寻址\n- 需要和 ModR/M 一起使用\n\n### 位移\n\n- 操作码的操作数为内存地址事, 用来表示位移操作\n\n### 立即数\n\n- 操作码的操作数是常量, 该常量为立即数\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90":{"title":"寄存器，test，cmp剖析","content":"# 寄存器，test，cmp剖析\n\n## 状态寄存器\n\n\u003e 首先复习一下状态寄存器.\n\nPSW(Program Status Word)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,如下所示：  \n\n![[3-计算机科学/6-应用开发/0-软件语言/汇编/z-attachments/Pasted image 20220917161214.png]]\n\n条件码：  \n- OF(Overflow Flag)溢出标志\n    - 溢出时为1，否则置0\n    - 标明一个溢出了的计算\n- SF(Sign Flag)符号标志\n    - 结果为负时置1，否则置0\n- ZF(Zero Flag)零标志,\n    - 运算结果为0时置1，否则置0\n- CF(Carry Flag)进位标志\n- 进位时置1，否则置0\n- 注意:Carry标志中存放计算后最右的位\n- AF(Auxiliary carry Flag)辅助进位标志\n    - 记录运算时第3位(半个字节)产生的进位置\n    有进位时1,否则置0。\n- PF(Parity Flag)奇偶标志\n    - 结果操作数中1的个数为偶数时置1，否则置0  \n    - \n控制标志位：  \n- DF(Direction Flag)方向标志\n    - 在串处理指令中控制信息的方向\n- IF(Interrupt Flag)中断标志\n- TF(Trap Flag)陷井标志  \n\n\u003e test和cmp指令运行后都会设置标志位.\n\n## test\n\n\u003e test 是逻辑运算符\n\n- 执行BIT与BIT之间的逻辑运算\n- 两操作数作与运算,仅修改标志位，不回送结果\n- `test r/m, r/m/data`\n- 影响标志位 C,O,P,Z,S(其中C与O两个标志会被设为0)\n- test 的一个非常普遍的用法是用来测试一方寄存器是否为空\n    - test ecx, ecx\n    - jz somewhere\n    - 如果ecx为零，设置ZF零标志为1，Jz跳转\n\n## cmp\n\n\u003e cmp 属于算术运算指令\n\n- 比较两个值(寄存器,内存,直接数值)\n- 两操作数作减法,仅修改标志位,不回送结果\n- `CMP r/m,r/m/data`\n- 影响标志位 C,P,A,Z,O\n\n## 总结\n\n- test 逻辑与运算结果为零,就把ZF(零标志)置1\n- cmp 算术减法运算结果为零,就把ZF(零标志)置1","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/Java%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7":{"title":"Java调试技巧","content":"\n# Java调试技巧\n\n## 找某个值的默认参数\n\n1. 推理某个变量值在哪个方法里用到\n2. maven中下载对应包的source\n3. 全局搜索该方法\n4. **find usages**找到方法调用处\n5. 找到上层方法中对应该该变量的参数\n6. 逐级往上寻找，遇到接口跳转到对应模块下的实现\n7. 找到最终的源头\n\n### 总结\n\n巧用find usages，找到调用处。\n选中变量，在右侧滚动条中会用粉红色标题赋值位置。\n\n## 利用debug堆栈回溯\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB":{"title":"内部类","content":"# 内部类\n\n被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。\n\n## Inner Class\n\n```java\nclass Outer {\n    class Inner {\n        // 定义了一个Inner Class\n    }\n}\n```\n\n上述定义的`Outer`是一个普通类，而`Inner`是一个Inner Class，它与普通类有个最大的不同，就是**Inner Class的实例不能单独存在**，必须依附于一个Outer Class的实例。示例代码如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\"); // 实例化一个Outer\n        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner\n        inner.hello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    class Inner {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.this.name);\n        }\n    }\n}\n```\n\n要实例化一个`Inner`，我们必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例：\n\n```java\nOuter.Inner inner = outer.new Inner();\n```\n\nInner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以**修改Outer Class的`private`字段**，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的`private`字段和方法。\n\n观察[[Java编译器]]编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而`Inner`类被编译为`Outer$Inner.class`。\n\n## Anonymous Class\n\n通过[[匿名类]]（Anonymous Class）定义Inner Class。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\");\n        outer.asyncHello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    void asyncHello() {\n\t    // 实例化接口时直接\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello, \" + Outer.this.name);\n            }\n        };\n        new Thread(r).start();\n    }\n}\n\n```\n\n观察`asyncHello()`方法，我们在方法内部实例化了一个[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Runnable]]。`Runnable`本身是[[接口]]，接口是不能实例化的，所以这里实际上是定义了一个实现了`Runnable`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`Runnable`。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：\n\n```java\nRunnable r = new Runnable() {\n    // 实现必要的抽象方法...\n};\n```\n\n匿名类和Inner Class一样，可以访问Outer Class的`private`字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。\n\n观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`。如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`……\n除了接口外，匿名类也完全可以继承自普通类。观察以下代码：\n\n```java\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap\u003cString, String\u003e map1 = new HashMap\u003c\u003e();\n        HashMap\u003cString, String\u003e map2 = new HashMap\u003c\u003e() {}; // 匿名类!\n        HashMap\u003cString, String\u003e map3 = new HashMap\u003c\u003e() {\n            {\n                put(\"A\", \"1\");\n                put(\"B\", \"2\");\n            }\n        };\n        System.out.println(map3.get(\"A\"));\n    }\n}\n```\n\n`map1`是一个普通的`[[HashMap]]`实例，但`map2`是一个匿名类实例，只是该匿名类继承自`HashMap`。`map3`也是一个继承自`HashMap`的匿名类实例，并且添加了`static`代码块来初始化数据。观察编译输出可发现`Main$1.class`和`Main$2.class`两个匿名类文件。\n\n## Static Nested Class\n\n使用`static`修饰，称为静态内部类（Static Nested Class）：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer.StaticNested sn = new Outer.StaticNested();\n        sn.hello();\n    }\n}\n\nclass Outer {\n    private static String NAME = \"OUTER\";\n\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n\n    static class StaticNested {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.NAME);\n        }\n    }\n}\n\n```\n\n用`static`修饰的内部类和Inner Class有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此**无法引用`Outer.this`**，但它**可以访问`Outer`的`private`静态字段和静态方法**。如果把`StaticNested`移到`Outer`之外，就失去了访问`private`的权限。\n\n## 小结\n\nJava的内部类可分为**Inner Class**、**Anonymous Class**和**Static Nested Class**三种：\n\n* Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有`Outer.this`实例，并拥有Outer Class的`private`访问权限；\n    \n* Static Nested Class是独立类，但拥有Outer Class的`private`访问权限。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8":{"title":"异常","content":"\n# 异常\n\n通常，Java的异常(包括Exception和Error)分为：\n- 检查异常（checked exceptions）\n- 非检查的异常（unchecked exceptions）。\n其中根据Exception异常进行划分，可分为：\n- 运行时异常\n- 非运行时异常\n\n## 检查异常\n\n就是**编译器**要求你**必须**处置的异常。不知道你编程的时候有没有遇到过，你写的某段代码，编译器要求你必须要对这段代码try...catch，或者throws exception，如果你遇见过，没错，这就是检查异常，也就是说，你代码还没运行呢，编译器就会检查你的代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理。\n\n### 处理\n\n1、继续抛出，消极的方法，一直可以抛到java虚拟机来处理，就是通过throws exception抛出。  \n2、用try...catch捕获  \n注意，对于检查的异常必须处理，或者必须捕获或者必须抛出\n\n### 分类\n\n除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。\n\n## 非检查异常\n\n编译器不要求强制处置的异常，虽然你有可能出现错误，但是我不会在编译的时候检查，没必要，也不可能。\n\n### 处理\n\n1、捕获  \n2、继续抛出  \n3、不处理\n\n一般我们是不处理的，因为你很难判断会出什么问题，而且有些异常你也无法运行时处理，比如空指针，需要人手动的去查找。\n\n而且，捕捉异常并处理的代价远远大于直接抛出。\n\n### 为何存在\n\n你想想非检查异常都有哪些？NullPointerException，IndexOutOfBoundsException，VirtualMachineError等，这些异常你编译的时候检查吗？再说了，明明可以运行时检查，都在编译的时候检查，你写的代码还能看吗？而且有些异常只能在运行时才能检查出来，比如空指针，堆溢出等。\n\n### 分类\n\nRuntimeException与其子类，以及错误（Error）。\n\n## 运行时异常\n\n都是**RuntimeException类及其子类**异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是**非检查**异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\n\n## 非运行时异常\n\n是**RuntimeException以外**的异常，类型上都属于Exception类及其子类。从程序语法角度讲是**必须进行处理**的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，**一般情况下不要自定义检查异常**。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE":{"title":"枚举","content":"# 枚举\n\n枚举是一个类，内部写规定了这个类的所有实例。\n\n## 用途\n\n### 编译器类型检测\n\n和`int`定义的常量相比，使用`enum`定义枚举有如下好处：\n\n首先，`enum`常量本身带有类型信息，即`Weekday.SUN`类型是`Weekday`，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：\n\n```java\nint day = 1;\nif (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '=='\n}\n```\n\n其次，不可能引用到非枚举的值，因为无法通过编译。\n\n最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个`Weekday`枚举类型的变量赋值为`Color`枚举类型的值：\n\n```java\nWeekday x = Weekday.SUN; // ok!\nWeekday y = Color.RED; // Compile error: incompatible types\n```\n\n这就使得编译器可以在编译期自动检查出所有可能的潜在错误。\n\n## 用法\n\n### 值比较\n\n使用`enum`定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用`equals()`方法，如果使用`==`比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用`equals()`方法，但`enum`类型可以例外。\n\n这是因为`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较：\n\n```java\nif (day == Weekday.FRI) { // ok!\n}\nif (day.equals(Weekday.SUN)) { // ok, but more code!\n}\n```\n\n### 推荐用法\n\n如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠`ordinal()`的返回值。因为`enum`本身是`class`，所以我们可以定义`private`的构造方法，并且，给每个枚举常量添加字段：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day.dayValue == 6 || day.dayValue == 0) {\n            System.out.println(\"Work at home!\");\n        } else {\n            System.out.println(\"Work at office!\");\n        }\n    }\n}\n\nenum Weekday {\n    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);\n\n    public final int dayValue;\n\n    private Weekday(int dayValue) {\n        this.dayValue = dayValue;\n    }\n}\n\n```\n\n## 总结\n\n- Java使用`enum`定义枚举类型，它被编译器编译为`final class Xxx extends Enum { … }`；\n- 通过`name()`获取常量定义的字符串，注意不要使用`toString()`；\n- 通过`ordinal()`返回常量定义的顺序（无实质意义）；\n- 可以为`enum`编写构造方法、字段和方法\n- `enum`的构造方法要声明为`private`，字段强烈建议声明为`final`；\n- `enum`适合用在`switch`语句中。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"\n# 泛型\n\n## 类型擦除\n\n下面的例子无法编译通过：\n\n```java\n// generics/HasF.java\n\npublic class HasF {\npublic void f() {\nSystem.out.println(\"HasF.f()\");\n}\n}\n```\n\n```java\n// generics/Manipulation.java  \n// {WillNotCompile}  \n  \nclass Manipulator\u003cT\u003e {  \n    private T obj;  \n  \n    Manipulator(T x) {  \n        obj = x;  \n    }  \n  \n    // Error: cannot find symbol: method f():  \n    // 传入时类型就擦除了，obj现在时Object类型，没有f方法\n    public void manipulate() {  \n        obj.f();  \n    }  \n  \n}  \n  \npublic class Manipulation {  \n    public static void main(String[] args) {  \n        HasF hf = new HasF();  \n        // 这里只做了传入的对象是否未HasF类型判断，之后就擦除了类型\n        Manipulator\u003cHasF\u003e manipulator = new Manipulator\u003c\u003e(hf);  \n        manipulator.manipulate();  \n    }  \n}\n```\n\n因为`Manipulator\u003cHasF\u003e`这里`\u003cHasF\u003e`的作用只是对等号右边传入的`new Manipulator\u003c\u003e(hf)`进行了类型检测，随后就将其类型擦除为Objcet。在`manipulate()`方法中编译器只知道obj对象是个Object类型，没有f()方法。\n\n### 给定泛型边界\n\n为了调用 f()，我们必须协助泛型类，给定 泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 extends 关键字。由于有了边界，下面的代码就能通过编译：\n\n```java\npublic class Manipulator2\u003cT extends HasF\u003e {  \n    private T obj;  \n  \n    Manipulator2(T x) {  \n        obj = x;  \n    }  \n  \n    public void manipulate() {  \n        obj.f();  \n    }  \n  \n}\n```\n\n边界 `\u003cT extends HasF\u003e` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此， 就可以安全地在 obj 上调用 f() 方法。\n**泛型类型参数会擦除到它的第一个边界**（可能有多个边界，稍后你将看到）。\njava还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除边界，就像上面 的示例，T 擦除到了 HasF，就像在类的声明中用 HasF 替换了 T 一样。\n\n\u003e 例如，`List\u003cT\u003e` 这样的类型注解会被 擦除为 List，普通的类型变量在未指定边界的情况下会被擦除为 Object。\n\n```java\n// generics/Manipulator3.java  \n  \nclass Manipulator3 {  \n    private HasF obj;  \n  \n    Manipulator3(HasF x) {  \n        obj = x;  \n    }  \n  \n    public void manipulate() {  \n        obj.f();  \n    }  \n}\n```\n\n这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加\n“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中\n的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `\u003cT extends HasF\u003e`\n形式就是有缺陷的。例如，如果某个类有一个返回 T 的方法，那么泛型就有所帮助，因\n为它们之后将返回确切的类型：\n\n```java\n// generics/ReturnGenericType.java  \n  \npublic class ReturnGenericType\u003cT extends HasF\u003e {  \n    private T obj;  \n  \n    ReturnGenericType(T x) {  \n        obj = x;  \n    }  \n  \n    public T get() {  \n        return obj;  \n    }  \n  \n}\n```\n\n### 代价\n\n擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、 instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了，当你在编写 泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。\n考虑如下的代码段：\n\n```java\nclass Foo\u003cT\u003e {  \n    T var;  \n}\n```\n\n```java\nFoo\u003cCat\u003e f = new Foo\u003c\u003e();\n```\n\n看上去当你创建一个 Foo 实例时：class Foo 中的代码应该知道现在工作于 Cat 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：\"不，这只是一个 **Object**\"。\n\n### 时机\n\n泛型的所有动作都发生在边 界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住： “边界就是动作发生的地方”。\n\n对比泛型和非泛型的两段代码对应的字节码：\n\n非泛型：\n\n```java\n// generics/SimpleHolder.java  \n  \npublic class SimpleHolder {  \n    private Object obj;  \n  \n    public void set(Object obj) {  \n        this.obj = obj;  \n    }  \n  \n    public Object get() {  \n        return obj;  \n    }  \n  \n    public static void main(String[] args) {  \n        SimpleHolder holder = new SimpleHolder();  \n        holder.set(\"Item\");  \n        // 需要手动类型转换\n        String s = (String) holder.get();  \n    }  \n  \n}\n```\n\n非泛型字节码：\n\n```java\npublic void set(java.lang.Object);  \n        0: aload_0  \n        1: aload_1  \n        2: putfield #2; // Field obj:Object;  \n        5: return  \n  \npublic java.lang.Object get();  \n        0: aload_0  \n        1: getfield #2; // Field obj:Object;  \n        4: areturn  \n  \npublic static void main(java.lang.String[]);  \n        0: new #3; // class SimpleHolder  \n        3: dup  \n        4: invokespecial #4; // Method \"\u003cinit\u003e\":()V  \n        7: astore_1  \n        8: aload_1  \n        9: ldc #5; // String Item  \n        11: invokevirtual #6; // Method set:(Object;)V  \n        14: aload_1  \n        15: invokevirtual #7; // Method get:()Object;  \n        18: checkcast #8; // class java/lang/String  \n        21: astore_2  \n        22: return\n```\n\n泛型：\n\n```java\n// generics/GenericHolder2.java  \n  \npublic class GenericHolder2\u003cT\u003e {  \n    private T obj;  \n  \n    public void set(T obj) {  \n        this.obj = obj;  \n    }  \n  \n    public T get() {  \n        return obj;  \n    }  \n  \n    public static void main(String[] args) {  \n        GenericHolder2\u003cString\u003e holder = new GenericHolder2\u003c\u003e();  \n        holder.set(\"Item\"); \n        // 使用了泛型，这里不用手动类型转换了 \n        String s = holder.get();  \n    }  \n  \n}\n```\n\n泛型字节码：\n\n```java\npublic void set(java.lang.Object);  \n        0: aload_0  \n        1: aload_1  \n        2: putfield #2; // Field obj:Object;  \n        5: return  \n  \npublic java.lang.Object get();  \n        0: aload_0  \n        1: getfield #2; // Field obj:Object;  \n        4: areturn  \n  \npublic static void main(java.lang.String[]);  \n        0: new #3; // class GenericHolder2  \n        3: dup  \n        4: invokespecial #4; // Method \"\u003cinit\u003e\":()V  \n        7: astore_1  \n        8: aload_1  \n        9: ldc #5; // String Item  \n        11: invokevirtual #6; // Method set:(Object;)V  \n        14: aload_1  \n        15: invokevirtual #7; // Method get:()Object;  \n        18: checkcast #8; // class java/lang/String  \n        21: astore_2  \n        22: return\n```\n\n两个代码所产生的字节码是相同的。\n对进入 set() 的类型进行检查是不需要的，因为这将由编译器执行。而对 get() 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由**编译器自动插入**。\nget() 和 set() 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边 界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住： “边界就是动作发生的地方”。\n\n## 边界\n\n由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 Object 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。\n为了应用约束，Java 泛型使用了 extends 关键字。\n\n## 数组协变\n\n在了解通配符之前，先来了解一下数组。Java 中的数组是[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/协变|协变]]的，什么意思？看下面的例子：\n\n```java\nclass Fruit {}\nclass Apple extends Fruit {}\nclass Jonathan extends Apple {}\nclass Orange extends Fruit {}\n\npublic class CovariantArrays {\n    public static void main(String[] args) {       \n        Fruit[] fruit = new Apple[10];\n        fruit[0] = new Apple(); // OK\n        fruit[1] = new Jonathan(); // OK\n        // Runtime type is Apple[], not Fruit[] or Orange[]:\n        try {\n            // Compiler allows you to add Fruit:\n            fruit[0] = new Fruit(); // ArrayStoreException\n        } catch(Exception e) { System.out.println(e); }\n        try {\n            // Compiler allows you to add Oranges:\n            fruit[0] = new Orange(); // ArrayStoreException\n        } catch(Exception e) { System.out.println(e); }\n        }\n} /* Output:\njava.lang.ArrayStoreException: Fruit\njava.lang.ArrayStoreException: Orange\n*///:~\n```\n\n`main` 方法中的第一行，创建了一个 `Apple` 数组并把它赋给 `Fruit` 数组的引用。这是有意义的，`Apple` 是 `Fruit` 的子类，一个 `Apple` 对象也是一种 `Fruit` 对象，所以一个 `Apple` 数组也是一种 `Fruit` 的数组。这称作**数组的协变**，Java 把数组设计为协变的，对此是有争议的，有人认为这是一种缺陷。\n\n尽管 `Apple[]` 可以 “向上转型” 为 `Fruit[]`，但数组元素的实际类型还是 `Apple`，我们只能向数组中放入 `Apple`或者 `Apple` 的子类。在上面的代码中，向数组中放入了 `Fruit` 对象和 `Orange` 对象。对于编译器来说，这是可以通过编译的，但是在运行时期，JVM 能够知道数组的实际类型是 `Apple[]`，所以当其它对象加入数组的时候就会抛出异常。\n\n泛型设计的目的之一是要使这种运行时期的错误在编译期就能发现，看看用泛型容器类来代替数组会发生什么：\n\n```java\n// Compile Error: incompatible types:\nArrayList\u003cFruit\u003e flist = new ArrayList\u003cApple\u003e();\n\n```\n\n上面的代码根本就无法编译。当涉及到泛型时， 尽管 `Apple` 是 `Fruit` 的子类型，但是 `ArrayList\u003cApple\u003e` 不是 `ArrayList\u003cFruit\u003e` 的子类型，泛型不支持协变。\n\n## 通配符\n\n从上面我们知道，`List\u003cNumber\u003e list = ArrayList\u003cInteger\u003e` 这样的语句是无法通过编译的，尽管 `Integer` 是 `Number` 的子类型。那么如果我们确实需要建立这种 “向上转型” 的关系怎么办呢？这就需要通配符来发挥作用了。\n\n### 上边界\n\n\u003e 所有对象都当作是T\n\u003e 主要是用来处理泛型方法的返回值，返回的东西当作是T类型对待\n\n利用 `\u003c? extends Fruit\u003e` 形式的通配符，可以实现泛型的向上转型：\n\n```java\npublic class GenericsAndCovariance {\n    public static void main(String[] args) {\n        // Wildcards allow covariance:\n        List\u003c? extends Fruit\u003e flist = new ArrayList\u003cApple\u003e();\n        // Compile Error: can’t add any type of object:\n        // flist.add(new Apple());\n        // flist.add(new Fruit());\n        // flist.add(new Object());\n        flist.add(null); // Legal but uninteresting\n        // We know that it returns at least Fruit:\n        Fruit f = flist.get(0);\n    }\n}\n```\n\n`flist` 的类型可以看作是List\u003c某个继承了Fruit的类型\u003e。\n注意不是指这个list里可以**同时**放不同的Fruit子类，而是指flist可以指向指定边界内的List\u003c\u003e对象。\n\n无法传递对象了：加了界限，但又不完全确定到底是哪个具体类，导致无法向其中添加任意元素，甚至Object都不可以，只能添加null。\n\n### 下边界\n\n\u003e 所有对象起码是个T\n\u003e 主要是处理向泛型方法传递参数，所有传入的对象起码是个T，或者是T的子类。\n\n\u003e 超类型通配符。\n\u003e 逆变。\n\n通配符的另一个方向是　“超类型的通配符“: `? super T`，`T` 是类型参数的下界。使用这种形式的通配符，我们就可以 ”传递对象” 了。还是用例子解释：\n\n```java\npublic class SuperTypeWildcards {\n    static void writeTo(List\u003c? super Apple\u003e apples) {\n        apples.add(new Apple());\n        apples.add(new Jonathan());\n        // apples.add(new Fruit()); // Error\n    }\n}\n```\n\n`writeTo` 方法的参数 `apples` 的类型是 `List\u003c? super Apple\u003e`，它表示某种类型的 List，我们不知道实际类型是什么，但是这个类型肯定是 `Apple` 的父类型。因此，我们可以知道向这个 List 添加一个 `Apple` 或者其子类型的对象是安全的，这些对象都可以**向上**转型为 `Apple`。但是我们不知道加入 `Fruit` 对象是否安全，因为那样会使得这个 List 添加跟 `Apple` 无关的类型。\n\n### 利用上下边界面向泛型类型进行读取和写入\n\n如何向泛型类型中 “写入” ( 传递对象给方法参数) 以及如何从泛型类型中 “读取” ( 从方法中返回对象 )。下面是一个例子：\n\n```java\npublic class Collections { \n  public static \u003cT\u003e void copy(List\u003c? super T\u003e dest, List\u003c? extends T\u003e src) \n  {\n      for (int i=0; i\u003csrc.size(); i++) \n        dest.set(i,src.get(i)); \n  } \n}\n```\n\n`src` 是原始数据的 List，因为要从这里面读取数据，所以用了上边界限定通配符：`\u003c? extends T\u003e`，取出的元素转型为 `T`。`dest` 是要写入的目标 List，所以用了下边界限定通配符：`\u003c? super T\u003e`，可以写入的元素类型是 `T` 及其子类型。\n\n### 无边界\n\n还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：`List\u003c?\u003e`，也就是没有任何限定。不做任何限制，和`\u003c? extends Object\u003e`效果一样。\n\n跟不用类型参数的 `List` 有什么区别呢？\n`List\u003c?\u003e list` 表示 `list` 是持有某种特定类型的 List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然**不可以**，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。\n而单独的 `List list` ，也就是没有传入泛型参数，表示这个 list 持有的元素的类型是 `Object`，因此**可以**添加任何类型的对象，只不过编译器会有警告信息。\n\n\u003e List`\u003c?\u003e`里面的元素，如果你取出来，会都被转化为Object。\n\u003e 加了`\u003c?\u003e`那么会把返回值自动转换为Object。\n\u003e 不加则需要自己手动转换。\n\n## 总结\n\n通配符的使用可以对泛型参数做出某些限制，使代码更安全，对于上边界和下边界限定的通配符总结如下：\n\n- 使用 `List\u003c? extends C\u003e list` 这种形式，表示 list 可以引用一个 `ArrayList` ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素类型是 `C` 的子类型 ( 包含 `C` 本身）的一种。\n- 使用 `List\u003c? super C\u003e list` 这种形式，表示 list 可以引用一个 `ArrayList` ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素就类型是 `C` 的超类型 ( 包含 `C` 本身 ) 的一种。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6":{"title":"访问控制符","content":"# 访问控制符\n\n![[z-oblib/z2-attachments/v2-315cda6274202d57b75be7641eba442f_1440w.png]]\n\n## public\n\n- 可以被所有其它类访问。\n\n## private\n\n- 只能被自己访问。\n\n## protected\n\n- 只能被自身、子类、同属一个包的其他类访问。\n\t- 在同一个包相当于public。\n\n## default\n\n- 默认修饰符（friendly）。\n- 只能被自身、同属一个包的其他类访问。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/final":{"title":"final","content":"# final\n\n\u003e final是可被继承的，这点和static不同。\n\n## 修饰类\n\n**不可继承**\n\n当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n\n## 修饰方法\n\n**不可重写**\n\n\u003e使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。\n\u003e--摘自《Java编程思想》第四版第143页\n\n- 如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。\n- 类的private方法会隐式地被指定为final方法。\n\n## 修饰变量\n\n**不可变**\n\n- 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改\n- 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n\n但是和static不同，final在声明时不进行初始化，但是后续只能给给未初始化的final变量赋值一次。再次赋值会报错。\n\n\n## 原理\n\n```java\npublic class TestFinal {\n    final int a = 20;\n}\n```\n\n字节码：\n\n```java\n0: aload_0\n1: invokespecial #1                  // Method java/lang/Object.\"\u003cinit\u003e\":()V\n4: aload_0\n5: bipush        20\n7: putfield      #2                  // Field a:I\n    \u003c-- 写屏障\n10: return\n```\n\n发现 ﬁnal 变量的赋值也会通过 putﬁeld 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况\n\n### 设置final\n\n理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了\n\n### 获取final\n\n\nstatic变量的读取会用getstatic访问共享内存\n而final static变量的读取，会把值赋值一份，避免共享：\n- 变量较小则赋复制到当前线程的栈空间。\n- 变量较大则复制到常量区。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/static":{"title":"static","content":"# static\n\n父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95":{"title":"三色标记算法","content":"# 三色标记算法\n\n## 解决的问题\n\nCMS垃圾回收机制下，对象标记线程和用户线程同时执行，用户线程会影响标记准确度，导致：\n1. 浮游垃圾问题\n\t1. 该问题不同特别在意，因为浮动垃圾会在下次GC时被清理。\n2. 错误回收问题\n\t1. 该问题要特别在意，因为回收了一个正在使用的对象是严重的BUG。\n\n## 解决思路\n\n通过广度优先算法扫描gc树上的节点，并用黑色标记已经扫描完成的节点，灰色标记正在扫描的节点，白的未扫描的节点，达到性质：\n1. 黑色节点的所有子节点都应该是灰色节点。\n2. 所有白色节点都是垃圾。\n\n因为**黑色节点是已经扫描完成的，不会再处理**，所以若用户线程把白色节点接入黑色节点就会产生错误：该白色节点不应该被回收但不会再变色了。\n\n## 问题产生条件\n\n我们将用户线程针对对象引用的操作成为赋值（修改应用或者置null），则有：\n1. 赋值器插入了若干条 **黑色 --\u003e 白色** 的新引用。\n2. 赋值器删除了针对某白色节点的所有 **灰色 --\u003e 白色** 的引用。\n\t1. 可能该白色节点就是垃圾。\n\t2. 赋值器可能接下来会把白色节点接入黑色节点，进入情况1。\n\n## 解决方案\n\n只要打破上述两种情况的任意一种即可，则对应有两种解决方案：\n\n### 增量更新\n\n通过“写屏障”（类似AOP），记录用户将白色节点链到黑色节点的操作。重新标记阶段就会根据该记录以这部分黑色节点为根再扫描一次。\n\n### 原始快照\n\n在用户线程断开灰白间引用关系前加入“写屏障”，将这个要删除的引用记录下来。发扫描结束之后，再将这些记录过得引用关系中的灰色对象为根，重新扫描一次。\n\n### 总结\n\n原始快照关注的是引用删除，增量更新关注的是引用增加。\n使用增量更新算法，那变成灰色的对象还要重新扫描一遍，效率太低了，所以G1在处理并发标记的过程比CMS效率要高，这个主要是解决漏标的算法决定的。\n因此G1不采用增量更新。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86":{"title":"动态代理","content":"# 动态代理\n\n## 案例\n\n```java\npublic class DynamicProxySample {\n\n    interface Greet {\n        Object sayHello(String name);\n    }\n\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"method: \" + method.getName());\n                return args[0];\n            }\n        };\n\n        Greet proxy = (Greet) Proxy.newProxyInstance(Greet.class.getClassLoader(), new Class[]{Greet.class}, handler);\n        System.out.println(proxy.sayHello(\"creativeworkes\"));\n    }\n}\n```\n\n\u003e 关键问题：为什么调用`proxy.sayHello`，自动会将代理类的方法和被代理类的方法关联起来？\n\n## 基本流程\n\n\u003e https://blog.csdn.net/cicada_smile/article/details/118280698\n\n1. 动态生成一个类，这个类伪装成实现了某个接口的样子。\n2. 实现中实际调用的是InvocationHandler对象的invoke方法。\n3. InvocationHandler是一个拦截器，拦截器只声明额外的动作，不会指定拦截目标。\n\t1. 拦截器实际上会拦截掉所有函数，只是你可以在拦截器里做判断，遇到特定函数才做特定操作。\n4. Proxy.newProxyInstance(目标类加载器，目标接口，拦截器)会根据前两个参数**动态生成一个代理类**，并实例化代理类同时将拦截器传递给代理对象。\n\t1. 代理类实际上是一个Proxy对象，只是额外还实现了目标接口。\n\t2. **代理类里面会重写所有目标接口的方法，用拦截器.invoke(原始方法)**\n5. 调用代理类.method()实际上是调用了h.invoke(method())\n6. method传入拦截器后，就可以根据原始方法函数名等信息进行逻辑处理，同时也可以调用原始方法。\n\nJDK动态代理**只能代理接口**，因为自动生成的对象会实现目标接口（伪装成目标接口的指定的样子），伪装的时候会“实现接口的方法”，而方法里实际调用的是 InvocationHandler 对象的invoke方法，InvocationHandler 可以理解成拦截器，通过Java反射对传入对象的指定方法进行拦截。**invoke方法是对某一实现目标接口的类的对象方法的重新包装。**\n\nJDK动态代理模式里有个拦截器，在JDK中，只要实现了**InvocationHandler**接口的类就是一个**拦截器类**。\n\n假如写了个请求到action，经过拦截器，然后才会到action，执行后续操作。 拦截器就像一个过滤网，一层层过滤，只有满足一定条件，才能继续向后执行。 **拦截器的作用**：控制目标对象的目标方法的执行。\n\n拦截器的具体操作步骤：\n\n1. 引入类 目标类和一些扩展方法相关的类\n2. 赋值 调用构造器，给相关对象赋值\n3. 合并逻辑处理 在invoke方法中把所有的逻辑结合在一起。最终决定目标方法是否被调用\n\n### 解释用例\n\n目标接口：\n```java\npackage com.mgg.styproxy;  \n  \npublic interface TargetInterface {  \n    void business();  \n}\n```\n\n目标类：\n```java\npackage com.mgg.styproxy;  \n  \npublic class TargetObject implements TargetInterface{  \n    @Override  \n    public void business() {  \n        System.out.println(\"business\");  \n    }  \n}\n```\n\n拦截器及使用：\n```java\npackage com.mgg.styproxy;  \n  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Method;  \nimport java.lang.reflect.Proxy;  \n  \npublic class MyInterceptor implements InvocationHandler {  \n\t// 被代理对象\n    private Object target;  \n    public MyInterceptor(Object target) {this.target = target;}  \n  \n    // 调用对象target的指定方法实际是调用了这里，本例是business() \n    @Override  \n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  \n        System.out.println(\"before calling \" + method);  \n        method.invoke(this.target, args);  \n        System.out.println(\"after calling \" + method);  \n        return null;    }  \n  \n    public static void main(String[] args) {  \n        TargetObject target = new TargetObject();  // 目标对象  \n        MyInterceptor myInterceptor = new MyInterceptor(target);  // 拦截掉目标对象的方法  \n        TargetInterface proxyObj = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), myInterceptor);  // 代理掉原来的对象，调用接口方法时会被指定的拦截器拦截。代理对象是由JVM动态生成的  \n        proxyObj.business();  // 这里实际上调用了myInterceptor.invoke()，在里面可能会再调用target的business方法。  \n  \n    }  \n}\n```\n\n## 源码解析\n\n很多同学对动态代理迷糊，在于`proxyObj.business();`理解错了，至少是被表面所迷惑，没有发现这个proxyObj和Proxy之间的联系，一度纠结最后调用的这个`business()`是怎么和`invoke()`联系上的，而invoke又怎么知道business存在的。\n\n其实上面的true和class $ Proxy0就能解决很多的疑问，再加上下面将要说的$ Proxy0的源码，完全可以解决动态代理的疑惑了。\n\n我们并没有显式调用invoke()，但是这个方法确实执行了。下面分析：\n\n从Client中的代码看，可以从newProxyInstance这个方法作为突破口，我们先来看一下Proxy类中newProxyInstance方法的源代码：\n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                      Class\u003c?\u003e[] interfaces,\n                                      InvocationHandler h) {\n    final Class\u003c?\u003e[] intfs = interfaces.clone();\n    final SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n    }\n\n    /*\n     * 查找或生成指定的代理类，从目标身上获取到对应的类加载器和接口\n     * 用对应的类加载器和接口创建代理类$Proxy0\n     * $Proxy0类实现了interfaces类型的接口,并继承了Proxy类\n     */\n    Class\u003c?\u003e cl = getProxyClass0(loader, intfs);\n\n    /*\n     * 使用指定的调用处理程序调用其构造器\n     */\n    try {\n        if (sm != null) {\n            checkNewProxyPermission(Reflection.getCallerClass(), cl);\n        }\n        // 形参为InvocationHandler类型的构造器\n        final Constructor\u003c?\u003e cons = cl.getConstructor(constructorParams);  // 获得目标类的构造函数\n        final InvocationHandler ih = h;\n        if (!Modifier.isPublic(cl.getModifiers())) {\n            AccessController.doPrivileged(new PrivilegedAction\u003cVoid\u003e() {\n                public Void run() {\n                    cons.setAccessible(true);\n                    return null;\n                }\n            });\n        }\n        return cons.newInstance(new Object[]{h});  // 创建类的实例并返回，同时传入拦截器\n    } ...\n}\n```\n\nProxy.newProxyInstance做了如下事：\n\n- 根据参数loader和interfaces调用方法 getProxyClass(loader, interfaces)创建代理类`$Proxy0`。`$Proxy0`类 实现了目标接口，并继承了Proxy类\n\t- loader参数是为了保证代理类和接口类由同一个加载器加载\n- 实例化`$Proxy0`，并在构造器把拦截器传过去，接着`$Proxy0`调用Proxy父类的构造器，为h赋值\n\n$Proxy0的源码：\n这个类是动态生成的\n```java\npackage com.sun.proxy;\n\npublic final class $Proxy0 extends Proxy implements TargetInterface {\n    private static Method m1;\n    private static Method m3;  // 被代理类的原始方法，本例会当作参数传给h.invoke()\n    private static Method m2;\n    private static Method m0;\n\n\t// newProxyInstance创建完类后进行实例化，同时传入拦截器\n    public $Proxy0(InvocationHandler var1) throws  {\n\t    // Proxy类的构造方法，接收一个InvocationHandler类型参数\n\t    // 主要工作就是给proxy.h赋值一个拦截器\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        }...\n    }\n\n\t// main中调用的实际是这个方法，而不是原目标中的方法了\n\t// 代理类生成的同名的方法拦截掉了目标方法\n    public final void business() throws  {\n        try {\n            super.h.invoke(this, m3, (Object[])null);\n        }...\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        }...\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        }...\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m3 = Class.forName(\"com.javaedge.design.pattern.structural.proxy.dynamicproxy.jdkdynamicproxy.TargetInterface\").getMethod(\"business\");\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        }...\n    }\n}\n```\n\n接着把得到的`$Proxy0`实例强转成TargetInterface，并将引用赋给TargetInterface。当执行proxyObj.business()，就调用了`$Proxy0`类中的business()方法，进而调用父类Proxy中的h的invoke()方法。即`InvocationHandler.invoke()`。\n\nProxy#getProxyClass返回的是Proxy的Class类，而非“被代理类的Class类”！\n\n## 总结\n\n上面是案例执行的过程和原理，还有一个关键点要明白，即JDK源码的逻辑：\n\n```java\nIUser proxyUser = (IUser) Proxy.newProxyInstance(classLoader,interfaces,userHandler);\n```\n\nProxy提供的静态方法`newProxyInstance()`，通过各个参数的传入，构建一个新的代理Class对象，即$Proxy0类的结构信息，这里再回首看下三个核心参数：\n\n- ClassLoader：基于JVM运行过程，所以需要获取目标类UserService的类加载器；\n    \n- Interfaces：目标类UserService实现的接口，从面向对象来考虑，接口与实现分离，代理类通过实现IUser接口，模拟目标类的需求；\n    \n- InvocationHandler：代理类提供的功能封装即UserHandler，可以在目标方法调用前后做增强处理；","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8D%8F%E5%8F%98":{"title":"协变","content":"# 协变\n\n子类型可以隐性的转换为父类型。\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE":{"title":"双亲委派","content":"# 双亲委派\n\n\u003e https://blog.csdn.net/weixin_36586120/article/details/117457014\n\n## 定义\n\n1. 类加载器加载一个类时，会先将其逐级上交给父级加载器尝试加载\n\t1. 父子关系不是继承维护，而是**组合**，每个类加载器都持有一个 `parent` 字段，指向父加载器。\n2. 父级加载器先检查是否已加载，再尝试递归上交\n3. 若无法处理再向下委派加载任务。\n\n![[z-oblib/z2-attachments/20210601230727770.png]]\n\n## 目的\n\n双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。\n\n## 破坏\n\n#TODO","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90":{"title":"对象内存构成","content":"# 对象内存构成\n\nJava 中通过 new 关键字创建一个类的实例对象，对象存于内存的堆中并给其分配一个内存地址。\n![[z-oblib/z2-attachments/Pasted image 20220428151815.png]]\n在 JVM 中，Java对象保存在堆中时，由以下三部分组成：\n-   **[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/对象头|对象头]]（object header）**：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。\n-   **实例数据（Instance Data）**：主要是存放类的数据信息，父类的信息，对象字段属性信息。\n-   **对齐填充（Padding）**：为了字节对齐，填充的数据，不是必须的。\n\n![[z-oblib/z2-attachments/Pasted image 20220428151834.png]]","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%A4%B4":{"title":"对象头","content":"# 对象头\n\n![[z-oblib/z2-attachments/Pasted image 20220428151706.png]]\n\n在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针。\n\n## 普通对象\n\n```text\n|--------------------------------------------------------------|\n|                     Object Header (64 bits)                  |\n|------------------------------------|-------------------------|\n|        Mark Word (32 bits)         |    Klass Word (32 bits) |\n|------------------------------------|-------------------------|\n```\n\n## 数组对象\n\n```text\n|------------------------------------------------------------------------------|\n|                               Object Header (96 bits)                        |\n|------------------------------|----------------------|------------------------|\n|       Mark Word(32bits)      |   Klass Word(32bits) |  array length(32bits)  |\n|------------------------------|----------------------|------------------------|\n```\n\n## Mark Word\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8":{"title":"对象的引用","content":"# 对象的引用\n\n| 引用类型  | 被垃圾回收时间  | 用途       | 生存时间       |\n|-------|----------|----------|------------|\n| 强引用   | 从来不会     | 对象的一般状态  | JVM停止运行时终止 |\n| 软引用   | 当内存不足时   | 对象缓存     | 内存不足时终止    |\n| 弱引用  | 正常垃圾回收时  | 对象缓存       | 垃圾回收后终止 |\n| 虚引用  | 正常垃圾回收时  | 跟踪对象的垃圾回收  | 垃圾回收后终止 |\n\n\n\u003e https://juejin.cn/post/6844903665241686029\n\n从`JDK 1.2`版本开始，对象的引用被划分为`4`种级别，从而使程序能更加灵活地控制**对象的生命周期**。这`4`种级别**由高到低**依次为：**强引用**、**软引用**、**弱引用**和**虚引用**。\n\n![[z-oblib/z2-attachments/16576be9ee015804~tplv-t2oaga2asx-zoom-in-crop-mark-1304-0-0-0.webp]]\n\n## 强引用\n\n**强引用**是使用最普遍的引用。如果一个对象具有强引用，那**垃圾回收器**绝不会回收它。如下：\n\n当**内存空间不足**时，`Java`虚拟机宁愿抛出`OutOfMemoryError`错误，使程序**异常终止**，也不会靠随意**回收**具有**强引用**的**对象**来解决内存不足的问题。 如果强引用对象**不使用时**，需要弱化从而使`GC`能够回收，如下：\n\n```java\n strongReference = null;\n```\n\n显式地设置`strongReference`对象为`null`，或让其**超出**对象的**生命周期**范围，则`gc`认为该对象**不存在引用**，这时就可以回收这个对象。具体什么时候收集这要取决于`GC`算法。\n\n```java\npublic void test() {\n\tObject strongReference = new Object();\n\t// 省略其他操作\n}\n```\n\n在一个**方法的内部**有一个**强引用**，这个引用保存在`Java`**栈**中，而真正的引用内容(`Object`)保存在`Java`**堆**中。 当这个**方法运行完成**后，就会退出**方法栈**，则引用对象的**引用数**为`0`，这个对象会被回收。\n\n但是如果这个`strongReference`是**全局变量**时，就需要在**不用这个对象时赋值为`null`**，因为**强引用**不会被垃圾回收。\n\n**ArrayList的Clear方法：**\n在`ArrayList`类中定义了一个`elementData`数组，在调用`clear`方法清空数组时，每个数组元素被赋值为`null`。 不同于`elementData=null`，强引用仍然存在，避免在后续调用`add()`等方法添加元素时进行内存的**重新分配**。 使用如`clear()`方法**内存数组**中存放的**引用类型**进行**内存释放**特别适用，这样就可以及时释放内存。\n![[z-oblib/z2-attachments/Pasted image 20220428164341.png]]\n\n## 软引用(SoftReference)\n\n如果一个对象只具有**软引用**，则**内存空间充足**时，**垃圾回收器**就**不会**回收它；如果**内存空间不足**了，就会**回收**这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n\n```java\n// 强引用\nString strongReference = new String(\"abc\");\n// 软引用\nString str = new String(\"abc\");\nSoftReference\u003cString\u003e softReference = new SoftReference\u003cString\u003e(str);\n```\n\n**软引用**可以和一个**引用队列**(`ReferenceQueue`)联合使用。如果**软引用**所引用对象被**垃圾回收**，`JAVA`虚拟机就会把这个**软引用**加入到与之关联的**引用队列**中。\n\n## 弱引用(WeakReference)\n\n**弱引用**与**软引用**的区别在于：只具有**弱引用**的对象拥有**更短暂**的**生命周期**。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有**弱引用**的对象，不管当前**内存空间足够与否**，都会**回收**它的内存。不过，由于垃圾回收器是一个**优先级很低的线程**，因此**不一定**会**很快**发现那些只具有**弱引用**的对象。\n\n  \n```java\n    String str = new String(\"abc\");\n    WeakReference\u003cString\u003e weakReference = new WeakReference\u003c\u003e(str);\n    str = null;\n```\n\n下面的代码会让一个**弱引用**再次变为一个**强引用**：\n\n```java\nString str = new String(\"abc\");\n    WeakReference\u003cString\u003e weakReference = new WeakReference\u003c\u003e(str);\n    // 弱引用转强引用\nString strongReference = weakReference.get();\n```\n\n## 虚引用(PhantomReference)\n\n**虚引用**顾名思义，就是**形同虚设**。与其他几种引用都不同，**虚引用**并**不会**决定对象的**生命周期**。如果一个对象**仅持有虚引用**，那么它就和**没有任何引用**一样，在任何时候都可能被垃圾回收器回收。\n\n**应用场景：**\n\n**虚引用**主要用来**跟踪对象**被垃圾回收器**回收**的活动。 **虚引用**与**软引用**和**弱引用**的一个区别在于：\n\n**虚引用必须和引用队列(ReferenceQueue)联合使用**。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99":{"title":"开闭原则","content":"# 开闭原则\n\n开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该**对扩展开放，对修改关闭**。\n\n## 闭合原则\n\n不想向外暴露的设置成final/private。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%B5%81":{"title":"流","content":"\n# 流\n\n## 基本概念\n\n\n流只是一个比喻。\n\n任何比喻都无法完美。\n\n流比喻数据的均匀连续性。\n\n你从水龙头接水，无论拿杯子，脸盘，还是桶。只要水流不断，你都可以接满。\n\n假设水龙头吐出的是大小不一的冰块，那就不叫连续了。\n\n当然，计算机最小单位是字节，所以流数据最小单位也是字节（byte)。当然可以通过写程序模拟以位(bit 每字节8位）为单位的bit流。\n\n模拟bit流多用在压缩算法。平常我们更多时候是需要连续的字节以某种方式组合起来读入或写出，比如以字符形式就是两个两个读（char，在java里是两个字节。）。看看jdk里有什xxxstream的类。\n\n你的问题是自我想像流一定是个管子。其实在计算机世界里，管子是管子，流是流。\n\n以文件流为比喻。你下载了1个G的某片，存在磁盘上总要占用一大块磁盘空间（物理上很可能是不连续的，但暂时想像它们是家里瓷盘上的一汪水）然后你凑过嘴，把嘴嘟起来，陶醉（假装）地吸上一口，字节带着细微的水花从你嘴唇穿入，这时候磁盘的一汪字节和你产生吸力的嘴之间，没有吸管，但真的有流。\n\n  \n\n你说嘴巴吸不了磁盘上的字节。你说甚至一G的文件在磁盘上很可能是分在不连续的扇区存储的，怎么有连续的流呢？\n\n  \n\n你说得很对。。。也许你看本地片子时，突然某处稍卡了一下，你怀疑是不是正好上个字节和下个字节之间 隔了几个扇区几个[磁道](https://www.zhihu.com/search?q=%E7%A3%81%E9%81%93\u0026search_source=Entity\u0026hybrid_search_source=Entity\u0026hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A44911601%7D)\n\n。。。但其实通常不是的。操作系统不会这么直接。它会趁你慢慢欣赏某些片段时，早就将数据从慢腾腾的磁盘预读到快如闪电的内存中了，这个位于磁盘和播放器程序之间的缓存区，是很像你说的管子，但它真的和流这个对象没有什么关系，在代码中的流对象看来 那缓存区就是操作系统提供的文件。\n\nJAVA代码是在[虚拟机](https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA\u0026search_source=Entity\u0026hybrid_search_source=Entity\u0026hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A44911601%7D)\n\n上跑的，所以在操作系统自带的缓存区这管子后面，可能还要再接一截虚拟机提供的管子。并且，看过净水机的广告吧？ 什么十八过滤芯层层净化，那就是JAVA虚拟机或运行时提供的，用于转换数据编码什么的。\n\n  \n\n流这个比喻的本质就是为了让某个对象可以均匀持续地吐出无间隔的数据，或者你可以向这个对象毫无压力地持续不断塞进数据。。。。至于那些管子。。。恰恰是因为现实世界不够符合这个要求，所以必须有。经典例子改成网上看超大的片子。我们希望网络是一个符合我们说的条件的流，它必须连续出数据，但它做不到，它卡卡卡的，太像是在咳嗽吐结石了……认真回答我，看片子很卡，你会有“流”的任何联想和感受吗。。怎么办？你先等等，操作系统已经准备了个长管子，帮你缓存一大段你再看，这回就很流很流的感觉了。\n\n  \n\n所以，管子什么的，那不是流，那是不得不要靠它们来装（装逼的装 不是装放的装）流的枝节。通常是伟大的C程序员们要管的事。\n\n最后有关网线。。。你要从公司回家，公司是A端，家是B端，你是数据，两个问题请回答：\n\n一，你回家不从任何路上经过，你闭上眼睛心里默念我要回家，然后就瞬间转移到家里出现了？？\n\n二，你拉开家门，你老婆会说：哟，从公司回来了呀？ 还是她很认真严谨地说：哟，从马路上回来了呀？\n\n再说三点：一，物理上你无法直接从公司转移到家，所以需要马路管子。二，你老婆关心以及认知你是从公司还是某些她不喜欢的店回来的，通常不关心你从哪条马路回来了。三，但你也不是一个流，除非哪天你有个孩子，并且孩子日志里写到：下午，爸爸陆陆续续地回来了。。。。。。。。。\n\n## java中的流\n\nJava所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。\n\n标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等，java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存中（供Java程序使用）的称为[输入流](https://www.zhihu.com/search?q=%E8%BE%93%E5%85%A5%E6%B5%81\u0026search_source=Entity\u0026hybrid_search_source=Entity\u0026hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)\n\n，将数据从内存写入外存中的称为[输出流](https://www.zhihu.com/search?q=%E8%BE%93%E5%87%BA%E6%B5%81\u0026search_source=Entity\u0026hybrid_search_source=Entity\u0026hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)\n\n。\n\n流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。\n\n流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。\n\n流的分类：\n\n流的分类，Java的流分类比较丰富，刚接触的人看了后会感觉很晕。流分类的方式很多：\n\n1、按照输入的方向分，输入流和输出流，输入输出的参照对象是Java程序。\n\n2、按照处理数据的单位不同分，字节流和[字符流](https://www.zhihu.com/search?q=%E5%AD%97%E7%AC%A6%E6%B5%81\u0026search_source=Entity\u0026hybrid_search_source=Entity\u0026hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A260699828%7D)\n\n，字节流读取的最小单位是一个字节（1byte=8bit），而字符流一次可以读取一个字符（1char = 2byte = 16bit）。\n\n3、按照功能的不同分，分节点流和处理流，节点流是直接从一个源读写数据的流（这个流没有经过包装和修饰），处理流是在对节点流封装的基础上的 一种流，FileInputStream是一个节点流，可以直接从文件读取数据，但是BufferedInputStream可以包装 FileInputStream，使得其有缓冲功能。\n\n流的类结构图：\n\n![[z-oblib/z2-attachments/20191013212051298.png]]\n\n![[z-oblib/z2-attachments/20191014111930276.png]]\n\nJava中“流”的概念与简介\n\n字节流与字符流：\n\n字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是**基于字节流读取时，去查了指定的码表**。 字节流和字符流的区别：\n\n读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n\n处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n\n结论：只要是处理纯文本数据，就优先考虑使用字符流。除此之外都使用字节流。\n\n这里需要提到的一句是：一个英文字符的长度是1byte，而汉字的长度是2byte. 如果我们把英汉混合的文档统一按照字节流处理，就会出现分割混乱，出现乱码。这是，我们需要使用字符流来处理。这就是为什么在处理文档的时候，都要把inputstream放到FileReader中。\n\n方向性：\n\n流分为输入流和输出流。但这都是相对的。特别是在Hadoop的序列化时，总是不知道到底使用输入流还是输出流。这里，我们可以做个区分：\n\n序列化，就是把数据做字节流处理。而字节流只是一种存储形式。他不会被程序识别，需要把字节流反序列化为java识别的对象，才可以被java程序识别。所以，序列化就是字节流化，就是从java代码或内存中输出到外存。而反序列化就是对象化，就是从外存中将字节流数据转化为程序识别的对象。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8":{"title":"类加载器","content":"# 类加载器\n\n## 简介\n\n一个可以将Java字节码加载为`java.lang.Class`实例的工具。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。\n\n## 特点\n\n- 动态加载，无需在程序一开始运行的时候加载，而是在程序运行的过程中，动态按需加载，字节码的来源也很多，压缩包jar、war中，网络中，本地文件等。类加载器动态加载的特点为热部署，热加载做了有力支持。\n- 全盘负责，当一个类加载器加载一个类时，这个类所依赖的、引用的其他所有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。所以破坏双亲委派不能破坏扩展类加载器以上的顺序。\n\n## 为何需要多个类加载器\n\n**思考以下情景：**\n\n1. **首先，是为了区分同名的类**：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 jvm 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？_当然是不同的应用都拥有自己独立的类加载器了。_\n2. **其次，是为了更方便的加强类的能力**：类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？_一个比较方便的模式就是每个类库都可以使用独立的类加载器_\n\n一个类的唯一性由加载它的类加载器和这个类的本身决定（类的全限定名+类加载器的实例ID作为唯一标识）。比较两个类是否相等（包括Class对象的`equals()`、`isAssignableFrom()`、`isInstance()`以及`instanceof`关键字等），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类就必定不相等。\n\njvm 需要有不同的类加载器，因为它一方面允许你在一个 jvm 里运行不同的应用程序，另一方面方便你独立的对不同类库进行运行时增强。\n\n## 分类\n\n从实现方式上，类加载器可以分为两种：一种是**启动类加载器**，由C++语言实现，是虚拟机自身的一部分；另一种是继承于`java.lang.ClassLoader`的类加载器，包括**扩展类加载器**、**应用程序类加载器**以及自定义类加载器。\n\n### 启动类加载器\n\n（`Bootstrap ClassLoader`）：负责加载`\u003cJAVA_HOME\u003e\\lib`目录中的，或者被`-Xbootclasspath`参数所指定的路径，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。**启动类加载器无法被Java程序直接引用**，用户在编写自定义类加载器时，如果想设置`Bootstrap ClassLoader`为其`parent`，**可直接设置null**。\n\n### 扩展类加载器\n\n（`Extension ClassLoader`）：负责加载`\u003cJAVA_HOME\u003e\\lib\\ext`目录中的，或者被`java.ext.dirs`系统变量所指定路径中的所有类库。该类加载器由`sun.misc.Launcher$ExtClassLoader`实现。扩展类加载器由启动类加载器加载，其父类加载器为启动类加载器，即`parent=null`。\n\n### 应用程序类加载器\n\n（`Application ClassLoader`）：负责加载用户类路径（`ClassPath`）上所指定的类库，由`sun.misc.Launcher$App-ClassLoader`实现。开发者可直接通过`java.lang.ClassLoader`中的`getSystemClassLoader()`方法获取应用程序类加载器，所以也可称它为系统类加载器。应用程序类加载器也是启动类加载器加载的，但是它的父类加载器是扩展类加载器。在一个应用程序中，系统类加载器一般是默认类加载器。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF":{"title":"组合优于继承","content":"# 组合优于继承\n\n\u003e 1. Program to an interface, not an implementation. (面向接口编程，而不是具体的实现)  \n\u003e   \n\u003e 2. Favor object composition over class inheritance.（如果某个场景的代码复用既可以通过类继承实现， 也可以通过对象组合实现， 尽量选择对象组合的设计方式）\n\n第一个原则的好处非常明显： 可以极大程度地减少子系统具体实现之间的相互依赖。  \n第二个原则则不那么容易理解， 下面展开叙述 。\n\n## 组合和继承的区别\n\n| 组合           | 继承                        |\n|--------------|---------------------------|\n| has-a        | is-a                      |\n| 不破坏封装        | 破坏封装，子类依赖父类               |\n| 支持扩展，随意增加组合类 | 只能继承一个父类，必须包含所有方法，增加系统复杂性 |\n\n- 通过**继承**实现的代码复用常常是一种“**白盒复用**”， 这里的白盒指的是可见性： 对于继承来说，父类的内部实现对于子类来说是不透明的（实现一个子类时， 你需要了解父类的实现细节， 以此决定是否需要重写某个方法）。\n- 对象**组合**实现的代码复用则是一种“**黑盒复用**”: 对象的内部细节不可见，对象仅仅是以“黑盒”的方式出现（可以通过改变对象引用来改变其行为方式）。\n\n## 判断是继承还是组合\n\n所以不难发现， 当我们拿**类继承**和**组合**在一起进行对比时， 并不是以实现方式中是否有用到类继承而区分的。\n\n我们真正关注的是**行为的继承**与**行为的组合** ：需要变化的行为是通过 **继承后重写的方式** 实现， 还是通过 **赋予不同的行为实例** 实现。\n\n## 继承优缺点\n\n### 优点\n\n- 类之间的继承关系时在编译时刻静态地定义好的， 因此使用起来也非常直观， 毕竟继承是被编程语言本身所支持的功能。\n- 类继承也使得修改要重用的代码变得相对容易， 因为可以仅仅重写要更改的父类方法。\n\n### 缺点\n\n- 第一个缺点是伴随第一个优点而生的： 没有办法在运行时刻改变继承了父类的子类行为。\n- 第二个缺点与第一个缺点相比往往更严重： 通过继承实现的代码复用，本质上把父类的内部实现细节暴露给了子类， 子类的实现会和父类的实现紧密的绑定在一起， 结果是父类实现的改动，会导致子类也必须得改变。\n\n#### 继承如何破坏封装性\n\n```java\npublic class A {\n    //方法功能是说话\n    public void say() {\n        //一堆说话的实现细节\n    }\n    //方法功能是唱歌\n    public void song() {\n        //具体的实现细节\n        // 注意这里，唱歌的前提要先说话，所以调用自身的say()方法\n        say();\n        //然后一堆唱歌的实现细节\n    }\n}\n```\n\n```java\npublic class B extends A{\n    @Override\n    public void say() {\n        //我就想再说话之前先告诉大家一声我要说话了\n        System.out.println(\"我要开始说话了\");\n        super.say();\n    }\n\n    @Override\n    public void song() {\n        //我就想再唱歌之前先告诉大家一声我要唱歌了\n        System.out.println(\"我要开始唱歌了\");\n        super.song();\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        //现在我要高歌一首\n        b.song();\n    }\n}\n\n```\n\n结果：\n```\n我要开始唱歌了\n我要开始说话了\n```\n\n出现了只想唱歌但是说话了的问题。我明明就是想唱歌呀，为啥又说我开始说话了，  \n其实是因为类B继承了类A ，在类A中的song实现细节中用了say()方法，导致在类B中先走了song()方法，又走了say()方法，但是对于类B来说我不想知道你走了啥方法，我就是想要的功能而已，唱歌就是唱歌，说话就是说话。当然我们也可以将类A中的song()方法改成不调用say()方法，但是这个不应该和类A的实现细节有关系啊，我只是提供了我的API接口，功能不变的情况下，我的内部实现细节怎么变都应该是没有问题的啊，所以这就是继承暴漏了API的实现细节出现的问题。\n\n## 组合的缺点\n\n- 不具备之前所罗列的类继承的优点。\n\n## 用组合替代继承\n\n而复合就不会有这样的问题了,把类A做为一个私有域放入类B中。再调用类A的song()方法：\n\n```java\npublic class B {\n    private A a;\n\n    public B(A a) {\n        this.a = a;\n    }\n    public void say() {\n        System.out.println(\"我要开始说话了\");\n        a.say();\n    }\n\n    public void song() {\n        System.out.println(\"我要开始唱歌了\");\n        a.song();\n    }\n    \n    public static void main(String[] args) {\n        B b = new B(new A());\n        //现在我要高歌一首\n        b.song();\n    }\n}\n\n```\n\n```\n我要开始唱歌了\n```\n\n可以看出复合屏蔽了类的实现细节，专注于功能而不关注细节。\n\n## 总结\n\n所以继承要严格的遵循is-a的关系，否则不能瞎用继承，在用继承的时候想好继承是不是只是为了扩展功能。否则就不得不用复合来代替继承了。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8":{"title":"迭代器","content":"# 迭代器\n\n- 迭代器是一个用于保存状态的类，状态是指一个可迭代对象当前的遍历情况，例如可迭代对象元素量，当前迭代指针等。\n- 迭代器主要是通过内部类实现，比如ArrayList内部有个Iterator类，这样iterator可以通过ArrayList.this访问到外部类的内容，最重要的是访问到外部类中存储的具体数据。\n- 迭代器设计上降低了空间开销（维护指针信息而不用复制原数据），保证了与原数据的一致性（如果是复制则可能造成与原数据不一致）。\n- iterator()方法会返回一个可迭代对象内部的迭代器实例。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86":{"title":"静态代理","content":"# 静态代理\n\n## 概述\n\n1. 代理类实现目标接口\n2. 代理类在内部实例化一个被代理类的对象\n3. 代理类重写目标方法，加入修改的逻辑，并可以调用被代理类的对象的方法\n\n## 案例\n\n```java\npublic class StaticProxySample {\n    interface Greet {\n        void sayHello(String name);\n    }\n\n    static class GreetImpl implements Greet {\n        @Override\n        public void sayHello(String name) {\n            System.out.println(\"Hello \" + name);\n        }\n    }\n\n    static class GreetProxyImpl implements Greet {\n\n        private Greet greet = new GreetImpl();\n\n        @Override\n        public void sayHello(String name) {\n            this.greet.sayHello(name);\n        }\n    }\n\n    public static void main(String[] args) {\n        Greet proxy = new GreetProxyImpl();\n        proxy.sayHello(\"creativeworkes\");\n    }\n}\n```\n\n可以看到**Greetmpl**实现了**Greet**接口，同时**GreetProxyImpl**也实现了**Greet**接口，并且持有**GreetImpl**对象的实例，这就是静态代理的典型实现。**GreetProxyImpl**实例代理了**GreetImpl**的功能，这里的缺点就很明显，只要**Greet**有新的功能添加，**GreetImpl**和**GreetProxyImpl**类都要实现，不同的是**GreetProxyImpl**使用了**GreetImpl**类的实现，这样的实现耦合度非常高，对后期拓展来说是非常不友好的，所以接下来说说动态代理是怎样的，以及如何解决刚才遇到的问题。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/HashMap":{"title":"HashMap","content":"\n# HashMap\n\n## 并发问题\n\n### JDK7并发死链\n\n```java\npublic static void main(String[] args) {\n    // 测试 java 7 中哪些数字的 hash 结果相等\n    System.out.println(\"长度为16时，桶下标为1的key\");\n    for (int i = 0; i \u003c 64; i++) {\n        if (hash(i) % 16 == 1) {\n            System.out.println(i);\n        }\n    }\n    System.out.println(\"长度为32时，桶下标为1的key\");\n    for (int i = 0; i \u003c 64; i++) {\n        if (hash(i) % 32 == 1) {\n            System.out.println(i);\n        }\n    }\n    // 1, 35, 16, 50 当大小为16时，它们在一个桶内\n    final HashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();\n    // 放 12 个元素\n    map.put(2, null);\n    map.put(3, null);\n    map.put(4, null);\n    map.put(5, null);\n    map.put(6, null);\n    map.put(7, null);\n    map.put(8, null);\n    map.put(9, null);\n    map.put(10, null);\n    // 下面三个会放在一个桶中\n    map.put(16, null);\n    map.put(35, null);\n    map.put(1, null);\n \n    System.out.println(\"扩容前大小[main]:\"+map.size());\n    new Thread() {\n        @Override\n        public void run() {\n            // 放第 13 个元素, 发生扩容\n            map.put(50, null);\n            System.out.println(\"扩容后大小[Thread-0]:\"+map.size());\n        }\n    }.start();\n    new Thread() {\n        @Override\n        public void run() {\n            // 放第 13 个元素, 发生扩容\n            map.put(50, null);\n            System.out.println(\"扩容后大小[Thread-1]:\"+map.size());\n        }\n    }.start();\n}\n \nfinal static int hash(Object k) {\n    int h = 0;\n    if (0 != h \u0026\u0026 k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n    h ^= k.hashCode();\n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);\n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);\n}\n```\n\n#### 死链复现\n\n调试工具使用 idea\n在 HashMap 源码 590 行加断点\n```java\nint newCapacity = newTable.length;\n```\n断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来：\n```java\nnewTable.length==32 \u0026\u0026 \n    (\n        Thread.currentThread().getName().equals(\"Thread-0\")||\n        Thread.currentThread().getName().equals(\"Thread-1\")\n    )\n```\n断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行\n运行代码，程序在预料的断点位置停了下来，输出：\n```\n长度为16时，桶下标为1的key \n1 \n16 \n35 \n50 \n长度为32时，桶下标为1的key \n1 \n35 \n扩容前大小[main]:12 \n```\n接下来进入扩容流程调试\n在 HashMap 源码 594 行加断点\n```java\nEntry\u003cK,V\u003e next = e.next; // 593\nif (rehash)              // 594\n// ...\n```\n这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件Thread.currentThread().getName().equals(\"Thread-0\")）\n这时可以在 Variables 面板观察到 e 和 next 变量，使用 view as -\u003e Object 查看节点状态\n```\ne (1)-\u003e(35)-\u003e(16)-\u003enull \nnext (35)-\u003e(16)-\u003enull \n```\n在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成\n```\nnewTable[1]  (35)-\u003e(1)-\u003enull\n扩容后大小:13\n```\n这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为\n```\ne (1)-\u003enull \nnext (35)-\u003e(1)-\u003enull \n```\n为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结果正确，但它结束后 Thread-0 还要继续运行\n接下来就可以单步调试（F8）观察死链的产生了\n下一轮循环到 594，将 e 搬迁到 newTable 链表头\n```\nnewTable[1]     (1)-\u003enull \ne (35)-\u003e(1)-\u003enull \nnext (1)-\u003enull \n```\n下一轮循环到 594，将 e 搬迁到 newTable 链表头\n```\nnewTable[1] (35)-\u003e(1)-\u003enull \ne (1)-\u003enull \nnext null \n```\n再看看源码\n```java\ne.next = newTable[1];\n// 这时 e  (1,35)\n// 而 newTable[1] (35,1)-\u003e(1,35) 因为是同一个对象\n \nnewTable[1] = e;  \n// 再尝试将 e 作为链表头, 死链已成\n \ne = next;\n// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了\n```\n\n#### 源码分析\n\n```java\n// 将 table 迁移至 newTable\nvoid transfer(Entry[] newTable, boolean rehash) {    \n    int newCapacity = newTable.length;\n    for (Entry\u003cK,V\u003e e : table) {\n        while(null != e) {\n            Entry\u003cK,V\u003e next = e.next;\n            // 1 处\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            // 2 处\n            // 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n```\n原始链表，格式：[下标] (key,next)\n[1] (1,35)-\u003e(35,16)-\u003e(16,null)\n \n线程 a 执行到 1 处 ，此时局部变量 e 为 (1,35)，而局部变量 next 为 (35,16) 线程 a 挂起\n \n线程 b 开始执行（构建扩容后的新链表）\n第一次循环\n[1] (1,null)\n \n第二次循环\n[1] (35,1)-\u003e(1,null)\n \n第三次循环\n[1] (35,1)-\u003e(1,null)\n[17] (16,null)\n \n切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (1,null)，而 next 的内\n容被改为 (35,1) 并链向 (1,null)\n第一次循环\n[1] (1,null)\n \n第二次循环，注意这时 e 是  (35,1) 并链向 (1,null) 所以 next 又是 (1,null)\n[1] (35,1)-\u003e(1,null)\n \n第三次循环，e 是 (1,null)，而 next 是 null，但 e 被放入链表头，这样 e.next 变成了 35 （2 处）\n[1] (1,35)-\u003e(35,1)-\u003e(1,35)\n链表出现循环\n已经是死链了\n```\n\n### 总结\n\n1. JDK7的HashMap桶链表采用头插法，新节点会成为链表的头节点。\n2. 在扩容过程中，遍历旧链表构造新链表的时候采用头插法，会导致链表倒序排列，顺序与原链表不一致。（头插法有逆序操作，会修改节点的next指针，两个线程同时扩容就会读取到异常的next值造成环的出现）。\n3. 两个线程同时触发扩容且一个线程先完成扩容遍历，第二个线程只获取到了头节点和头节点.next两个节点。\n4. 第二个线程继续执行时，手上的两个节点已经被第一个线程改掉，先后关系反了，但第二个线程不知道还以为是原来的顺序。\n5. 第二个线程继续按原顺序对链表扩容，遍历构造新链表时出现了环。\n\n- 究其原因，是因为在多线程环境下使用了非线程安全的 map 集合\n- JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JMM":{"title":"JMM","content":"# JMM\n\n## 简介\n\nJMM 即 Java Memory Model，它定义了**主存**、**工作内存**抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。\nJMM 体现在以下几个方面：\n- 原子性 - 保证指令不会受到线程上下文切换的影响\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]] - 保证指令不会受 cpu 缓存的影响\n- 有序性 - 保证指令不会受 cpu 指令并行优化的影响\n\n## JMM的抽象示意图\n\n![[z-oblib/z2-attachments/JMM抽象示意图.jpg]]\n\n从图中可以看出：\n1. 所有的共享变量都存在主内存中。\n2. 每个[[3-计算机科学/2-计算机组成原理/线程|线程]]都保存了一份该线程使用到的共享变量的副本。\n3. 如果线程A与线程B之间要通信的话，必须经历下面2个步骤：\n    1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去。\n    2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。\n\n- **线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取**。\n- **JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证**。\n\n\u003e Java中的[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]关键字可以保证多线程操作共享变量的可见性以及禁止指令[[3-计算机科学/2-计算机组成原理/指令重排序|重排序]]，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。\n\n### JMM与Java内存区域划分的区别与联系\n\n#### 区别\n\n两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。\n\n#### 联系\n\n都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。\n\n### 数据竞争与顺序一致性\n\n当程序未正确同步的时候，就可能存在数据竞争。\n\n\u003e 数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。\n\n如果程序中包含了数据竞争，那么运行的结果往往充满了**不确定性**，比如读发生在了写之前，可能就会读到错误的值；如果一个线程程序能够正确同步，那么就不存在数据竞争。\n\nJava内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：\n\n\u003e **如果程序是正确同步的，程序的执行将具有顺序一致性**。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。\n\n这里的同步包括了使用`volatile`、`final`、`synchronized`等关键字来实现**多线程下的同步**。\n\n如果程序员没有正确使用`volatile`、`final`、`synchronized`，那么即便是使用了同步（单线程下的同步），JMM也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。\n\n所以如何正确使用`volatile`、`final`、`synchronized`，是程序员应该去了解的。后面会有专门的章节介绍这几个关键字的内存语义及使用。\n\n## JMM中同步程序的顺序一致性效果\n\n在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是JMM中，**临界区内**（同步块或同步方法中）的代码可以发生[[3-计算机科学/2-计算机组成原理/指令重排序|重排序]]（但**不允许临界区内的代码“逃逸”到临界区之外**，因为会破坏锁的内存语义）。\n\n虽然线程A在临界区做了重排序，但是因为锁的特性，线程B无法观察到线程A在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。\n\n同时，JMM会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。\n\n**由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门**。\n\n## JMM中未同步程序的顺序一致性效果\n\n对于未同步的多线程程序，JMM只提供**最小安全性**：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。\n\n为了实现这个安全性，**JVM在堆上分配对象时，首先会对内存空间清零**，然后才会在上面分配对象（这两个操作是同步的）。\n\nJMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。\n\n未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异：\n1. 顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果）\n2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）\n3. 顺序一致性模型保证对所有的内存读写操作都具有原子性，而**JMM不保证对64位的long型和double型变量的写操作具有原子性**。\n\n## 可见性vs原子性\n\n两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错：\n```java\n// 假设i的初始值为0 \ngetstatic     i  // 线程2-获取静态变量i的值 线程内i=0 \n \ngetstatic     i  // 线程1-获取静态变量i的值 线程内i=0 \niconst_1         // 线程1-准备常量1 \niadd             // 线程1-自增 线程内i=1 \nputstatic     i  // 线程1-将修改后的值存入静态变量i 静态变量i=1 \n \niconst_1         // 线程2-准备常量1 \nisub             // 线程2-自减 线程内i=-1 \nputstatic     i  // 线程2-将修改后的值存入静态变量i 静态变量i=-1 \n```\n\n\u003e注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低\n\u003e如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JVM%E7%9A%84%E6%A0%88%E5%B8%A7":{"title":"JVM的栈帧","content":"\n# JVM的栈帧\n\n栈帧（Stack [Frame](https://so.csdn.net/so/search?q=Frame\u0026spm=1001.2101.3001.7020)）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机**运行时**数据区中的虚拟机栈的栈元素。\n\n栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。\n\n每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在[虚拟机](https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA\u0026spm=1001.2101.3001.7020)里面从入栈到出栈的过程。\n\n\u003e 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了。\n\u003e \n\u003e 因此一**个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响**，而仅仅取决于具体的虚拟机实现。\n\n## 局部变量表\n\n局部变量表（Local Variable Table）是一组变量值存储空间，用于存放**方法参数**和方法内部定义的**局部变量**。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。\n\n## 动态连接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支付方法调用过程中的动态连接（Dynamic Linking）。\n\n在类加载阶段中的解析阶段会将符号引用转为直接引用，这种转化也称为静态解析。另外的一部分将在每一次运行时期转化为直接引用。这部分称为动态连接。\n\n## 返回地址\n\n当一个方法开始执行后，只有2种方式可以退出这个方法 ：\n\n- 方法返回指令 ： 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口。\n- 异常退出 ： 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。\n\n\n无论采用任何退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息。\n\n\u003e 一般来说，方法正常退出时，**调用者**的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值。\n\u003e 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。\n\n## 操作数栈\n\n操作数栈主要用于保存计算过程的中间结果。\n\n操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。\n\n操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B":{"title":"Java内存模型","content":"# Java内存模型\n\n## 运行时内存的划分\n\n![[z-oblib/z2-attachments/Java运行时数据区.png]]\n对于每一个[[3-计算机科学/2-计算机组成原理/线程|线程]]来说，**栈都是私有的**，而**堆是公有的**。\n\n也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量，内存的可见性针对的是**共享变量**。\n\n### 既然堆是共享的，为什么在堆中会有内存不可见?\n\n这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。\n\u003e 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。\n\nJava线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/JMM#JMM的抽象示意图|JMM的抽象示意图]]。\n## 一个例子\n\n\u003e https://www.bilibili.com/video/BV16J411h7Rd?p=21\u0026t=575.8\n\n![[z-oblib/z2-attachments/Pasted image 20220526104910.png]]\n\n1. 初始化时会将类加载到方法区。\n2. jvm启动main方法作为主线程。\n3. main线程栈中包含：\n\t1. 程序计数器：指向下一句要执行的代码地址。\n\t2. [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/JVM的栈帧|栈帧]]：每次调用其它函数都会生成一个运行时栈帧。\n4. 每次调用一个方法，就会在main线程栈中创建一个目标方法的栈帧。\n5. 局部变量可以指向堆空间的数组或者是对象。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Mark-Word":{"title":"Mark Word","content":"# Mark Word\n\n用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、[[3-计算机科学/2-计算机组成原理/线程|线程]]持有的锁、偏向线程ID、偏向时间戳等等。\n\nMark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。我们打开[openjdk的源码包](https://download.java.net/openjdk/jdk8/promoted/b132/openjdk-8-src-b132-03_mar_2014.zip)，对应路径`/openjdk/hotspot/src/share/vm/oops`，Mark Word对应到C++的代码`markOop.hpp`，可以从注释中看到它们的组成，本文所有代码是基于Jdk1.8。\n\nMark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：\n\n![[z-oblib/z2-attachments/1162587-20200918154115022-312986152.png]]\n\n在64位JVM中是这么存的：\n\n![[z-oblib/z2-attachments/1162587-20200918154125385-1537793659.png]]\n\n虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。\n\n\u003e 注意上述结构不是每一行都同时存在，而是根据锁标志位来决定当前行的状态。\n\u003e 例如在重量级锁状态下，当对象获取到Mointer的时，会先复制并暂存无锁态对应的信息，将信息覆写为Mointer地址。当释放锁后，会恢复无锁态对应数据。\n\n- **锁标志位（lock）**：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。\n- **biased_lock**：是否[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/偏向锁|偏向锁]]，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。\n- **分代年龄（age）**：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。\n- **对象的hashcode（hash）**：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。\n- **偏向锁的线程ID（JavaThread）**：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。\n- **epoch**：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。\n- **ptr_to_lock_record**：[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]操作在对象的标题字中设置指向锁记录的指针。\n- **ptr_to_heavyweight_monitor**：[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]状态下，指向对象监视器[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|Monitor]]的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/SPI":{"title":"SPI","content":"# SPI\n\nSPI 全称为Service Provider Interface，是一种**服务发现机制**。SPI 的本质是**将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类**。\n\n简单点说SPI就是 JDK 内置的一个服务发现机制，它使得接口和具体实现完全解耦。我们只声明接口，具体的实现类在配置中选择。\n\n具体的就是你定义了一个接口，然后在`META-INF/services`目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。\n\n这样就通过配置来决定具体用哪个实现！","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/lambda":{"title":"lambda","content":"# lambda\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/safepoint":{"title":"safepoint","content":"# safepoint\n\n## 什么是safepoint\n\nsafepoint可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。\n\n从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。\n\n## 什么地方可以放safepoint\n\n下面以Hotspot为例，简单的说明一下什么地方会放置safepoint  \n1. 理论上，在解释器的每条字节码的边界都可以放一个safepoint，不过挂在safepoint的调试符号信息要占用内存空间，如果每条机器码后面都加safepoint的话，需要保存大量的运行时数据，所以要尽量少放置safepoint，在safepoint会生成polling代码询问VM是否要“进入safepoint”，polling操作也是有开销的，polling操作会在后续解释。\n\n2. 通过JIT编译的代码里，会在所有方法的返回之前，以及所有非counted loop的循环（无界循环）回跳之前放置一个safepoint，为了防止发生GC需要STW时，该线程一直不能暂停。另外，JIT编译器在生成机器码的同时会为每个safepoint生成一些“调试符号信息”，为GC生成的符号信息是OopMap，指出栈上和寄存器里哪里有GC管理的指针。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/stream":{"title":"stream","content":"# stream\n\n## OJ中的应用\n\n将内容读取成string，再按照空格分割出字符串数组，再通过stream将字符串数组转成int数组。\n\n```java\npublic class P5788 {  \n    public static void main(String[] args) throws IOException {  \n        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));  \n  \n        int n = Integer.parseInt(buf.readLine());  \n        int[] array;  \n  \n        String str = buf.readLine();  \n        array = Arrays.stream(str.split(\" \")).mapToInt(Integer::parseInt).toArray();  \n  \n        int[]res = new int[n];  \n  \n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();  \n        for (int i=0; i\u003carray.length; i++) {  \n            while (!stack.isEmpty() \u0026\u0026 array[stack.peek()] \u003c array[i]) {  \n                int cur = stack.pop();  \n                res[cur] = i+1;  \n            }  \n            stack.push(i);  \n        }  \n  \n        for (int re : res) System.out.print(re + \" \");  \n    }  \n}\n```","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/volatile":{"title":"volatile","content":"# volatile\n\n\u003e https://ifeve.com/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97/\n\n## 内存可见性问题\n\n```java\nA = 0;\nB = 0;\nT0 {\n\tA = 1;\n\tprint(B);\n}\n\nT1 {\n\tB = 1;\n\tprint(A);\n}\n\n```\n这样一段代码可能会出现下列四种输出：\n\n| 情况1  | 情况2  | 情况3  | 情况4  |\n|------|------|------|------|\n| 读A   | 读A   | 写A   | 写A   |\n| 读B   | 写B   | 写B   | 读B   |\n| 写A   | 写A   | 读A   | 读A   |\n| 写B   | 读B   | 读B   | 写B   |\n| A0B0 | A0B1 | A1B1 | A1B0 |\n\n在读上加入内存屏障即可保证**在一个线程中**写操作发生在读操作之前，但是若线程1先执行完毕线程2才执行，就会导致线程1无法读取到B的值，所以需要让两个线程同步：\n\n1. 用标志位来告知A B变量有没有被写入过\n2. 写过后设置标志位\n3. 标志位的写前插入屏障     \n4. 读之前自旋判断对应标志位\n\n\n## 作用\n\n保证：\n- 内存可见性\n\t- 读写一定是从主内存中获得，而不是本地内存\n- 内存有序性\n\t- 读写操作按一定的顺序执行，不会因为指令重排而乱序\n\n\u003e无法保证原子性。\n\n## JVM限制重排序的方式\n\n\u003e禁止重排序实际上不是禁止了cpu指令级别的重排序、乱序执行、双射等操作，而是控制内存的访问顺序。编译器指令防止加载/存储操作在源代码中跨行重新排序，但是允许编译器对任意一侧的内存访问或同一侧的其他访问进行重新排序，这可能意味着使用专用指令停止内核的运行，直至确保所有先前的内存访问对系统中的其他代理可见。代理是系统中能够启动总线事务的任何设备——例如处理器或DMA控制器。屏障影响加载-存储（`load-store`）指令顺序的例子：\n\u003e![[z-oblib/z2-attachments/Pasted image 20220531012444.png]]\n\n1. volatile变量执行**写**操作，会在写之前插入StoreStore Barriers**写屏障**，在执行volatile变量写之前的所有Store操作都已执行，数据同步到了内存中（将store buffer中的store操作刷新到内存）；在写之后插入StoreLoad Barriers，代表该volatile变量的写操作也会立即刷新到内存中，其他线程会看到最新值；  \n2. volatile变量执行**读**操作，会在读之前插入LoadLoad Barriers**读屏障**，代表在执行volatile变量读之前的所有Load从内存中获取最新值；在读之后插入LoadStore Barriers，代表该读取volatile变量获得是内存中最新的值；\n\n### 如何保证可见性\n\n#### 写屏障\n\n写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中\n```java\npublic void actor2(I_Result r) {\n    num = 2;\n    ready = true; // ready 是 volatile 赋值带写屏障\n    // 写屏障\n}\n```\n\n#### 读屏障\n\n而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据\n```java\npublic void actor1(I_Result r) {\n    // 读屏障\n    // ready 是 volatile 读取值带读屏障\n    if(ready) {\n        r.r1 = num + num;\n    } else {\n        r.r1 = 1;\n    }\n}f\n```\n![[z-oblib/z2-attachments/Pasted image 20220531142019.png]]\n\n\n### 如何保证有序性\n\n写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n```java\npublic void actor2(I_Result r) {\n    num = 2;\n    ready = true; // ready 是 volatile 赋值带写屏障\n    // 写屏障\n}\n```\n读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n```java\npublic void actor1(I_Result r) {\n    // 读屏障\n    // ready 是 volatile 读取值带读屏障\n    if(ready) {\n        r.r1 = num + num;\n    } else {\n        r.r1 = 1;\n    }\n}\n```\n![[z-oblib/z2-attachments/Pasted image 20220531143810.png]]\n\n## 原理\n\n用[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式#双重校验锁|单例模式双重校验锁]]的例子展开：\n\n```java\n// -------------------------------------\u003e 加入对 INSTANCE 变量的读屏障\n0: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n3: ifnonnull     37\n6: ldc           #3                  // class cn/itcast/n5/Singleton\n8: dup\n9: astore_0\n10: monitorenter -----------------------\u003e 保证原子性、可见性\n11: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n14: ifnonnull     27\n17: new           #3                  // class cn/itcast/n5/Singleton\n20: dup\n21: invokespecial #4                  // Method \"\u003cinit\u003e\":()V\n24: putstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n// -------------------------------------\u003e 加入对 INSTANCE 变量的写屏障\n27: aload_0\n28: monitorexit ------------------------\u003e 保证原子性、可见性\n29: goto          37\n32: astore_1\n33: aload_0\n34: monitorexit\n35: aload_1\n36: athrow\n37: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n40: areturn\n```\n\n如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：\n- 可见性\n\t- 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中\n\t- 而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据\n- 有序性\n\t- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\n\t- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\n- 更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性\n![[z-oblib/z2-attachments/Pasted image 20220531154956.png]]\n\n## volatile并不总是可行的\n\n**不能解决指令交错**：\n- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去。\n- 而有序性的保证也只是保证了本线程内相关代码不被重排序S。\n- \n## volatile的用途\n\n从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。\n\n在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个**临界区代码**的执行具有原子性。所以**在功能上，锁比volatile更强大；在性能上，volatile更有优势**。\n\n在禁止重排序这一点上，volatile也是非常有用的。比如我们熟悉的[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式|单例模式]]，其中有一种实现方式是“[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式#线程安全的实现|双重锁]]检查”，比如这样的代码：\n\n```java\npublic class Singleton {\n\n    private static Singleton instance; // 不使用volatile关键字\n\n    // 双重锁检验\n    public static Singleton getInstance() {\n        if (instance == null) { // 第7行\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton(); // 第10行\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：\n\n```java\ninstance = new Singleton(); // 第10行\n\n// 可以分解为以下三个步骤\n1 memory=allocate();// 分配内存 相当于c的malloc\n2 ctorInstanc(memory) //初始化对象\n3 s=memory //设置s指向刚分配的地址\n\n// 上述三个步骤可能会被重排序为 1-3-2，也就是：\n1 memory=allocate();// 分配内存 相当于c的malloc\n3 s=memory //设置s指向刚分配的地址\n2 ctorInstanc(memory) //初始化对象\n```\n\n而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！\n\n所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。\n\n## 何时使用volatile\n\n正如我前面所说，如果两个线程同时读写一个共享变量，仅仅使用volatile关键字是不够的。你应该使用 [synchronized](http://tutorials.jenkov.com/java-concurrency/synchronized.html) 来保证读写变量是原子的。（一个线程）读写volatile变量时，不会阻塞（其他）线程进行读写。你必须在关键的地方使用synchronized关键字来解决这个问题。\n\n除了synchronized方法，你还可以使用[java.util.concurrent](http://tutorials.jenkov.com/java-util-concurrent/index.html)包提供的许多原子数据类型来解决这个问题。比如，[AtomicLong](http://tutorials.jenkov.com/java-util-concurrent/atomiclong.html)或[AtomicReference](http://tutorials.jenkov.com/java-util-concurrent/atomicreference.html)，或是其他的类。\n\n如果只有一个线程对volatile进行读写，而其他线程只是读取变量，这时，对于只是读取变量的线程来说，volatile就已经可以保证读取到的是变量的最新值。如果没有把变量声明为volatile，这就无法保证。\n\nvolatile关键字对32位和64位的变量都有效。\n\n## volatile的性能考量\n\n读写volatile变量会**导致变量从主存读写**。从主存读写比从CPU缓存读写更加“昂贵”。访问一个volatile变量同样会**禁止指令重排**，而指令重排是一种提升性能的技术。因此，你应当只在需要保证变量可见性的情况下，才使用volatile变量。\n\n\n\n假设两个全局变量A和B，初始值都是0，线程0对A写入了1，线程1对B写入了1，然后线程0读B，线程1读B，他们分别读到的A和B分别可能是几，列出所有可能的排列组合。\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98":{"title":"一致性缓存","content":"# 一致性缓存\n\n使用读写锁实现一个简单的按需加载缓存：\n\n```java\nclass GenericCachedDao\u003cT\u003e {\n    // HashMap 作为缓存非线程安全, 需要保护\n    // 这里对读写都加锁了，所以可以继续使用HashMap\n    HashMap\u003cSqlPair, T\u003e map = new HashMap\u003c\u003e();\n    \n    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    \n    GenericDao genericDao = new GenericDao();\n \n    public int update(String sql, Object... params) {\n        SqlPair key = new SqlPair(sql, params);\n        // 加写锁, 防止其它线程对缓存读取和更改\n        lock.writeLock().lock();\n        try {\n\t        // 更新数据\n            int rows = genericDao.update(sql, params);\n            // 清空缓存\n            map.clear();\n            return rows;\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n \n    public T queryOne(Class\u003cT\u003e beanClass, String sql, Object... params) {\n        SqlPair key = new SqlPair(sql, params);\n        // 加读锁, 防止其它线程对缓存更改\n        lock.readLock().lock();\n        try {\n\t        // 缓存命中则直接返回\n            T value = map.get(key);\n            if (value != null) {\n                return value;\n            }\n        } finally {\n            lock.readLock().unlock();\n        }\n        // 注意，加写锁前必须释放掉读锁\n        // 加写锁, 防止其它线程对缓存读取和更改\n        lock.writeLock().lock();\n        try {\n            // get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据\n            // 为防止重复查询数据库, 再次验证（双重验证）\n            T value = map.get(key);\n            if (value == null) {\n                // 如果没有, 查询数据库\n                value = genericDao.queryOne(beanClass, sql, params);\n                // 更新缓存\n                map.put(key, value);\n            }\n            return value;\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n \n    // 作为 key 保证其是不可变的\n    // 组合sql语句和查询参数\n    class SqlPair {\n        private String sql;\n        private Object[] params;\n \n        public SqlPair(String sql, Object[] params) {\n            this.sql = sql;\n            this.params = params;\n        }\n \n        @Override\n        public boolean equals(Object o) {\n\n            if (this == o) {\n            return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            SqlPair sqlPair = (SqlPair) o;\n            return sql.equals(sqlPair.sql) \u0026\u0026\n                    Arrays.equals(params, sqlPair.params);\n        }\n \n        @Override\n        public int hashCode() {\n            int result = Objects.hash(sql);\n            result = 31 * result + Arrays.hashCode(params);\n            return result;\n        }\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87":{"title":"上下文","content":"# 上下文\n\n上下文是指某一时间点 CPU 寄存器和程序计数器的内容。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2":{"title":"上下文切换","content":"# 上下文切换\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/上下文|上下文]]切换（有时也称做进程切换或任务切换）是指 CPU 从一个[[3-计算机科学/2-计算机组成原理/进程|进程]]（或[[3-计算机科学/2-计算机组成原理/线程|线程]]）切换到另一个进程（或线程）。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%B0%8F%E7%BB%93":{"title":"不可变小结","content":"# 不可变小结\n\n- 不可变类使用\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/不可变设计|不可变设计]]\n- 原理方面\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/0-语法基础/final|ﬁnal]]\n- 模式方面\n\t- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/享元模式|享元模式]]","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1":{"title":"不可变设计","content":"# 不可变设计\n\n以String类为例：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n \n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    // ...\n    \n}\n```\n\n## final的使用\n\n发现该类、类中所有属性都是 ﬁnal 的\n- 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改\n- 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，**防止子类无意间破坏不可变性**\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/保护性拷贝|保护性拷贝]]","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F":{"title":"两阶段终止模式","content":"# 两阶段终止模式\n\nTwo Phase Termination\n\n## 要优雅\n\n[[3-计算机科学/2-计算机组成原理/线程|线程]]T1优雅的终止线程T2，指的是给T2一个料理后事的机会。\n\n## 错误思路\n\n- 使用线程对象的stop()停止线程：\n\t- stop方法会真正杀死线程会强制释放CPU资源和锁，但是不能保证清理工作完整（如关闭文件/连接等），会导致数据不同步等问题，不安全。已弃用。\n- 使用System.exit(int)方法停止线程：\n\t- 目的是停止一个线程，但是会让整个程序都停止。\n\n## 使用打断标记实现\n\n### 例-系统状态定时监控\n\n需要有停止监控的功能：\n\n![[z-oblib/z2-attachments/Pasted image 20220526162938.png]]\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \n@Slf4j  \npublic class Test4TPT {  \n    public static void main(String[] args) throws InterruptedException {  \n        TwoPhaseTermination tpt = new TwoPhaseTermination();  \n        tpt.start();  \n  \n        Thread.sleep(3500);  \n        tpt.stop();  \n    }  \n}  \n  \n@Slf4j  \nclass TwoPhaseTermination {  \n    private Thread monitor;  \n  \n    public void start() {  \n        monitor = new Thread(()-\u003e{  \n            while (true) {  \n                Thread current = Thread.currentThread();  \n                if (current.isInterrupted()) {  \n                    log.debug(\"料理后事\");  \n                    break;                }  \n                try {  \n                    Thread.sleep(1000);  \n                    log.debug(\"正在监控\");  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                    current.interrupt();  // 重新设置打断标记  \n                }  \n            }  \n        });  \n        monitor.start();  \n    }  \n  \n    public void stop() {  \n        monitor.interrupt();  \n    }  \n}\n```\n\n## 使用volatile实现","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%AD%E6%96%AD":{"title":"中断","content":"# 中断\n\n线程中断即线程运行过程中被其他线程给打断了。\n\n## 原理\n\n- 中断无法直接终止另一[[3-计算机科学/2-计算机组成原理/线程|线程]]，只能发起通知。\n- 中断需要被中断线程自己处理。\n- 每个对象有一boolean标识是否有中断请求（来自其它线程/自身）。\n\t- 线程 t1 想中断线程 t2，只需要在线程 t1 中将线程 t2 对象的中断标识置为 true，然后线程 t2 可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。\n\njava.lang.Thread 类提供了几个方法来操作这个中断状态，这些方法包括：\n- `public static boolean interrupted()`：测试**当前**线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n- `public boolean isInterrupted()`：测试**目标**线程（由具体Thread实例决定）是否已经中断。线程的中断状态不受该方法的影响。\n- `public void interrupt()`：中断**目标**线程，给目标线程发一个中断信号，线程被打上中断标记即将中断状态设置为true。\n\n### 响应中断\n\n假设某个线程要不停地处理某件事情(比如 i 一直自增)，但是还有个要求：在处理事情前，先要检查下这个线程是否被中断，如果已经被中断，处理就应该结束。\n\n下面是一些例子：\n```java\npublic class Run {\n \n    public static void main(String[] args) {\n        try {\n            MyThread thread = new MyThread();\n            thread.start();\n            Thread.sleep(20);//modify 2000 to 20\n            thread.interrupt();//请求中断MyThread线程\n        } catch (InterruptedException e) {\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n        System.out.println(\"end!\");\n    }\n}\n```\nmain线程睡眠20ms后，执行第8行中断MyThread线程：\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i \u003c 500000; i++) {\n            if (this.interrupted()) {\n                System.out.println(\"should be stopped and exit\");\n                break;\n            }\n            System.out.println(\"i=\" + (i + 1));\n        }\n        System.out.println(\"this line is also executed. thread does not stopped\");//尽管线程被中断,但并没有结束运行。这行代码还是会被执行\n    }\n}\n```\n当MyThread获得CPU执行时，第6行的 if 测试中，检测到中断标识被设置。即MyThread线程检测到了main线程想要中断它的 请求。\n\n大多数情况下，MyThread检测到了中断请求，**对该中断的响应是：退出执行（或者说是结束执行）。**\n\n但是，上面第5至8行for循环，是执行break语句跳出for循环。但是，线程并没有结束，它只是跳出了for循环而已，它还会继续执行第12行的代码....\n\n**因此，我们的问题是，当收到了中断请求后，如何结束该线程呢？**\n\n一种可行的方法是使用 return 语句 而不是 break语句。。。。。哈哈。。。\n\n**当然，一种更优雅的方式则是：抛出InterruptedException异常。**\n\n看下面MyThread类的代码：\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try{\n            for (int i = 0; i \u003c 500000; i++) {\n                if (this.interrupted()) {\n                    System.out.println(\"should be stopped and exit\");\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"this line cannot be executed. cause thread throws exception\"); //这行语句不会被执行!!!\n        }catch(InterruptedException e){\n            System.out.println(\"catch interrupted exception\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于**System.out.println语句没有锁**。考虑到这样的情况：线程1在执行完put/take操作后立即失去CPU时间片，然后切换到线程2执行put/take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put/take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。\n\n### 线程池中使用阻塞队列\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                           int maximumPoolSize,\n                           long keepAliveTime,\n                           TimeUnit unit,\n                           BlockingQueue\u003cRunnable\u003e workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0":{"title":"任务调度线程池","content":"# 任务调度线程池\n\n用来代替[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Timer|Timer]]。\n\n## ScheduledExecutorService\n\n```java\nScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n// 添加两个任务，希望它们都在 1s 后执行\nexecutor.schedule(() -\u003e {\n    System.out.println(\"任务1，执行时间：\" + new Date());\n    try { Thread.sleep(2000); } catch (InterruptedException e) { }\n}, 1000, TimeUnit.MILLISECONDS);\nexecutor.schedule(() -\u003e {\n    System.out.println(\"任务2，执行时间：\" + new Date());\n}, 1000, TimeUnit.MILLISECONDS);\n```\n\n## scheduleAtFixedRate\n\n```java\nScheduledExecutorService executor = Executors.newScheduledThreadPool(2);\n// 添加两个任务，希望它们都在 1s 后执行\nexecutor.schedule(() -\u003e {\n    System.out.println(\"任务1，执行时间：\" + new Date());\n    try { Thread.sleep(2000); } catch (InterruptedException e) { }\n}, 1000, TimeUnit.MILLISECONDS);\nexecutor.schedule(() -\u003e {\n    System.out.println(\"任务2，执行时间：\" + new Date());\n}, 1000, TimeUnit.MILLISECONDS);\n```\n\n## scheduleAtFixedRate\n\n间隔时间从前一次任务启动开始计算。\n\n```java\nScheduledExecutorService pool = Executors.newScheduledThreadPool(1);\nlog.debug(\"start...\");\npool.scheduleAtFixedRate(() -\u003e {\n    log.debug(\"running...\");\n}, 1, 1, TimeUnit.SECONDS);\n```\n\n```\n21:45:43.167 c.TestTimer [main] - start... \n21:45:44.215 c.TestTimer [pool-1-thread-1] - running... \n21:45:45.215 c.TestTimer [pool-1-thread-1] - running... \n21:45:46.215 c.TestTimer [pool-1-thread-1] - running... \n21:45:47.215 c.TestTimer [pool-1-thread-1] - running... \n```\n\n任务超过执行时间时，会挤占间隔时间，但不会重叠执行：\n\n```java\nScheduledExecutorService pool = Executors.newScheduledThreadPool(1);\nlog.debug(\"start...\");\npool.scheduleAtFixedRate(() -\u003e {\n    log.debug(\"running...\");\n    sleep(2);\n}, 1, 1, TimeUnit.SECONDS);\n```\n\n```java\n21:44:30.311 c.TestTimer [main] - start... \n21:44:31.360 c.TestTimer [pool-1-thread-1] - running... \n21:44:33.361 c.TestTimer [pool-1-thread-1] - running... \n21:44:35.362 c.TestTimer [pool-1-thread-1] - running... \n21:44:37.362 c.TestTimer [pool-1-thread-1] - running... \n```\n\n## scheduleWithFixedDelay\n\n间隔时间是从前一次任务结束开始计算，而不是前一次任务启动开始计算。\n\n```java\nScheduledExecutorService pool = Executors.newScheduledThreadPool(1);\nlog.debug(\"start...\");\npool.scheduleWithFixedDelay(()-\u003e {\n    log.debug(\"running...\");\n    sleep(2);\n}, 1, 1, TimeUnit.SECONDS);\n```\n\n输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束 \u003c-\u003e 延时 \u003c-\u003e 下一个任务开始 所 以间隔都是 3s：\n\n```java\n21:40:55.078 c.TestTimer [main] - start... \n21:40:56.140 c.TestTimer [pool-1-thread-1] - running... \n21:40:59.143 c.TestTimer [pool-1-thread-1] - running... \n21:41:02.145 c.TestTimer [pool-1-thread-1] - running... \n21:41:05.147 c.TestTimer [pool-1-thread-1] - running... \n```\n\n\n## 总结\n\n整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%85%B1%E4%BA%AB":{"title":"伪共享","content":"\n# 伪共享\n\n\u003e 给数据加填充让数组的每个元素在缓存中强制换行，将cpu缓存中的数据拆分成多行，防止数据挨在一起后被连坐导致缓存集体失效。\n\n因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。\n而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中。\nCPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效，降低效率。\n\n![[z-oblib/z2-attachments/Pasted image 20220602143831.png]]\n\n因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：\n- Core-0 要修改 Cell[0]\n- Core-1 要修改 Cell[1]\n\n无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效。\n\n## 解决\n\n`@sun.misc.Contended` 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效。\n\n![[z-oblib/z2-attachments/Pasted image 20220602143930.png]]\n\n#TODO ","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D":{"title":"保护性拷贝","content":"# 保护性拷贝\n\n\u003e 先复制到本地，再做修改\n\n使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例：\n\n```java\npublic String substring(int beginIndex) {\n\t// 边界检查\n    if (beginIndex \u003c 0) {\n        throw new StringIndexOutOfBoundsException(beginIndex);\n    }\n    int subLen = value.length - beginIndex;\n    if (subLen \u003c 0) {\n        throw new StringIndexOutOfBoundsException(subLen);\n    }\n\n\t// new一个String\n    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n}\n```\n\n发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 ﬁnal char[] value 做出 了修改：\n\n```java\npublic String(char value[], int offset, int count) {\n    if (offset \u003c 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count \u003c= 0) {\n        if (count \u003c 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset \u003c= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    if (offset \u003e value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    // 复制值\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n```\n\n结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%81%8F%E5%90%91%E9%94%81":{"title":"偏向锁","content":"# 偏向锁\n\n## 存在缘由\n\n轻量级锁在没有竞争时，每次[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁#获取锁|在5.2重入锁时]]都要重复执行[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]操作，例如：\n```java\nstatic final Object obj = new Object();\npublic static void m1() {\n    synchronized( obj ) {\n        // 同步块 A\n        m2();\n    }\n}\npublic static void m2() {\n    synchronized( obj ) {\n        // 同步块 B\n        m3();\n    }\n}\npublic static void m3() {\n    synchronized( obj ) {\n\t    // 同步块 C\n    }\n}\n```\n\n对应轻量级锁：\n\n![[z-oblib/z2-attachments/Pasted image 20220527220040.png]]\n\n对应偏向锁：\n\n![[z-oblib/z2-attachments/Pasted image 20220527220054.png]]\n\njava6中引入偏向锁来进一步优化：\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。\n\n## 偏向状态\n\n一个对象创建时：\n- 如果开启了偏向锁（默认开启），在 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 中，偏向锁的锁标志位仍然是01，偏向锁标志位1 --\u003e Mark Word后三位为101。\n- 初始状态 thread、epoch、age都为0。\n- 偏向锁是默认是**延迟**的（4秒），不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟。\n\t\u003e 因为JVM在启动期间会采取大量安全点来消除偏差。这跟偏向锁有啥关系？说下我的理解哈，不一定是JVM工程师设计此的初衷。安全点大家应该是很熟悉了，启用安全点会带来STW。而偏向锁的撤销与重偏向判断，也是需要启用安全点的，因为需要扫描所有线程的虚拟机栈，需要内存静止才能保证结果准确。而JVM在启动期间用到的锁，包括初始化很多类的过程中用的锁，都会经过偏向锁逻辑，如果没有偏向延迟，就会带来更多的STW，导致JVM启动时间过长。\n- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值。\n- 测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁。\n\n## 偏向锁获取过程\n\n- 访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。\n- 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。\n- 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。\n- 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。\n- 执行同步代码。\n\n![[z-oblib/z2-attachments/偏向锁2.png]]\n\n## 偏向锁的释放\n\n![[z-oblib/z2-attachments/偏向锁.png]]\n\n偏向锁的撤销在上述第四步骤中有提到。偏向锁只有**遇到其他线程尝试竞争偏向锁**时，持有偏向锁的线程才会释放锁，**线程不会主动去释放偏向锁**。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况： \n1. A 线程已经退出了同步代码块，或者是已经不再存活，如果是上面两种情况之一，此时就会直接撤销偏向锁，变成无锁状态。\n2. 线程还在同步代码块中，此时将A线程的**偏向锁升级为轻量级锁**。\n\n偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：\n\n1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。\n2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。\n3. 唤醒被停止的线程，将当前锁升级成轻量级锁。\n\n所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：\n\n```bash\n-XX:UseBiasedLocking=false。\n```\n\n\n## 批量重偏向\n\n### 为什么有批量重偏向\n\n当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。这个过程是要消耗一定的成本的，所以如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。\n\n### 批量重偏向的原理\n\n竞争发生先升级成轻量级锁，但是如果线程对锁是交错访问的，没有实际上的竞争发生，并且次数达到一定阈值，则会进行重偏向（因为偏向锁不会释放，所以线程用完锁了偏向状态不会改变，别的线程一下子不知道）。\n\nepoch：一个时间戳，用来记录线程对某个类生成的对象的控制权。\n\n\u003e 我们要对一个**类**的所有实例（对象）进行批量重定向，就会在一个关键节点对所有实例进行一次扫描，看看有没有线程在锁定这些对象，被锁定的对象会更新一个标记，这个标记和类元数据中的最新标记一致，未被锁定的不会记录最新值，这样就能知道对象有没有线程在用。\n\n1. 首先引入一个概念epoch，其本质是一个**时间戳**，代表了**偏向锁的有效性**，epoch存储在可偏向对象的MarkWord中。除了**对象**中的epoch，对象所属的**类**class信息中，也会保存一个epoch值。\n    \n2. 每当遇到一个全局安全点时(这里的意思是说批量重偏向没有完全替代了全局安全点（比如要对class C 进行批量重偏向），则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new\n\n3. 然后扫描所有持有 class C **实例**的线程栈，根据线程栈的信息**判断出该线程是否锁定了该对象**，仅将epoch_new的值赋给**被锁定**的对象中，也就是现在**偏向锁还在被使用**的对象才会被赋值epoch_new。\n\n4. 退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了（因为步骤3里面已经说了只有偏向锁还在被使用的对象才会有epoch_new，这里不相等的原因是class C里面的epoch值是epoch_new,而当前对象的epoch里面的值还是epoch），此时竞争线程可以尝试对此对象重新进行偏向操作，**偏向自己而不是升级成轻量级锁**。\n\n## 撤销\n\n### 调用对象hashCode\n\nhashCode会禁用偏向锁：哈希码用的时候才产生，默认是0，只有第一次调用对象的hashcode，对象的哈希码才会产生，才在对象头的markword里面填充哈希码。\n\n\u003e 轻量级锁会在锁记录中记录 hashCode\n重量级锁会在 Monitor 中记录 hashCode\n\n### 其它线程使用对象\n\n当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁。\n\n### 调用 wait/notify\n\n### 批量撤销\n\n当撤销偏向锁阈值超过 40 次后，jvm 会发现这个类的对象竞争比较激烈，不应该用偏向锁。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93":{"title":"内存模型总结","content":"# 内存模型总结\n\n重点设计到[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/JMM|JMM]]中：\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]] - 由 JVM 缓存优化引起\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/有序性|有序性]] - 由 JVM [[3-计算机科学/2-计算机组成原理/指令重排序|指令重排序]]优化引起\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/happens-before|happens-before]] 规则\n- 原理方面\n\t- CPU 指令[[3-计算机科学/2-计算机组成原理/并行|并行]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]\n- 模式方面\n\t- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/两阶段终止|两阶段终止]]模式的 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]] 改进\n\t- [[3-计算机科学/2-计算机组成原理/同步|同步]]模式之 [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/Balking|balking]]","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B":{"title":"创建和运行线程","content":"# 创建和运行线程\n\n- 创建时部分使用了[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/lambda|lambda]]简化代码，为了便于理解未全部使用。\n\n## 方法1 直接使用Thread\n\n```java\nThread t1 = new Thread() {  \n    @Override  \n    public void run() {  \n        log.debug(\"running\");  \n    }  \n};  \nt1.start();\n```\n\n## 方法2 Thread配合Runnable\n\n```java\nRunnable runnable = () -\u003e log.debug(\"runnable\");  // lambda  \nThread t2 = new Thread(runnable);  \nt2.start();\n```\n\n## 方法3 Thread配合FutureTask\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/FutureTask|FutureTask]]需要用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Callable|Callable]]进行可以处理返回值。\n\n```java\nFutureTask\u003cInteger\u003e task = new FutureTask\u003c\u003e(new Callable\u003cInteger\u003e() {  \n    @Override  \n    public Integer call() throws Exception {  \n        log.debug(\"futuretask\");  \n        return 123;  \n    }  \n});  \nThread t3 = new Thread(task);  \nt3.start();\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8":{"title":"原子引用","content":"# 原子引用\n\n- AtomicReference\n- AtomicMarkableReference\n- AtomicStampedReference\n\n```java\nclass DecimalAccountSafeCas implements DecimalAccount {\n    AtomicReference\u003cBigDecimal\u003e ref;\n \n    public DecimalAccountSafeCas(BigDecimal balance) {\n        ref = new AtomicReference\u003c\u003e(balance);\n    }\n\n\t@Override\n\tpublic BigDecimal getBalance() {\n        return ref.get();\n    }\n \n    @Override\n    public void withdraw(BigDecimal amount) {\n        while (true) {\n            BigDecimal prev = ref.get();\n            BigDecimal next = prev.subtract(amount);\n            if (ref.compareAndSet(prev, next)) {\n                break;\n            }\n        }\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%80%A7":{"title":"原子性","content":"# 原子性\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84":{"title":"原子数组","content":"# 原子数组\n\n- AtomicIntegerArray\n- AtomicLongArray\n- AtomicReferenceArray\n\n```java\n/**\n     参数1，提供数组、可以是线程不安全数组或线程安全数组\n     参数2，获取数组长度的方法\n     参数3，自增方法，回传 array, index\n     参数4，打印数组的方法\n*/\n// supplier 提供者 无中生有  ()-\u003e结果\n// function 函数   一个参数一个结果   (参数)-\u003e结果  ,  BiFunction (参数1,参数2)-\u003e结果\n// consumer 消费者 一个参数没结果  (参数)-\u003evoid,      BiConsumer (参数1,参数2)-\u003e\nprivate static \u003cT\u003e void demo(\n    Supplier\u003cT\u003e arraySupplier,\n    Function\u003cT, Integer\u003e lengthFun,\n    BiConsumer\u003cT, Integer\u003e putConsumer,\n    Consumer\u003cT\u003e printConsumer ) {\n    List\u003cThread\u003e ts = new ArrayList\u003c\u003e();\n    T array = arraySupplier.get();\n    int length = lengthFun.apply(array);\n    for (int i = 0; i \u003c length; i++) {\n        // 每个线程对数组作 10000 次操作\n        ts.add(new Thread(() -\u003e {\n            for (int j = 0; j \u003c 10000; j++) {\n                putConsumer.accept(array, j%length);\n            }\n        }));\n    }\n \n    ts.forEach(t -\u003e t.start()); // 启动所有线程\n    ts.forEach(t -\u003e {\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });     // 等所有线程结束\n    printConsumer.accept(array);\n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0":{"title":"原子整数","content":"# 原子整数\n\nJ.U.C 并发包提供了：\n- AtomicBoolean\n- AtomicInteger\n- AtomicLong\n以 AtomicInteger 为例：\n\n```java\nAtomicInteger i = new AtomicInteger(0);\n \n// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++\nSystem.out.println(i.getAndIncrement());\n \n// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i\nSystem.out.println(i.incrementAndGet());\n \n// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i\nSystem.out.println(i.decrementAndGet());\n \n// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--\nSystem.out.println(i.getAndDecrement());\n \n// 获取并加值（i = 0, 结果 i = 5, 返回 0）\nSystem.out.println(i.getAndAdd(5));\n \n// 加值并获取（i = 5, 结果 i = 0, 返回 0）\nSystem.out.println(i.addAndGet(-5));\n \n// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用\nSystem.out.println(i.getAndUpdate(p -\u003e p - 2));\n \n// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用\nSystem.out.println(i.updateAndGet(p -\u003e p + 2));\n \n// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用\n// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的\n// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final\nSystem.out.println(i.getAndAccumulate(10, (p, x) -\u003e p + x));\n \n// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）\n// 其中函数中的操作能保证原子，但函数需要无副作用\nSystem.out.println(i.accumulateAndGet(-10, (p, x) -\u003e p + x));\n```\n\n#TODO","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8":{"title":"原子累加器","content":"\n# 原子累加器\n\n性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]... 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。\n\n累加单元不会超过cpu的核心数，核心数越多提升越明显。\n\n## 源码分析\n\n#TODO","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8":{"title":"变量的线程安全","content":"# 变量的线程安全\n\n## 成员变量\n\n- 如果它们没有共享，则[[3-计算机科学/2-计算机组成原理/线程|线程]]安全\n- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况\n\t- 如果只有**读**操作，则线程安全\n\t- 如果有读**写**操作，则这段代码是[[3-计算机科学/2-计算机组成原理/临界区|临界区]]，需要考虑线程安全\n\n## 局部变量\n\n- 局部变量是线程安全\n- 局部变量引用的对象不一定线程安全\n\t- 如果该对象没有逃离方法的作用访问，它是线程安全的\n\t- 如果该对象逃离方法的作用范围，需要考虑线程安全\n\n### 分析\n\n#### 非引用局部变量\n\n```java\npublic static void test1() {\n    int i = 10;\n    i++;\n}\n```\n\n每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。\n\n```\npublic static void test1();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=1, args_size=0\n         0: bipush        10\n         2: istore_0\n         3: iinc          0, 1\n         6: return\n      LineNumberTable:\n        line 10: 0\n        line 11: 3\n        line 12: 6\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            3       4     0     i   I\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220527140033.png]]\n\n#### 引用局部变量\n\n```java\nclass ThreadUnsafe {\n    ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e();\n    public void method1(int loopNumber) {\n        for (int i = 0; i \u003c loopNumber; i++) {\n            // { 临界区, 会产生竞态条件\n            method2();\n            method3();\n            // } 临界区\n        }\n    }\n \n    private void method2() {\n        list.add(\"1\");\n    }\n \n    private void method3() {\n        list.remove(0);\n    }\n}\n\nstatic final int THREAD_NUMBER = 2;\nstatic final int LOOP_NUMBER = 200;\npublic static void main(String[] args) {\n    ThreadUnsafe test = new ThreadUnsafe();\n    for (int i = 0; i \u003c THREAD_NUMBER; i++) {\n        new Thread(() -\u003e {\n            test.method1(LOOP_NUMBER);\n        }, \"Thread\" + i).start();\n    }\n}\n```\n\n上述代码中，在多线程场景下多个成员函数对同一个成员变量进行了操作，产生了临界区。\n\n如果线程1add到一半时线程2remove会报错。\n\n多个[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/JVM的栈帧|栈帧]]上的函数栈中，变量引用了同一个堆上资源：\n![[z-oblib/z2-attachments/Pasted image 20220527140412.png]]\n\n将资源改为成员变量即可：\n\n```java\nclass ThreadSafe {\n    public final void method1(int loopNumber) {\n        ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c loopNumber; i++) {\n            method2(list);\n            method3(list);\n        }\n    }\n \n    private void method2(ArrayList\u003cString\u003e list) {\n        list.add(\"1\");\n    }\n \n    private void method3(ArrayList\u003cString\u003e list) {\n        list.remove(0);\n    }\n}\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220527141920.png]]\n\n##### 方法访问修饰符带来的思考\n\n如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？\n- 情况1：有其它线程调用 method2 和 method3\n- 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即：\n\n```java\nclass ThreadSafe {\n    public final void method1(int loopNumber) {\n        ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c loopNumber; i++) {\n            method2(list);\n            method3(list);\n        }\n    }\n \n    private void method2(ArrayList\u003cString\u003e list) {\n\n        list.add(\"1\");\n    }\n \n    private void method3(ArrayList\u003cString\u003e list) {\n        list.remove(0);\n    }\n}\n \nclass ThreadSafeSubClass extends ThreadSafe{\n    @Override\n    public void method3(ArrayList\u003cString\u003e list) {\n        new Thread(() -\u003e {\n            list.remove(0);\n        }).start();\n    }\n}\n```\n\n\u003e 子类覆写了method3，会导致在子类对象中执行method1时，调用的method3是子类覆写过的。因为public修饰的成员方法在jvm对应的字节码是INVOKEVIRTUAL，是会根据对象类型来链接方法的。 #TODO : 补充知识。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7":{"title":"可见性","content":"# 可见性\n\n## 举例\n\nmain 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：\n\n```java\nstatic boolean run = true;\n \npublic static void main(String[] args) throws InterruptedException {\n    Thread t = new Thread(()-\u003e{\n        while(run){\n            // ....\n        }\n    });\n    t.start();\n \n    sleep(1);\n    run = false; // 线程t不会如预想的停下来\n}\n```\n\n 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存:\n ![[z-oblib/z2-attachments/Pasted image 20220530204318.png]]\n\n因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率:\n![[z-oblib/z2-attachments/Pasted image 20220530204336.png]]\n\n1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值：\n![[z-oblib/z2-attachments/Pasted image 20220530204356.png]]\n\n## 解决方案\n\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98":{"title":"哲学家就餐问题","content":"# 哲学家就餐问题\n\n![[z-oblib/z2-attachments/Pasted image 20220529223523.png]]\n\n有五位哲学家，围坐在圆桌旁：\n- 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。\n- 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。\n- 如果筷子被身边的人拿着，自己就得等待\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \npublic class Test14 {  \n    public static void main(String[] args) {  \n        Chopstick c1 = new Chopstick(\"1\");  \n        Chopstick c2 = new Chopstick(\"2\");  \n        Chopstick c3 = new Chopstick(\"3\");  \n        Chopstick c4 = new Chopstick(\"4\");  \n        Chopstick c5 = new Chopstick(\"5\");  \n        new Philosopher(\"苏格拉底\", c1, c2).start();  \n        new Philosopher(\"柏拉图\", c2, c3).start();  \n        new Philosopher(\"亚里士多德\", c3, c4).start();  \n        new Philosopher(\"赫拉克利特\", c4, c5).start();  \n        new Philosopher(\"阿基米德\", c5, c1).start();  \n    }  \n}  \n  \nclass Chopstick {  \n    String name;  \n  \n    public Chopstick(String name) {  \n        this.name = name;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"筷子{\" + name + '}';  \n    }  \n}  \n  \n@Slf4j  \nclass Philosopher extends Thread {  \n    Chopstick left;  \n    Chopstick right;  \n    public Philosopher(String name, Chopstick left, Chopstick right) {  \n        super(name);  \n        this.left = left;  \n        this.right = right;  \n    }  \n  \n    private void eat() {  \n        log.debug(\"eating...\");  \n        try {  \n            Thread.sleep(1000);  \n        } catch (InterruptedException e) {  \n            throw new RuntimeException(e);  \n        }  \n    }  \n  \n    @Override  \n    public void run() {  \n        while (true) {  \n            // 获得左手筷子  \n            synchronized (left) {  \n                // 获得右手筷子  \n                synchronized (right) {  \n                    // 吃饭  \n                    eat();  \n                }  \n                // 放下右手筷子  \n            }  \n            // 放下左手筷子  \n        }  \n    }  \n}\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%8A%8A%E9%94%81":{"title":"多把锁","content":"# 多把锁\n\n## 代码演示\n\n```java\nclass BigRoom {\n \n    public void sleep() {\n        synchronized (this) {\n            log.debug(\"sleeping 2 小时\");\n            Sleeper.sleep(2);\n        }\n    }\n \n    public void study() {\n        synchronized (this) {\n            log.debug(\"study 1 小时\");\n            Sleeper.sleep(1);\n        }\n    }\n \n}\n```\n\n细分锁的粒度：两个独立的功能用了同一把锁，导致[[3-计算机科学/2-计算机组成原理/并发|并发]]度下降，改进：\n\n```java\nclass BigRoom {\n \n    private final Object studyRoom = new Object();\n    private final Object bedRoom = new Object();\n \n    public void sleep() {\n    synchronized (bedRoom) {\n            log.debug(\"sleeping 2 小时\");\n            Sleeper.sleep(2);\n        }\n    }\n \n    public void study() {\n        synchronized (studyRoom) {\n            log.debug(\"study 1 小时\");\n            Sleeper.sleep(1);\n        }\n    }\n \n}\n```\n\n对独立的功能使用独立的多把锁，提高并发度。\n\n\u003e 注意，给方法加锁还是锁在this上。\n\n## 优缺点\n\n好处，是可以增强并发度\n坏处，如果一个[[3-计算机科学/2-计算机组成原理/线程|线程]]需要同时获得多把锁，就容易发生死锁\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8":{"title":"字段更新器","content":"# 字段更新器\n\n- AtomicReferenceFieldUpdater // 域  字段\n- AtomicIntegerFieldUpdater\n- AtomicLongFieldUpdater\n\n利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常\n\n#TODO","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8":{"title":"并发集合容器","content":"# 并发集合容器\n\n\u003e并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。\n\n我们知道在java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。\n\n而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明：\n```java\npublic class TestVector {\n    private Vector\u003cString\u003e vector;\n\n    //方法一\n    public  Object getLast(Vector vector) {\n        int lastIndex = vector.size() - 1;\n        return vector.get(lastIndex);\n    }\n\n    //方法二\n    public  void deleteLast(Vector vector) {\n        int lastIndex = vector.size() - 1;\n        vector.remove(lastIndex);\n    }\n\n    //方法三\n    public  Object getLastSysnchronized(Vector vector) {\n        synchronized(vector){\n            int lastIndex = vector.size() - 1;\n            return vector.get(lastIndex);\n        }\n    }\n\n    //方法四\n    public  void deleteLastSysnchronized(Vector vector) {\n        synchronized (vector){\n            int lastIndex = vector.size() - 1;\n            vector.remove(lastIndex);\n        }\n    }\n\n}\n```\n\n如果方法一和方法二为一个组合的话。那么当方法一获取到了`vector`的size之后，方法二已经执行完毕，这样就导致程序的错误。\n\n如果方法三与方法四组合的话。通过锁机制保证了在`vector`上的操作的原子性。\n\n## 并发容器类\n\n![[z-oblib/z2-attachments/assets--L_5HvtIhTFW9TQlOF8e--L_5TIKcBFHWPtY3OwUo--L_5TIqiTZQ7Me5TObhp-并发容器 1.png]]\n\n### 并发Map\n\n#### ConcurrentMap接口\n\nConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：\n\n```java\npublic interface ConcurrentMap\u003cK, V\u003e extends Map\u003cK, V\u003e {\n\n    //插入元素\n    V putIfAbsent(K key, V value);\n\n    //移除元素\n    boolean remove(Object key, Object value);\n\n    //替换元素\n    boolean replace(K key, V oldValue, V newValue);\n\n    //替换元素\n    V replace(K key, V value);\n\n}\n```\n\nputIfAbsent：与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；\n\nremove：与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;\n\nreplace(K,V,V)：增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；\n\nreplace(K,V)：与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；\n\n#### ConcurrentHashMap类\n\nConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与Hashtable完全不同的加锁策略，提供更高效的并发性和伸缩性。\n\nConcurrentHashMap在JDK 1.7 和JDK 1.8中有一些区别。这里我们分开介绍一下。\n\n##### JDK 1.7\n\nConcurrentHashMap在JDK 1.7中，提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。\n\n提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。\n\n可以这样理解分段锁，就是将数据分段，对每一段数据分配一把锁。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n\n有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图：\n![[z-oblib/z2-attachments/分段锁机制.png]]\n\nConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。\n\n一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。\n\n##### JDK 1.8\n\n而在JDK 1.8中，ConcurrentHashMap主要做了两个优化：\n\n- 同HashMap一样，链表也会在长度达到8的时候转化为红黑树，这样可以提升大量冲突时候的查询效率；\n- 以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合[[3-计算机科学/2-计算机组成原理/自旋|自旋]]+[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]避免不必要的锁开销，进一步提升并发性能。\n\n#### ConcurrentNavigableMap接口与ConcurrentSkipListMap类\n\nConcurrentNavigableMap接口继承了NavigableMap接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。\n\nConcurrentNavigableMap接口的主要实现类是ConcurrentSkipListMap类。从名字上来看，它的底层使用的是[[3-计算机科学/0-数据结构与算法/跳表|跳表]]（SkipList）的数据结构，它是一种”空间换时间“的数据结构，可以使用CAS来保证并发安全性。\n\n#### 并发Queue\n\nJDK并没有提供线程安全的List类，因为对List来说，**很难去开发一个通用并且没有并发瓶颈的线程安全的List**。因为即使简单的读操作，拿contains() 这样一个操作来说，很难想到搜索的时候如何避免锁住整个list。\n\n所以退一步，JDK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedQueue和ConcurrentLinkedDeque。因为队列相对于List来说，有更多的限制。这两个类是使用CAS来实现线程安全的。\n\n#### 并发Set\n\nJDK提供了ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。\n\n谷歌的guava框架实现了一个线程安全的ConcurrentHashSet：\n\n```java\nSet\u003cString\u003e s = Sets.newConcurrentHashSet();\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%8A%B6%E6%80%81":{"title":"无状态","content":"# 无状态\n\n在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的。因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93":{"title":"无锁小结","content":"\n# 无锁小结\n\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS与volatile|CAS与volatile]]\n- API\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/原子整数|原子整数]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/原子引用|原子引用]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/原子数组|原子数组]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/字段更新器|字段更新器]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/原子累加器|原子累加器]]\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Unsafe|Unsafe]]\n- 原理方面\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/LongAdder|LongAdder]] 源码\n\t- 伪共享\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%9C%89%E5%BA%8F%E6%80%A7":{"title":"有序性","content":"# 有序性\n\nJVM 会在不影响正确性的前提下，可以调整语句的执行顺序。\n\n## 有序性被破坏的例子\n\n```java\nboolean ready = false;\n \n// 线程1 执行此方法\npublic void actor1(I_Result r) {\n    if(ready) {\n        r.r1 = num + num;\n    } else {\n        r.r1 = 1;\n    }\n}\n \n// 线程2 执行此方法\npublic void actor2(I_Result r) {        \n    num = 2;\n    ready = true;    \n}\n```\n\n  \nready = true 可能会跑到num = 2前面执行，这种重排序在单线程下无所谓，但是有两个线程可能就导致 `ready==ture`时线程1执行了`num+num`，但是num还没被赋值。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%AD%BB%E9%94%81":{"title":"死锁","content":"# 死锁\n\n## 原因\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/多把锁|多把锁]]的情况可能会发生死锁：\n\n一个线程需要同时获取多把锁，这时就容易发生死锁\nt1 [[3-计算机科学/2-计算机组成原理/线程|线程]] 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \n@Slf4j  \npublic class Test13 {  \n    public static void main(String[] args) {  \n        Object A = new Object();  \n        Object B = new Object();  \n        Thread t1 = new Thread(() -\u003e {  \n            synchronized (A) {  \n                log.debug(\"lock A\");  \n                try {  \n                    Thread.sleep(1000);  \n                } catch (InterruptedException e) {  \n                    throw new RuntimeException(e);  \n                }  \n                synchronized (B) {  \n                    log.debug(\"lock B\");  \n                    log.debug(\"操作...\");  \n                }  \n            }  \n        }, \"t1\");  \n  \n        Thread t2 = new Thread(() -\u003e {  \n            synchronized (B) {  \n                log.debug(\"lock B\");  \n                try {  \n                    Thread.sleep(500);  \n                } catch (InterruptedException e) {  \n                    throw new RuntimeException(e);  \n                }  \n                synchronized (A) {  \n                    log.debug(\"lock A\");  \n                    log.debug(\"操作...\");  \n                }  \n            }  \n        }, \"t2\");  \n        t1.start();  \n        t2.start();  \n    }  \n}\n```\n\n## 定位\n检测死锁：\n- 使用 jconsole工具。\n- 使用 jps 定位[[3-计算机科学/2-计算机组成原理/进程|进程]] id，再用 jstack 定位死锁。\n\n## 解决方案\n\n### 顺序加锁\n\n![[z-oblib/z2-attachments/Pasted image 20220529224443.png]]\n\n![[z-oblib/z2-attachments/Pasted image 20220529224458.png]]\n\n#### 缺点\n\n顺序加锁可能引发[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/饥饿|饥饿]]问题。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E8%B7%83%E6%80%A7":{"title":"活跃性","content":"# 活跃性\n\n包括：\n\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/死锁|死锁]]\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/活锁|活锁]]\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/饥饿|饥饿]]","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E9%94%81":{"title":"活锁","content":"\n# 活锁\n\n活锁出现在两个[[3-计算机科学/2-计算机组成原理/线程|线程]]互相改变对方的结束条件，最后谁也无法结束，例如：\n\n```java\npublic class TestLiveLock {\n    static volatile int count = 10;\n    static final Object lock = new Object();\n \n    public static void main(String[] args) {\n        new Thread(() -\u003e {\n            // 期望减到 0 退出循环\n            while (count \u003e 0) {\n                sleep(0.2);\n                count--;\n                log.debug(\"count: {}\", count);\n            }\n        }, \"t1\").start();\n        new Thread(() -\u003e {\n            // 期望超过 20 退出循环\n            while (count \u003c 20) {\n                sleep(0.2);\n                count++;\n                log.debug(\"count: {}\", count);\n            }\n        }, \"t2\").start();\n    }\n}\n```\n\n## 解决方案\n\n错开运行时机。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93":{"title":"管程总结","content":"# 管程总结\n\n\u003e悲观锁\n\n需要重点掌握的是\n- 分析多[[3-计算机科学/2-计算机组成原理/线程|线程]]访问共享资源时，哪些代码片段属于[[3-计算机科学/2-计算机组成原理/临界区|临界区]]\n- 使用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]] 互斥解决临界区的线程安全问题\n\t- 掌握 synchronized 锁对象语法\n\t- 掌握 synchronzied 加载成员方法和静态方法语法\n\t- 掌握 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/wait\u0026notify|wait\u0026notify]] [[3-计算机科学/2-计算机组成原理/同步|同步]]方法\n- 使用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/ReentrantLock|lock]] 互斥解决临界区的线程安全问题\n\t- 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量\n- 学会分析[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]性、掌握常见[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程安全类|线程安全类]]的使用\n- 了解线程[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/活跃性|活跃性]]问题：[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/死锁|死锁]]、[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/活锁|活锁]]、[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/饥饿|饥饿]]\n- 应用方面\n\t- 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果\n\t- 同步：使用 wait\u0026notify 或 Lock 的条件变量来达到线程间通信效果\n- 原理方面\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|monitor]]、synchronized 、wait\u0026notify 原理\n\t- synchronized 进阶原理\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/park\u0026unpark|park\u0026unpark]] 原理\n- 模式方面\n\t- 同步模式之[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/保护性暂停|保护性暂停]]\n\t- [[3-计算机科学/2-计算机组成原理/异步|异步]]模式之[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/生产者消费者|生产者消费者]]\n\t- 同步模式之[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/顺序控制|顺序控制]]","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB":{"title":"线程安全类","content":"# 线程安全类\n\n自己实现类的时候维护[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]比较繁琐，java就给我们提供了一些线程安全的类。\n\n## 常见线程安全类\n\n- String\n- Integer\n- StringBuﬀer\n- Random\n- Vector\n- Hashtable\n- java.util.concurrent 包下的类\n\n线程安全场景举例：\n```java\nHashtable table = new Hashtable();\n \nnew Thread(()-\u003e{\n    table.put(\"key\", \"value1\");\n}).start();\n \nnew Thread(()-\u003e{\n    table.put(\"key\", \"value2\");\n}).start();\n```\n\n## 线程安全类方法的组合\n\n这些类线程安全的是指，**多个线程**调用它们**同一个实例**的某个方法时，是线程安全的。也可以理解为：\n- 它们的**每个**方法是原子的\n- 但注意它们多个方法的组合不是原子的\n\n```java\nHashtable table = new Hashtable();\n// 线程1，线程2\nif( table.get(\"key\") == null) {  // 中间会收到线程上下文切换的影响\n    table.put(\"key\", value);\n}\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220527151142.png]]\n\n## 不可变类的线程安全性\n\nString、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。\n\nsubString()等方法实际是创建了一个新String对象。\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0":{"title":"线程安全集合类概述","content":"# 线程安全集合类概述\n\n![[z-oblib/z2-attachments/Pasted image 20220612211057.png]]\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0":{"title":"线程池","content":"# 线程池\n\n## 使用线程池的原因\n\n-   创建/销毁[[3-计算机科学/2-计算机组成原理/线程|线程]]需要消耗系统资源，线程池可以复用已创建的线程。\n-   控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）\n-   可以对线程做统一管理\n\n## 原理\n\nJava中的线程池顶层接口是`Executor`接口，`ThreadPoolExecutor`是这个接口的实现类。\n\n### ThreadPoolExecutor 构造方法\n\n四个构造方法：\n\n```java\n// 五个参数的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue)\n\n// 六个参数的构造函数-1\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          ThreadFactory threadFactory)\n\n// 六个参数的构造函数-2\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          RejectedExecutionHandler handler)\n\n// 七个参数的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n5~7个参数，其中5个为必须： ^22da28\n- int corePoolSize：线程池中核心线程数最大值\n- int maximumPoolSize：该线程池中线程总数最大值 \n- long keepAliveTime：非核心线程闲置超时时长\n- TimeUnit（枚举类型） unit：keepAliveTime的单位\n\t- NANOSECONDS 微毫秒\n\t- MICROSECONDS 微秒\n\t- MILLISECONDS 毫秒\n\t- SECONDS 秒\n\t- MINUTES 分\n\t- HOURS 时\n\t- DAYS 天\n\t\u003eNANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天\n- BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象\n\t- LinkedBlockingQueue：链式阻塞队列，底层数据结构是链表，默认大小是`Integer.MAX_VALUE`，也可以指定大小。\n\t- ArrayBlockingQueue：数组阻塞队列，底层数据结构是数组，需要指定队列的大小。\n\t- SynchronousQueue：同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。\n\t- DelayQueue：延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。用于缓存系统、定时任务调度等\n2个非必要参数：\n- ThreadFactory threadFactory：创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。\n  ```java\nstatic class DefaultThreadFactory implements ThreadFactory {\n    // 省略属性\n    // 构造函数\n    DefaultThreadFactory() {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n        Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n            poolNumber.getAndIncrement() +\n            \"-thread-\";\n    }\n\n    // 省略\n}\n  ```\n- RejectedExecutionHandler handler 拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：\n\t- ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。 \n\t- hreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。 \n\t- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。\n\t- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。\n\n### ThreadPoolExecutor 策略\n\n**线程池也有自己的状态**：线程池本身有一个负责调度的线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。`ThreadPoolExecutor`类中使用了一些`final int`常量变量来表示线程池的状态 ，分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。\n\n```java\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 \u003c\u003c COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 \u003c\u003c COUNT_BITS;\nprivate static final int STOP       =  1 \u003c\u003c COUNT_BITS;\nprivate static final int TIDYING    =  2 \u003c\u003c COUNT_BITS;\nprivate static final int TERMINATED =  3 \u003c\u003c COUNT_BITS;\n```\n\n线程池四种状态的流转：\n-   线程池创建后处于**RUNNING**状态。\n-   调用shutdown()方法后处于**SHUTDOWN**状态，线程池不能接受新的任务，清除一些空闲worker,不会等待阻塞队列的任务完成。\n-   调用shutdownNow()方法后处于**STOP**状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。\n-   当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为**TIDYING**状态。接着会执行terminated()函数。\n\u003e`ctl`，它是一个AtomicInteger类型的变量。线程池状态就是通过AtomicInteger类型的成员变量`ctl`来获取的。\n\u003e获取的`ctl`值传入`runStateOf`方法，与`~CAPACITY`位与运算(`CAPACITY`是低29位全1的int变量)。\n\u003e`~CAPACITY`在这里相当于掩码，用来获取ctl的高3位，表示线程池状态；而另外的低29位用于表示工作线程数\n\n### 任务处理流程\n\n处理任务的核心方法是`execute`，JDK 1.8 源码中`ThreadPoolExecutor`是处理线程任务：\n```java\n// JDK 1.8\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();   \n    int c = ctl.get();\n    // 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务\n    // 检查核心线程是否已满\n    if (workerCountOf(c) \u003c corePoolSize) {\n       if (addWorker(command, true))\n           return;\n       c = ctl.get();\n    }\n    // 2.如果不小于corePoolSize，则将任务添加到workQueue队列。\n    // 要保证线程池在运行状态\n    // 同时任务队列未满\n    if (isRunning(c) \u0026\u0026 workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。\n        // 在任务入队后在判断一次线程池是否处于运行状态（状态瞬息万变）\n        if (! isRunning(recheck) \u0026\u0026 remove(command))\n            reject(command);\n            // 2.2 线程池处于running状态，但是没有线程，则创建线程\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 3.如果放入workQueue失败，则创建非核心线程执行任务，\n    // 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。\n    else if (!addWorker(command, false))\n         reject(command);\n}\n```\n\n线程池状态瞬息万变，所以要在`workQueue.offer(command)`任务入队的前后都检查一次线程池状态：线程池没在运行就没必要入队了，入了也没法执行。入队也有个过程，这时候线程池如果变成未运行，则有可能这个指令永远不被执行了。\n\n总结：\n1.  线程总数量 \u003c corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 \u003c corePoolSize时）。**注意，这一步需要获得全局锁。**\n2.  线程总数量 \u003e= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。\n3.  当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**\n4.  缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。\n![[z-oblib/z2-attachments/线程池主要的处理流程.png]]\n### 线程复用原理\n\n我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。**那么，线程池如何做到线程复用呢？**\n\n原来，ThreadPoolExecutor在创建线程时，会将线程封装成**工作线程worker**,并放入**工作线程组**中，然后这个worker反复从阻塞队列中拿任务去执行。话不多说，我们继续看看源码（一定要仔细看，前后有联系）\n\n这里的`addWorker`方法是在上面提到的`execute`方法里面调用的，先看看上半部分：\n\n```java\n// ThreadPoolExecutor.addWorker方法源码上半部分\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs \u003e= SHUTDOWN \u0026\u0026\n            ! (rs == SHUTDOWN \u0026\u0026\n               firstTask == null \u0026\u0026\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc \u003e= CAPACITY ||\n                // 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程\n                // 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数\n                // 如果不小于，则返回false\n                wc \u003e= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n```\n上半部分主要是判断线程数量是否超出阈值，超过了就返回false。我们继续看下半部分：\n```java\n    // ThreadPoolExecutor.addWorker方法源码下半部分\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 1.创建一个worker对象\n        w = new Worker(firstTask);\n        // 2.实例化一个Thread对象\n        final Thread t = w.thread;\n        if (t != null) {\n            // 3.线程池全局锁\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs \u003c SHUTDOWN ||\n                    (rs == SHUTDOWN \u0026\u0026 firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s \u003e largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 4.启动这个线程\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n创建`worker`对象，并初始化一个`Thread`对象，然后启动这个线程对象。\n\n我们接着看看`Worker`类，仅展示部分源码：\n```java\n// Worker类部分源码\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    final Thread thread;\n    Runnable firstTask;\n\n    Worker(Runnable firstTask) {\n        setState(-1); // inhibit interrupts until runWorker\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n            runWorker(this);\n    }\n    //其余代码略...\n}\n```\n\n`Worker`类实现了`Runnable`接口，所以`Worker`也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故`addWorker`方法调用addWorker方法源码下半部分中的第4步`t.start`，会触发`Worker`类的`run`方法被JVM调用。\n\n我们再看看`runWorker`的逻辑：\n\n```java\n// Worker.runWorker方法源代码\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    // 1.线程启动之后，通过unlock方法释放锁\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出\n        while (task != null || (task = getTask()) != null) {\n            // 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            // 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 \n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() \u0026\u0026\n                  runStateAtLeast(ctl.get(), STOP))) \u0026\u0026\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 2.3执行beforeExecute \n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    // 2.4执行任务\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    // 2.5执行afterExecute方法 \n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                // 2.6解锁操作\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\u003e是线程工作者主动检查线程池状态的。\n\n首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在`while`循环中，worker会不断地调用`getTask`方法从**阻塞队列**中获取任务然后调用`task.run()`执行任务,从而达到**复用线程**的目的。只要`getTask`方法不返回`null`,此线程就不会退出。\n\n当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果**STOP**或者**TERMINATED**，返回`null`。\n\n最后看看`getTask`方法的实现：\n```java\n// Worker.getTask方法源码\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs \u003e= SHUTDOWN \u0026\u0026 (rs \u003e= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁 永不超时\n        // 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 \n        boolean timed = allowCoreThreadTimeOut || wc \u003e corePoolSize;  // 核心线程销毁标志\n        // 2.如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 \n　　　　 // 如果有设置允许线程超时或者线程数量超过了核心线程数量，\n        // 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量\n        if ((wc \u003e maximumPoolSize || (timed \u0026\u0026 timedOut))\n            \u0026\u0026 (wc \u003e 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            // 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.\n            // 超时时间是keepAliveTime。如果超过keepAliveTime时长，\n            // poll返回了null，上边提到的while循序就会退出，线程也就执行完了。\n            // 如果timed为false（allowCoreThreadTimeOut为falsefalse\n            // 且wc \u003e corePoolSize为false），则会调用workQueue的take方法阻塞在当前。\n            // 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n核心线程：\n- `workQueue.take`会阻塞等待，不消耗cpu，嗯等。\n- `workQueue.poll`含超时条件的等待，可能返回null，核心线程可能被销毁。\n\n核心线程的会一直卡在`workQueue.take`方法，被阻塞并挂起，不会占用CPU资源，直到拿到`Runnable` 然后返回（当然如果**allowCoreThreadTimeOut**设置为`true`,那么核心线程就会去调用`poll`方法，因为`poll`可能会返回`null`,所以这时候核心线程满足超时条件也会被销毁）。\n\n非核心线程：\n- 只有调用`workQueue.poll`\n\n非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断**compareAndDecrementWorkerCount**就会返回`null`,Worker对象的`run()`方法循环体的判断为`null`,任务结束，然后线程被系统回收 。\n\n## 四种常见线程池\n\n### newCachedThreadPool\n\n- 单个短任务处理时间快，线性执行两个短任务和并行执行效率差相对较小。\n- 大量短任务到来需要更高的线程复用率，防止大量创建线程带来的额外开销。\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池#^22da28|线程池构造方法参数]]\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue\u003cRunnable\u003e());\n}\n```\n\n- 全部都是非核心线程\n- 用同步队列，即队列大小为0，入队要等待出队操作发生\n- 线程池很大，基本不会发生拒绝\n\n`CacheThreadPool`的**运行流程**如下：\n\n1.  提交任务进线程池。\n2.  因为**corePoolSize**为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。\n3.  尝试将任务添加到**SynchronousQueue**队列。\n4.  如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。\n5.  如果SynchronousQueue已有任务在等待，入列操作将会阻塞。\n\n当需要执行很多**短时间**的任务时，CacheThreadPool的线程复用率比较高， 会显著的**提高性能**。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。\n\n### newFixedThreadPool\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池#^22da28|线程池构造方法参数]]\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue\u003cRunnable\u003e());\n}\n```\n\n- 全部都是核心线程\n- 无法创建非核心线程\n- 采用数组阻塞队列\n- 阻塞队列很大，基本不会发生拒绝\n\n与CachedThreadPool的区别：\n- 因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。\n- 在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。\n- 由于线程不会被回收，会一直卡在阻塞，所以**没有任务的情况下， FixedThreadPool占用资源更多**。\n- 都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。\n\n### newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue\u003cRunnable\u003e()));\n}\n```\n\n- 只有一个核心线程\n- 没有非核心线程\n- 采用链表阻塞队列\n- 保证任务先来先执行\n\n### newScheduledThreadPool\n\n```java\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n\n//ScheduledThreadPoolExecutor():\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE,\n          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\n          new DelayedWorkQueue());\n}\n```\n\n- 确定量的核心线程\n- 大量非核心线程\n- 默认的超时时间\n- 延迟队列","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF":{"title":"线程通讯","content":"# 线程通讯\n\n## 方法\n\n1. 使用消息队列\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5":{"title":"缓存更新策略","content":"\n# 缓存更新策略\n\n## 先清缓存\n\n清缓存--更新数据库之间，其它线程读取了数据库中的旧数据，并写入缓存，导致5中缓存长时间被污染。\n\n![[z-oblib/z2-attachments/Pasted image 20220610172505.png]]\n\n## 先更新数据库\n\n更新数据库--清空缓存之间，其它线程可能读取到缓存中的旧数据，2中存在一定的窗口期。\n\n![[z-oblib/z2-attachments/Pasted image 20220610172620.png]]\n\n## 特殊情况\n\n假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询，这种情况的出现几率非常小，见 facebook 论文：\n\n![[z-oblib/z2-attachments/Pasted image 20220610173806.png]]\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0":{"title":"自定义线程池","content":"# 自定义线程池\n\n![[z-oblib/z2-attachments/Pasted image 20220607213829.png]]\n\n## 拒绝策略接口\n\n策略模式：\n具体操作抽象成接口，具体实现由调用者传递进来。\n\n```java\n// 拒绝策略\n@FunctionalInterface\ninterface RejectPolicy\u003cT\u003e {\n    void reject(BlockingQueue\u003cT\u003e queue, T task);\n}\n```\n\n参数要包含queue，来决定是否要在queue上等待，例如queue.put(task)\n\n## 任务队列\n\n```java\nclass BlockingQueue\u003cT\u003e {\n    // 1. 任务队列\n    private Deque\u003cT\u003e queue = new ArrayDeque\u003c\u003e();\n \n    // 2. 锁\n    private ReentrantLock lock = new ReentrantLock();\n \n    // 3. 生产者条件变量\n    private Condition fullWaitSet = lock.newCondition();\n \n    // 4. 消费者条件变量\n    private Condition emptyWaitSet = lock.newCondition();\n \n    // 5. 容量\n    private int capcity;\n \n    public BlockingQueue(int capcity) {\n        this.capcity = capcity;\n    }\n \n    // 带超时阻塞获取\n    public T poll(long timeout, TimeUnit unit) {\n        lock.lock();\n        try {\n            // 将 timeout 统一转换为 纳秒\n            long nanos = unit.toNanos(timeout);\n            while (queue.isEmpty()) {\n                try {\n                    // 返回值是剩余时间\n                    if (nanos \u003c= 0) {\n                        return null;\n                    }\n                    nanos = emptyWaitSet.awaitNanos(nanos);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            T t = queue.removeFirst();\n            fullWaitSet.signal();\n            return t;\n        } finally {\n            lock.unlock();\n        }\n        }\n \n    // 阻塞获取\n    public T take() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                try {\n                    emptyWaitSet.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            T t = queue.removeFirst();\n            fullWaitSet.signal();\n            return t;\n        } finally {\n            lock.unlock();\n        }\n    }\n \n    // 阻塞添加\n    public void put(T task) {\n        lock.lock();\n        try {\n            while (queue.size() == capcity) {\n                try {\n                    log.debug(\"等待加入任务队列 {} ...\", task);\n                    fullWaitSet.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            log.debug(\"加入任务队列 {}\", task);\n            queue.addLast(task);\n            emptyWaitSet.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n \n    // 带超时时间阻塞添加\n    public boolean offer(T task, long timeout, TimeUnit timeUnit) {\n        lock.lock();\n        try {\n            long nanos = timeUnit.toNanos(timeout);\n            while (queue.size() == capcity) {\n                try {\n                    if(nanos \u003c= 0) {\n                        return false;\n                    }\n                    log.debug(\"等待加入任务队列 {} ...\", task);\n\n                    nanos = fullWaitSet.awaitNanos(nanos);\n                    } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            log.debug(\"加入任务队列 {}\", task);\n            queue.addLast(task);\n            emptyWaitSet.signal();\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n \n    public int size() {\n        lock.lock();\n        try {\n            return queue.size();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n\t// 超时策略由线程调用者提供\n    public void tryPut(RejectPolicy\u003cT\u003e rejectPolicy, T task) {\n        lock.lock();\n        try {\n            // 判断队列是否满\n            if(queue.size() == capcity) {\n                rejectPolicy.reject(this, task);  // 执行具体的超时策略\n            } else {  // 有空闲\n                log.debug(\"加入任务队列 {}\", task);\n                queue.addLast(task);\n                emptyWaitSet.signal();\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## 线程池\n\n```java\nclass ThreadPool {\n    // 任务队列\n    private BlockingQueue\u003cRunnable\u003e taskQueue;\n \n    // 线程集合\n    private HashSet\u003cWorker\u003e workers = new HashSet\u003c\u003e();\n \n    // 核心线程数\n    private int coreSize;\n \n    // 获取任务时的超时时间\n    private long timeout;\n \n    private TimeUnit timeUnit;\n \n    private RejectPolicy\u003cRunnable\u003e rejectPolicy;  // 任务执行超时策略\n \n    // 执行任务\n    // 对接workers和worker，新建worker或从队列拿\n    public void execute(Runnable task) {\n        // 当任务数没有超过 coreSize 时，直接交给 worker 对象执行\n        // 如果任务数超过 coreSize 时，加入任务队列暂存\n        synchronized (workers) {\n            if(workers.size() \u003c coreSize) {\n                Worker worker = new Worker(task);\n                log.debug(\"新增 worker{}, {}\", worker, task);\n                workers.add(worker);\n                worker.start();\n            } else {\n//                taskQueue.put(task);\n\t\t\t\t// 队列满了后的选择：\n                // 1) 死等\n                // 2) 带超时等待\n                // 3) 让调用者放弃任务执行\n                // 4) 让调用者抛出异常\n                // 5) 让调用者自己执行任务\n\n\t\t\t\t// 不要写死，权力下放给线程池使用者\n\t\t\t\t// 策略模式\n                taskQueue.tryPut(rejectPolicy, task);\n            }\n        }\n    }\n \n    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, \nRejectPolicy\u003cRunnable\u003e rejectPolicy) {\n        this.coreSize = coreSize;\n        this.timeout = timeout;\n        this.timeUnit = timeUnit;\n        this.taskQueue = new BlockingQueue\u003c\u003e(queueCapcity);\n        this.rejectPolicy = rejectPolicy;\n    }\n \n    class Worker extends Thread{\n        private Runnable task;\n \n        public Worker(Runnable task) {\n            this.task = task;\n        }\n \n        @Override\n        public void run() {\n            // 执行任务\n            // 1) 当 task 不为空，执行任务\n            // 2) 当 task 执行完毕，再接着从任务队列获取任务并执行\n//            while(task != null || (task = taskQueue.take()) != null) {\n\t\t\t// 有超时的从队列获取任务，一段时间没任务就销毁worker\n            while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {\n                try {\n                    log.debug(\"正在执行...{}\", task);\n                    task.run();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    task = null;\n                }\n            }\n            synchronized (workers) {\n                log.debug(\"worker 被移除{}\", this);\n                workers.remove(this);\n            }\n        }\n    }\n}\n```\n\n## 测试\n\n```java\npublic static void main(String[] args) {\n        ThreadPool threadPool = new ThreadPool(1,\n                1000, TimeUnit.MILLISECONDS, 1, (queue, task)-\u003e{\n            // 1. 死等\n//            queue.put(task);\n            // 2) 带超时等待\n//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);\n            // 3) 让调用者放弃任务执行\n//            log.debug(\"放弃{}\", task);\n            // 4) 让调用者抛出异常\n            // 会在主线程for里面抛出异常，使得剩下的任务都不会被执行\n//            throw new RuntimeException(\"任务执行失败 \" + task);\n            // 5) 让调用者自己执行任务\n            // task.run()是由主线程执行的\n            task.run();\n        });\n        for (int i = 0; i \u003c 4; i++) {\n            int j = i;\n            threadPool.execute(() -\u003e {\n                try {\n                    Thread.sleep(1000L);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                log.debug(\"{}\", j);\n            });\n        }\n    }\n```\n\n注意：\n- 策略5是由main线程执行的。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96":{"title":"自旋优化","content":"# 自旋优化\n\n- 自旋优化会因为循环消耗CPU资源。\n- java6后自旋锁是自适应的，成功的多尝试次数就多。\n- java7后不能控制是否开启自旋。\n\n## 自旋成功\n\n![[z-oblib/z2-attachments/Pasted image 20220527214938.png]]\n\n## 自旋失败\n\n![[z-oblib/z2-attachments/Pasted image 20220527214953.png]]","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81":{"title":"轻量级锁","content":"\n# 轻量级锁\n\n## 使用方式\n\n轻量级锁任然使用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]语法，实现对使用者透明。\n\n## 使用场景\n\n如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以\n使用轻量级锁来优化。\n\n## 流程\n\n示例代码：\n\n```java\nstatic final Object obj = new Object();\npublic static void method1() {\n    synchronized( obj ) {\n        // 同步块 A\n        method2();\n    }\n}\npublic static void method2() {\n    synchronized( obj ) {\n        // 同步块 B\n    }\n}\n```\n\n### 获取锁\n\n1. 每个[[3-计算机科学/2-计算机组成原理/线程|线程]]都的栈帧都会包含一个锁记录（Lock Record）的结构，内部可以存储锁定对象的 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]，用于存储锁对象目前的Mark Word的拷贝。\n2. 拷贝[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/对象头|对象头]]中的Mark Word复制到创建的锁记录中。\n![[z-oblib/z2-attachments/Pasted image 20220527211853.png]]\n3. 拷贝成功后，JVM尝试使用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]操作将对象头的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象头的mark word。如果更新成功，则执行步骤4，否则执行步骤5。\n![[z-oblib/z2-attachments/Pasted image 20220527212007.png]]\n4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且锁对象头中存储了锁记录地址和状态 00 。\n5. 如果 cas 失败，有两种情况：\n\t1. 如果是其它[[3-计算机科学/2-计算机组成原理/线程|线程]]已经持有了该 Object 的轻量级锁，一定次数后仍未获得锁对象，说明发生了竞争，需要进行锁膨胀，膨胀为[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]。\n    \u003e 尝试的方式是通过[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/自旋优化|自旋优化]]进行的，[[3-计算机科学/2-计算机组成原理/自旋|自旋]]会消耗CPU资源。\n\n\t2. 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数。\n\t![[z-oblib/z2-attachments/Pasted image 20220527212157.png]]\n\n### 释放锁\n\n1. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。\n\t![[z-oblib/z2-attachments/Pasted image 20220527212610.png]]\n2. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头：\n\t1. 成功，则解锁成功。\n\t2. 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81":{"title":"重量级锁","content":"# 重量级锁\n\n## 介绍\n\n重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。\n\n前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：\n\n```\nContention List：所有请求锁的线程将被首先放置到该竞争队列\nEntry List：Contention List中那些有资格成为候选人的线程被移到Entry List\nWait Set：那些调用wait方法被阻塞的线程被放置到Wait Set\nOnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck\nOwner：获得锁的线程称为Owner\n!Owner：释放锁的线程\n```\n\n当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个`ObjectWaiter`对象插入到Contention List的队列的队首，然后调用`park`函数挂起当前线程。\n\n当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做`Heir presumptive`即假定继承人，假定继承人被唤醒后会尝试获得锁，但`synchronized`是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。\n\n如果线程获得锁后调用`Object.wait`方法，则会将线程加入到WaitSet中，当被`Object.notify`唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的`wait`或`notify`方法时，**如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁**。\n\n## 重量级锁加锁和释放锁机制\n\n重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。\n\n前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：\n\n```\nContention List：所有请求锁的线程将被首先放置到该竞争队列\nEntry List：Contention List中那些有资格成为候选人的线程被移到Entry List\nWait Set：那些调用wait方法被阻塞的线程被放置到Wait Set\nOnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck\nOwner：获得锁的线程称为Owner\n!Owner：释放锁的线程\n```\n\n当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个`ObjectWaiter`对象插入到Contention List的队列的队首，然后调用`park`函数挂起当前线程。\n\n当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做`Heir presumptive`即假定继承人，假定继承人被唤醒后会尝试获得锁，但`synchronized`是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。\n\n如果线程获得锁后调用`Object.wait`方法，则会将线程加入到WaitSet中，当被`Object.notify`唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的`wait`或`notify`方法时，**如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁**。\n\n    ![[z-oblib/z2-attachments/20200411162031746.png]]\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB":{"title":"锁接口和类","content":"# 锁接口和类\n\n## 分类\n\n### 可重入锁和非可重入锁\n\n可重入：[[3-计算机科学/2-计算机组成原理/线程|线程]]能对资源重复加锁。\n\n- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]关键字就是使用的重入锁。\n- 在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。\n- 如果我们自己在继承[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/AQS|AQS]]实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。\n- ReentrantLock就是可重入锁。\n\n### 公平锁和非公平锁\n\n公平：现来后到，FIFO，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足。\n\n- 非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。\n- ReentrantLock支持非公平锁和公平锁两种。\n\n### 读写锁和排它锁\n\n排它：同一时刻只允许一个线程访问。\n读写：同一时刻允许多个**读**线程访问。\n\n- Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。\n- 即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。\n\n## JDK中有关锁的一些接口和类\n\n### 抽象类AQS/AQLS/AOS\n\nAQS（AbstractQueuedSynchronizer）资源上限是Integer.MAX_VALUE，AQLS（AbstractQueuedLongSynchronizer）资源上限是Long.MAX_VALUE。\n两者都继承自AOS（AbstractOwnableSynchronizer）它是用于表示锁与持有者之间的关系（独占模式）。可以看一下它的主要方法：\n```java\n// 独占模式，锁的持有者  \nprivate transient Thread exclusiveOwnerThread;  \n\n// 设置锁持有者  \nprotected final void setExclusiveOwnerThread(Thread t) {  \n    exclusiveOwnerThread = t;  \n}  \n\n// 获取锁的持有线程  \nprotected final Thread getExclusiveOwnerThread() {  \n    return exclusiveOwnerThread;  \n}\n```\n\n### 接口Condition/Lock/ReadWriteLock\n\njuc.locks包下共有三个接口：`Condition`、`Lock`、`ReadWriteLock`。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：\n\n```java\npublic interface ReadWriteLock {\n    Lock readLock();\n    Lock writeLock();\n}\n```\n\nLock接口中有一个方法是可以获得一个`Condition`:\n\n```java\nCondition newCondition();\n```\n\n#TODO\n\n\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%B6%88%E9%99%A4":{"title":"锁消除","content":"# 锁消除\n\nJIT会对java字节码进行优化，逃逸分析时发现对象不可能被共享，就会取消无意义的加锁操作。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94":{"title":"锁的优缺点对比","content":"# 锁的优缺点对比\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/偏向锁|偏向锁]] [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]] [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]\n\n| 锁     | 优点                                 | 缺点                        | 适用场景               |\n|-------|------------------------------------|---------------------------|--------------------|\n| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。  | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。  | 适用于只有一个线程访问同步块场景。  |\n| 轻量级锁  | 竞争的线程不会阻塞，提高了程序的响应速度。              | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。  | 追求响应时间。同步块执行速度非常快。 |\n| 重量级锁  | 线程竞争不使用自旋，不会消耗CPU。                 | 线程阻塞，响应时间缓慢。              | 追求吞吐量。同步块执行时间较长。   |\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96":{"title":"锁的其他优化","content":"# 锁的其他优化\n\n-   适应性自旋（Adaptive Spinning）：从[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]获取的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁#^8418aa|过程]]中我们知道，当[[3-计算机科学/2-计算机组成原理/线程|线程]]在获取轻量级锁的过程中执行[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]操作失败时，是要通过自旋来获取[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。\n-   锁粗化（Lock Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子：\n\n```java\npublic  void lockCoarsening() {\n    int i=0;\n    synchronized (this){\n        i=i+1;\n    }\n    synchronized (this){\n        i=i+2;\n    }\n}\n```\n\n上面的两个同步代码块可以变成一个\n\n```java\npublic  void lockCoarsening() {\n    int i=0;\n    synchronized (this){\n        i=i+1;\n        i=i+2;\n    }\n}\n```\n\n-   锁消除（Lock Elimination）：锁消除即删除不必要的加锁操作的代码。比如下面的代码,下面的for循环完全可以移出来，这样可以减少加锁代码的执行过程\n\n```java\npublic  void lockElimination() {\n    int i=0;\n    synchronized (this){\n        for(int c=0; c\u003c1000; c++){\n            System.out.println(c);\n        }\n        i=i+1;\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E8%86%A8%E8%83%80":{"title":"锁膨胀","content":"# 锁膨胀\n\n锁由[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]向[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]升级的过程。\n\n## 竞争者升级锁\n\n接着[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁#获取锁|轻量级锁中升级的5.1分支]]继续说：\n\n如果在尝试加轻量级锁的过程中，[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]] 操作无法成功，这时一种情况就是有其它[[3-计算机科学/2-计算机组成原理/线程|线程]]为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁。\n![[z-oblib/z2-attachments/Pasted image 20220527214017.png]]\n2. Thread-1 加轻量级锁失败，进入锁膨胀流程：\n\t1. 为 Object 对象申请 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|Monitor]] 锁，让 Object 指向重量级锁地址。\n\t2. 自己进入 Monitor 的 EntryList BLOCKED。\n\t![[z-oblib/z2-attachments/Pasted image 20220527214113.png]]\n\n\n## 原轻量级锁持有者解锁\n\n1. 当 Thread-0 退出同步块解锁时，使用 cas 将 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 的值恢复给对象头，失败。这时会进入重量级解锁流程：\n\t1. 即按照 Monitor 地址找到 Monitor 对象。\n\t2. 设置 Owner 为 null。\n\t3. 唤醒 EntryList 中 BLOCKED 线程。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97":{"title":"阻塞队列","content":"# 阻塞队列\n\n## 简介\n\njdk中阻塞队列BlockingQueue解决的问题和实现的功能：\n- 多线程场景下的生产者-消费者模式中，多个线程操作共享变量（资源）容易产生线程安全问题：重复消费、死锁。\n- 资源池空了，需要阻塞消费者，唤醒生产者。\n- 资源池满了，需要阻塞生产者，唤醒消费者。\n\nBlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了**线程安全的队列访问方式**，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。开发者只管往里面存取即可，不用担心线程安全问题。\nBlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。**BlockingQueue就是存放元素的容器**。\n\n## 操作方法\n\n阻塞队列提供了四组不同的方法用于插入、移除、检查元素：\n| 方法\\处理方式  | 抛出异常       | 返回特殊值     | 一直阻塞    | 超时退出               |\n|----------|------------|-----------|---------|--------------------|\n| 插入方法     | add(e)     | offer(e)  | put(e)  | offer(e,time,unit) |\n| 移除方法     | remove()   | poll()    | take()  | poll(time,unit)    |\n| 检查方法     | element()  | peek()    | -       | -                  |\n-   抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。\n-   返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。\n-   一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。\n-   超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。\n\n**注意：**\n-   不能往阻塞队列中插入null,会抛出空指针异常。\n-   可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。\n\n## 实现类\n\n### ArrayBlockingQueue\n\n由**数组**结构组成的**有界**阻塞队列。内部结构是数组，故具有数组的特性。\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair){\n    //..省略代码\n}\n```\n\n可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是非公平锁。\n\n### LinkedBlockingQueue\n\n由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是`Integer.MAX_VALUE`，也可以指定大小。此队列按照**先进先出**的原则对元素进行排序。\n\n### DelayQueue\n\n该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 \nDelayQueue是一个**无界**的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 \n\n### PriorityBlockingQueue\n\n基于优先级的**无界**阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是非公平锁。\n\n\u003e网上大部分博客上**PriorityBlockingQueue**为公平锁，其实是不对的。\n\n```java\npublic PriorityBlockingQueue(int initialCapacity,\n                                  Comparator\u003c? super E\u003e comparator) {\n         this.lock = new ReentrantLock(); //默认构造方法-非公平锁\n         ...//其余代码略\n     }\n```\n\n### SynchronousQueue\n\n这个队列比较特殊，**没有任何内部容量**，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。\n\n需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。\n\n以下方法的返回值，可以帮助理解这个队列：\n\n-   iterator() 永远返回空，因为里面没有东西\n-   peek() 永远返回null\n-   put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。\n-   offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。\n-   take() 取出并且remove掉queue里的element，取不到东西他会一直等。\n-   poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。\n-   isEmpty() 永远返回true\n-   remove()\u0026removeAll() 永远返回false\n\n**总注意：**\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/阻塞队列#PriorityBlockingQueue|PriorityBlockingQueue]]不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，**生产者生产数据的速度绝对不能快于消费者消费数据的速度**，否则时间一长，会最终耗尽所有的可用堆内存空间。对于使用默认大小的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/阻塞队列#LinkedBlockingQueue|LinkedBlockingQueue]]也是一样的（默认大小特别大）。\n\n## 原理\n\n阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。\n\n首先是构造器，除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。\n\n```java\n//数据元素数组\nfinal Object[] items;\n//下一个待取出元素索引\nint takeIndex;\n//下一个待添加元素索引\nint putIndex;\n//元素个数\nint count;\n//内部锁\nfinal ReentrantLock lock;\n//消费者监视器\nprivate final Condition notEmpty;\n//生产者监视器\nprivate final Condition notFull;  \n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    //..省略其他代码\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}\n```\n\n生产者 put()：\n```java\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    // 1.自旋拿操作资源队列的锁\n    // 如果当前线程未中断则获取锁定，如果已中断则抛出异常\n    // lock优先考虑获取锁，成功后才响应中断。\n    // lockInterruptibly优先考虑响应中断，而不是响应锁的普通获取或重入获取\n    // lockInterruptibly可以用来批量中断线程池中正在获取锁的线程\n    lock.lockInterruptibly();\n    try {\n        // 2.判断队列是否满了\n        while (count == items.length)\n            // 2.1如果满了，阻塞该线程，并标记为notFull线程，\n            // 等待notFull的唤醒，唤醒之后继续执行while循环。\n            notFull.await();\n        // 3.如果没有满，则进入队列\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\nprivate void enqueue(E x) {\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    // 4 唤醒一个等待的线程\n    notEmpty.signal();\n}\n```\n\nput流程：\n1.  所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。\n2.  判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。\n3.  如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。\n4.  唤醒一个标记为notEmpty（消费者）的线程。\n\n消费者take()：\n```java\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n\t    // 没有资源则阻塞\n        while (count == 0)\n            notEmpty.await();\n        // 消费资源\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\nprivate E dequeue() {\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings(\"unchecked\")\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}\n```\ntake流程：\n1.  所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。\n2.  判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。\n3.  如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。\n4.  唤醒一个标记为notFull（生产者）的线程。\n\n**注意：**\n1.  put和take操作都需要**先获取锁**，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。\n2.  就算拿到锁了之后，也**不一定**会顺利进行put/take操作，需要判断**队列是否可用**（是否满/空），如果不可用，则会被阻塞，**并释放锁**。\n3.  在第2点被阻塞的线程会被唤醒，但是在唤醒之后，**依然需要拿到锁**才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。\n\n## 示例和使用场景\n\n### 生产者-消费者模型\n\n```java\npublic class Test {\n    private int queueSize = 10;\n    private ArrayBlockingQueue\u003cInteger\u003e queue = new ArrayBlockingQueue\u003cInteger\u003e(queueSize);\n\n    public static void main(String[] args)  {\n        Test test = new Test();\n        Producer producer = test.new Producer();\n        Consumer consumer = test.new Consumer();\n\n        producer.start();\n        consumer.start();\n    }\n\n    class Consumer extends Thread{\n\n        @Override\n        public void run() {\n            consume();\n        }\n\n        private void consume() {\n            while(true){\n                try {\n                    queue.take();\n                    System.out.println(\"从队列取走一个元素，队列剩余\"+queue.size()+\"个元素\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    class Producer extends Thread{\n\n        @Override\n        public void run() {\n            produce();\n        }\n\n        private void produce() {\n            while(true){\n                try {\n                    queue.put(1);\n                    System.out.println(\"向队列取中插入一个元素，队列剩余空间：\"+(queueSize-queue.size()));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B":{"title":"顺序一致性模型","content":"# 顺序一致性模型\n\n顺序一致性内存模型是一个**理想化的理论参考模型**，它为程序员提供了极强的内存可见性保证。\n\n顺序一致性模型有两大特性：\n\n-   一个[[3-计算机科学/2-计算机组成原理/线程|线程]]中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。\n    \n-   不管程序是否[[3-计算机科学/2-计算机组成原理/同步|同步]]，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是**原子性的，且立刻对所有线程可见**。\n    \n\n为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-\u003eA2-\u003eA3，线程B也有3个操作，B1-\u003eB2-\u003eB3。\n\n假设**正确使用了同步**，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在**顺序一致性模型**中的执行效果如下所示：\n\n![[z-oblib/z2-attachments/正确同步.png]]\n\n操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。\n\n假设**没有使用同步**，那么在**顺序一致性模型**中的执行效果如下所示：\n\n![[z-oblib/z2-attachments/没有正确同步.png]]\n\n操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的**每个操作必须立即对任意线程可见**。\n\n**但是[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/JMM|JMM]]没有这样的保证：**\n比如，在当前线程把写过的数据缓存在本地内存中，**在没有刷新到主内存之前，这个写操作仅对当前线程可见**；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6":{"title":"顺序控制","content":"# 顺序控制\n\n线程之间按规定的先后顺序执行。\n\n## 交替输出\n\n线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现：\n\n### wait\u0026notify\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/wait\u0026notify|wait\u0026notify]]\n\n```java\nclass SyncWaitNotify {\n    private int flag;\n    private int loopNumber;\n \n    public SyncWaitNotify(int flag, int loopNumber) {\n        this.flag = flag;\n        this.loopNumber = loopNumber;\n    }\n \n    public void print(int waitFlag, int nextFlag, String str) {\n        for (int i = 0; i \u003c loopNumber; i++) {\n            synchronized (this) {\n\t            // 防止虚假唤醒，用循环\n                while (this.flag != waitFlag) {\n                    try {\n                        this.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.print(str);\n                flag = nextFlag;\n                // 唤醒所有其它线程\n                this.notifyAll();\n            }\n        }\n    }\n}\n```\n\n```java\nSyncWaitNotify syncWaitNotify = new SyncWaitNotify(1, 5);\nnew Thread(() -\u003e {\n    syncWaitNotify.print(1, 2, \"a\");\n}).start();\nnew Thread(() -\u003e {\n    syncWaitNotify.print(2, 3, \"b\");\n}).start();\nnew Thread(() -\u003e {\n    syncWaitNotify.print(3, 1, \"c\");\n}).start();\n```\n\n### ReentrantLock条件变量\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/ReentrantLock|ReentrantLock]]\n\n```java\nclass AwaitSignal extends ReentrantLock {\n    public void start(Condition first) {\n        this.lock();\n        try {\n            log.debug(\"start\");\n            first.signal();\n        } finally {\n            this.unlock();\n        }\n    }\n    public void print(String str, Condition current, Condition next) {\n        for (int i = 0; i \u003c loopNumber; i++) {\n            this.lock();\n            // 固定的try finally unlock\n            try {\n\t            // 默认都进入条件变量休眠，第一个线程由main线程唤醒\n                current.await();\n                log.debug(str);\n                // 唤醒下一个线程\n                next.signal();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                this.unlock();\n            }\n        }\n    }\n \n    // 循环次数\n    private int loopNumber;\n \n    public AwaitSignal(int loopNumber) {\n        this.loopNumber = loopNumber;\n    }\n}\n```\n\n```java\nAwaitSignal as = new AwaitSignal(5);\nCondition aWaitSet = as.newCondition();\nCondition bWaitSet = as.newCondition();\nCondition cWaitSet = as.newCondition();\n \n \nnew Thread(() -\u003e {\n    as.print(\"a\", aWaitSet, bWaitSet);\n}).start();\nnew Thread(() -\u003e {\n    as.print(\"b\", bWaitSet, cWaitSet);\n}).start();\nnew Thread(() -\u003e {\n    as.print(\"c\", cWaitSet, aWaitSet);\n}).start();\n \nas.start(aWaitSet);\n```\n\n### Park\u0026Unpark\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/park\u0026unpark|Park\u0026Unpark]]\n\n```java\nclass SyncPark {\n\n    private int loopNumber;\n    private Thread[] threads;\n \n    public SyncPark(int loopNumber) {\n        this.loopNumber = loopNumber;\n    }\n \n    public void setThreads(Thread... threads) {\n        this.threads = threads;\n    }\n \n    public void print(String str) {\n        for (int i = 0; i \u003c loopNumber; i++) {\n\t        // 线程默认park，第一个线程由main线程唤醒\n            LockSupport.park();\n            System.out.print(str);\n            // 唤醒下一个线程\n            LockSupport.unpark(nextThread());\n        }\n    }\n \n    private Thread nextThread() {\n        Thread current = Thread.currentThread();\n        int index = 0;\n        for (int i = 0; i \u003c threads.length; i++) {\n            if(threads[i] == current) {\n                index = i;\n                break;\n            }\n        }\n        if(index \u003c threads.length - 1) {\n            return threads[index+1];\n        } else {\n            return threads[0];\n        }\n    }\n \n    public void start() {\n        for (Thread thread : threads) {\n            thread.start();\n        }\n        LockSupport.unpark(threads[0]);\n    }\n}\n```\n\n```java\nSyncPark syncPark = new SyncPark(5);\nThread t1 = new Thread(() -\u003e {\n    syncPark.print(\"a\");\n});\nThread t2 = new Thread(() -\u003e {\n    syncPark.print(\"b\");\n});\nThread t3 = new Thread(() -\u003e {\n    syncPark.print(\"c\\n\");\n});\nsyncPark.setThreads(t1, t2, t3);\nsyncPark.start();\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A5%A5%E9%A5%BF":{"title":"饥饿","content":"# 饥饿\n\n一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS":{"title":"AQS","content":"# AQS\n\n\n全称是 AbstractQueuedSynchronizer，是**阻塞**式锁（类似[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]）和相关的同步器工具的框架。\n\n## 特点\n\n- 用 **state** 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁\n\t- getState - 获取 state 状态\n\t- setState - 设置 state 状态\n\t- compareAndSetState - cas 机制设置 state 状态\n\t- 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源\n- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList\n- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet\n\n子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）\n- tryAcquire\n- tryRelease\n- tryAcquireShared\n- tryReleaseShared\n- isHeldExclusively\n\n\u003e 这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法。\n\n\n### 获取锁\n\n```java\n// 如果获取锁失败\nif (!tryAcquire(arg)) {\n    // 入队, 可以选择阻塞当前线程  park unpark\n}\n```\n\n\u003e AQS使用park\u0026unpark来阻塞和恢复线程\n\n### 释放锁\n\n```java\n// 如果释放锁成功\nif (tryRelease(arg)) {\n    // 让阻塞线程恢复运行\n}\n```\n\n\n## 自己实现不可重入锁\n\n实现Lock+AQS：\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \nimport java.util.concurrent.TimeUnit;  \nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;  \nimport java.util.concurrent.locks.Condition;  \nimport java.util.concurrent.locks.Lock;  \n  \n@Slf4j  \npublic class Test23Aqs {  \n    public static void main(String[] args) {  \n        MyLock lock = new MyLock();  \n        new Thread(()-\u003e{  \n            log.debug(\"尝试加锁\");  \n            lock.lock();  \n            log.debug(\"加锁成功\");  \n            try {  \n                log.debug(\"加锁\");  \n                try {  \n                    Thread.sleep(3000);  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                }  \n            } finally {  \n                log.debug(\"解锁\");  \n                lock.unlock();  \n            }  \n        }).start();  \n  \n        new Thread(()-\u003e{  \n            log.debug(\"尝试加锁\");  \n            lock.lock();  \n            log.debug(\"加锁成功\");  \n            try {  \n                log.debug(\"加锁\");  \n            } finally {  \n                log.debug(\"解锁\");  \n                lock.unlock();  \n            }  \n        }).start();  \n    }  \n}  \n  \n  \n// 不可重入锁：  \n// 仿ReentrantLock实现  \n// 1. 实现Lock接口  \n// 2. 使用AQS同步器类  \nclass MyLock implements Lock {  \n  \n    // 同步器类  \n    // 锁的大部分功能是由该同步器类完成的  \n    // 实现一个独占锁：  \n    class MySync extends AbstractQueuedSynchronizer {  \n        // 尝试获取锁  \n        @Override  \n        protected boolean tryAcquire(int arg) {  \n            // 可能有其它线程同时尝试加锁，所以要用cas  \n            if (compareAndSetState(0, 1)) {  \n                // 加上锁了，设置owner为当前线程  \n                setExclusiveOwnerThread(Thread.currentThread());  \n                return true;            }  \n            return false;  \n        }  \n  \n        // 尝试释放锁  \n        @Override  \n        protected boolean tryRelease(int arg) {  \n            // 获取了锁，不用再和其它线程竞争  \n            setExclusiveOwnerThread(null);  \n            // state是volatile的，所以这里放在最后，让写屏障能影响前面所有操作，保证之前的设置对所有线程可见  \n            setState(0);  \n            return true;        }  \n  \n        // 是否持有独占锁  \n        @Override  \n        protected boolean isHeldExclusively() {  \n            return getState() == 1;  \n        }  \n  \n        // 返回一个条件变量  \n        public Condition newCondition() {  \n            // AQS提供的一个内部类，可以直接使用  \n            return new ConditionObject();  \n        }  \n    }  \n  \n    private MySync sync = new MySync();  \n  \n    // 下面的抽象方法自己实现比较繁琐  \n    // 就可以利用同步器类，AQS实现了大部分方法  \n  \n    // 加锁（尝试加锁，失败会进入队列等待）  \n    @Override  \n    public void lock() {  \n        sync.acquire(1);  \n    }  \n  \n    // 可打断加锁（加锁过程可打断）  \n    @Override  \n    public void lockInterruptibly() throws InterruptedException {  \n        sync.acquireInterruptibly(1);  \n    }  \n  \n    // 尝试加锁（尝试一次，失败直接返回false）  \n    @Override  \n    public boolean tryLock() {  \n        return sync.tryAcquire(1);  \n    }  \n  \n    // 带超时加锁  \n    @Override  \n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {  \n        return sync.tryAcquireNanos(1, unit.toNanos(time));  \n    }  \n  \n    // 解锁  \n    @Override  \n    public void unlock() {  \n        // 调用了tryRelease并唤醒正在阻塞的线程  \n        sync.release(1);  \n    }  \n  \n    // 创建条件变量  \n    @Override  \n    public Condition newCondition() {  \n        return sync.newCondition();  \n    }  \n}\n```\n\n\n\n\n\n\n\n\n\n\n\n## 简介\n\nAQS就是一个支持多个[[3-计算机科学/2-计算机组成原理/线程|线程]]进来排队的先进先出（FIFO）的双端队列，通过自身设计来实现多个线程到达总能按一定顺序进入队列，不会因为同时入队抢占发生问题。同时在头部保证有序的向目标资源进行访问（线程获取资源权限）。                    \n\n**AQS**是`AbstractQueuedSynchronizer`的简称，即`抽象队列同步器`，从字面意思上理解:\n\n- 抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；\n- 队列：使用先进先出（FIFO）队列存储数据；\n- 同步：实现了同步的功能。\n\nAQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。\n\n当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器，只要子类实现它的几个`protected`方法就可以。\n\n## AQS的数据结构\n\nAQS内部使用了一个[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]的变量state来作为资源的标识。同时定义了几个获取和改变state的protected方法，子类可以覆盖这些方法来实现自己的逻辑：\n\n```java\ngetState()\nsetState()\ncompareAndSetState()\n```\n\n这三种操作均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。\n\n而AQS类本身实现的是**一些排队和阻塞的机制**，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。\n\n1. 内部可以是一个先进先出（FIFO）的双端队列（CLH队列，（Craig, Landin, and Hagersten 队列）），并使用了两个指针head和tail用于标识队列的头部和尾部。其数据结构如图：\n![[z-oblib/z2-attachments/AQS数据结构.png]]\n但它并不是直接储存线程，而是**储存拥有线程的Node节点**，因为是一个双向链表的结构，所以最小单元是Node，Node会包含前后节点的地址，还包括一个线程。\n\n2. 也可以是一个借助nextWaiter（见后续章节）实现的单向队列。\n\n### 资源共享模式\n\n\u003e 一堆线程在排队等待资源，但资源可以同时只给一个线程用，或者支持多个线程同时用。\n\n资源有两种共享模式，或者说两种同步方式：\n\n- 独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。\n- 共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。\n\n一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如`ReadWriteLock`。\n\n### Node结构\n\nAQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看**Node的结构**：\n\n```java\nstatic final class Node {\n    // 标记一个结点（对应的线程）在共享模式下等待\n    static final Node SHARED = new Node();\n    // 标记一个结点（对应的线程）在独占模式下等待\n    static final Node EXCLUSIVE = null; \n\n    // waitStatus的值，表示该结点（对应的线程）已被取消\n    static final int CANCELLED = 1; \n    // waitStatus的值，表示后继结点（对应的线程）需要被唤醒\n    static final int SIGNAL = -1;\n    // waitStatus的值，表示该结点（对应的线程）在等待某一条件\n    static final int CONDITION = -2;\n    /*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*/\n    static final int PROPAGATE = -3;\n\n    // 等待状态，取值范围，-3，-2，-1，0，1\n    volatile int waitStatus;\n    volatile Node prev; // 前驱结点\n    volatile Node next; // 后继结点\n    volatile Thread thread; // 结点对应的线程\n    Node nextWaiter; // 在CLH队列时，表示共享式或独占式标记，在条件队列时，表示下一个Node节点\n\n\n    // 判断共享模式的方法\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n\n    // 其它方法忽略，可以参考具体的源码\n}\n\n// AQS里面的addWaiter私有方法\nprivate Node addWaiter(Node mode) {\n    // 使用了Node的这个构造函数\n    Node node = new Node(Thread.currentThread(), mode);\n    // 其它代码省略\n}\n```\n\n注意：通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。\n\nwaitStatus等待状态如下：\n![[z-oblib/z2-attachments/103e67d0d59543c4acfd4d0345dabfec.png]]\n\n **nextWaiter特殊标记**：\n- Node在CLH队列时，nextWaiter表示共享式或独占式标记；\n- Node在条件队列时，nextWaiter表示下个Node节点指针；\n\n## AQS的主要方法源码解析\n\nAQS的设计是基于[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/模板模式|模板模式]]的，它有一些方法必须要子类去实现的，它们主要有：\n\n- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。\n- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\u003e 子类需要实现在独占/共享模式下对资源的获取和释放的有针对性地逻辑部分。\n\n这些方法虽然都是[[3-计算机科学/6-应用开发/0-软件语言/Java/0-语法基础/访问控制符#protected|protected]]方法，但是它们并没有在AQS具体实现，而是直接抛出异常（这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法）：\n\n\u003e 而AQS实现了一系列（包括资源/释放）主要的逻辑。\n\n### 线程排队\n\n获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026\u0026\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。\n\n如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：\n\n```java\nprivate Node addWaiter(Node mode) {\n    // 生成该线程对应的Node节点\n    Node node = new Node(Thread.currentThread(), mode);\n    // 获取尾节点\n    Node pred = tail;\n    // 如果前面还有其它节点\n    if (pred != null) {\n\t    // 将当前节点地前驱节点设置为队尾节点\n        node.prev = pred;\n        // 使用CAS尝试将后继节点信息写入队尾节点，如果成功就返回\n        // 使用CAS是为了处理多个线程同时想排队的情况\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    // 如果等待队列为空或者上述CAS失败，再自旋CAS插入\n    enq(node);\n    return node;\n}\n\n// 自旋CAS插入等待队列\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        // 如果等待队列为空\n        if (t == null) { // Must initialize\n\t        // 创建一个空节点作为头节点（哨兵节点）\n            if (compareAndSetHead(new Node()))\n\t            // 并把队尾指向队首，及队伍中现在只有一个空节点，队首队尾都指向这个节点\n                tail = head;\n        // 等待队列不为空\n        } else {\n\t        // 使用CAS尝试将后继节点信息写入队尾节点，和之前函数一样，不过这里是在循环里一直去尝试\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n\u003e上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。\n\n### 获取资源\n\nOK，现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而等待队列的头节点获取资源，而队列中节点会依次成为头节点。具体的实现我们来看看acquireQueued方法：\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n\t    // 设置中断状态为非中断\n        boolean interrupted = false;\n        // 自旋\n        for (;;) {\n            final Node p = node.predecessor();\n            // 队首节点是当前已经获取到资源的结点或null，那么排在第二个位置的节点会循环尝试获取资源\n            // 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了\n            if (p == head \u0026\u0026 tryAcquire(arg)) {\n                // 拿到资源后，说明之前的头节点释放资源了，将head指向当前节点，把前任队首踢出队伍。\n                setHead(node); \n                p.next = null; // 清空上一任头节点的后继节点信息，帮助JVM回收垃圾\n                failed = false;\n                return interrupted;\n            }\n            // 多次没获取到锁，可以休息了，就进入waiting状态，直到被unpark()\n            if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n\u003e 这里parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)，顺便简单介绍一下park。\n\u003e \n\u003e LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：\n\u003e \n\u003e -   park(boolean isAbsolute, long time)：阻塞当前线程\n\u003e -   unpark(Thread jthread)：使给定的线程停止阻塞\n\n所以**结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的**。\n\n当然，获取资源的方法除了acquire外，还有以下三个：\n- acquireInterruptibly：申请可中断的资源（独占模式）\n- acquireShared：申请共享模式的资源\n- acquireSharedInterruptibly：申请可中断的资源（共享模式）\n\n\u003e 可中断的意思是，在线程中断时可能会抛出`InterruptedException`。\n\n![[z-oblib/z2-attachments/acquire流程.png]]\n\n###  释放资源\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null \u0026\u0026 h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n// 传入的参数是头节点\nprivate void unparkSuccessor(Node node) {\n    // 如果状态是负数，尝试把它设置为0\n    int ws = node.waitStatus;\n    if (ws \u003c 0)\n        compareAndSetWaitStatus(node, ws, 0);\n    // 得到头结点的后继结点head.next\n    Node s = node.next;\n    // 如果这个后继结点为空或者状态大于0\n    // 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消\n    if (s == null || s.waitStatus \u003e 0) {\n        s = null;  // 节点被取消则把节点删掉\n        // 等待队列中所有还有用的结点，都向前移动\n        // 从队尾向前遍历，取最靠近队首的未取消节点\n        for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev)\n            if (t.waitStatus \u003c= 0)\n                s = t;\n    }\n    // 如果后继结点不为空，\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n```\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS":{"title":"CAS","content":"# CAS\n\n\n## 原理\n\nCAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。\n\n在多核状态下，某个核执行到带 lock 的指令时，CPU 会让**总线锁住**，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。\n\n## CAS应用\n\njava中：与volatile配合实现乐观锁。\n\n## CAS为什么能保证原子操作呐？\n\n这个就关系到了CAS底层所用到的Unsafe类，Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。\n\n## 特点\n\n- 结合 CAS 和 volatile 可以实现无锁并发，适用于**线程数少**、**多核 CPU** 的场景下。\n\t- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。\n\t- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。\n\t- CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思\n\t\t- 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一\n\t\t- 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E4%B8%8Evolatile":{"title":"CAS与volatile","content":"# CAS与volatile\n\n\n## 用例\n\nAtomicInteger 的解决方法，内部并没有用锁来保护共享[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]。那么它是如何实现的呢？\n\n```java\npublic void withdraw(Integer amount) {\n    while(true) {\n        // 需要不断尝试，直到成功为止\n        while (true) {\n            // 比如拿到了旧值 1000\n            int prev = balance.get();\n            // 在这个基础上 1000-10 = 990\n            int next = prev - amount;\n            /*\n        compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值\n        - 不一致了，next 作废，返回 false 表示失败\n           比如，别的线程已经做了减法，当前值已经被减成了 990\n           那么本[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]的这次 990 就作废了，进入 while 下次循环重试\n        - 一致，以 next 设置为新值，返回 true 表示成功\n\n        */\n        if (balance.compareAndSet(prev, next)) {\n                break;\n            }\n        }\n    }\n}\n```\n\n其中的关键是 compareAndSet，它的简称就是 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]] （也有 Compare And Swap 的说法），它必须是原子操作。\n![[z-oblib/z2-attachments/Pasted image 20220531231303.png]]\n\n\n### 慢动作分析\n\n```java\n@Slf4j\npublic class SlowMotion {\n \n    public static void main(String[] args) {\n        AtomicInteger balance = new AtomicInteger(10000);\n        int mainPrev = balance.get();\n        log.debug(\"try get {}\", mainPrev);\n \n        new Thread(() -\u003e {\n            sleep(1000);\n            int prev = balance.get();\n            balance.compareAndSet(prev, 9000);\n            log.debug(balance.toString());\n        }, \"t1\").start();\n \n \n        sleep(2000);\n        log.debug(\"try set 8000...\");\n        boolean isSuccess = balance.compareAndSet(mainPrev, 8000);\n        log.debug(\"is success ? {}\", isSuccess);\n        if(!isSuccess){\n            mainPrev = balance.get();\n            log.debug(\"try set 8000...\");\n            isSuccess = balance.compareAndSet(mainPrev, 8000);\n            log.debug(\"is success ? {}\", isSuccess);\n        }\n \n    }\n \n \n    private static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## volatile\n\n获取共享变量时，为了保证该变量的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]]，需要使用 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]] 修饰。\n它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。\n\u003e注意：\n\u003evolatile 仅仅保证了共享变量的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]]，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）。\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]] 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果。\n\n## 为什么无锁效率更高\n\n- 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]] 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻\n- 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大\n- 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98":{"title":"CAS实现原子操作的三大问题","content":"\n# CAS实现原子操作的三大问题\n\n## ABA问题\n\n所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]是检查不出变化的，但实际上却被更新了两次。\n\nABA问题的解决思路是在变量前面追加上**版本号或者时间戳**。从JDK 1.5开始，JDK的atomic包里提供了一个类`AtomicStampedReference`类来解决ABA问题。\n\n这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。\n\n```java\npublic boolean compareAndSet(V   expectedReference,\n                             V   newReference,\n                             int expectedStamp,\n                             int newStamp) {\n    Pair\u003cV\u003e current = pair;\n    return\n        expectedReference == current.reference \u0026\u0026\n        expectedStamp == current.stamp \u0026\u0026\n        ((newReference == current.reference \u0026\u0026\n          newStamp == current.stamp) ||\n         casPair(current, Pair.of(newReference, newStamp)));\n}\n```\n\n## 循环时间长开销大\n\nCAS多与自旋结合。如果[[3-计算机科学/2-计算机组成原理/自旋|自旋]]CAS长时间不成功，会占用大量的CPU资源。\n\n解决思路是让JVM支持处理器提供的**pause指令**。\n\npause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。\n\n## 只能保证一个共享变量的原子操作\n\n有两种解决方案：\n\n1. 使用JDK 1.5开始就提供的`AtomicReference`类保证对象之间的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/原子性|原子性]]，把多个变量放到一个对象里面进行CAS操作；\n2. 使用[[3-计算机科学/3-操作系统/Linux/锁|锁]]。锁内的[[3-计算机科学/2-计算机组成原理/临界区|临界区]]代码可以保证只有当前[[3-计算机科学/2-计算机组成原理/线程|线程]]能操作。\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E9%94%81":{"title":"CAS锁","content":"# CAS锁\n\n利用原子类配合cas操作组成标志位，来模拟锁：\n\n```java\n// 不要用于实践！！！\npublic class LockCas {\n    private AtomicInteger state = new AtomicInteger(0);\n \n    public void lock() {\n        while (true) {\n            if (state.compareAndSet(0, 1)) {\n                break;\n            }\n        }\n    }\n \n    public void unlock() {\n        log.debug(\"unlock...\");\n        state.set(0);\n    }\n}\n```","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Callable":{"title":"Callable","content":"# Callable\n\n带返回值的call，并且可以抛出异常。\n\n```java\npublic interface Callable\u003cV\u003e {  \n    V call() throws Exception;\n```\n\n","lastmodified":"2023-01-23T15:37:51.746680481Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap":{"title":"ConcurrentHashMap","content":"# ConcurrentHashMap\n\n## 用例\n\n分布式计算字符串数量：\n\n### 生成测试数据\n\n```java\nstatic final String ALPHA = \"abcedfghijklmnopqrstuvwxyz\";\n \npublic static void main(String[] args) {\n    int length = ALPHA.length();\n    int count = 200;\n    List\u003cString\u003e list = new ArrayList\u003c\u003e(length * count);\n    for (int i = 0; i \u003c length; i++) {\n        char ch = ALPHA.charAt(i);\n        for (int j = 0; j \u003c count; j++) {\n            list.add(String.valueOf(ch));\n        }\n    }\n    Collections.shuffle(list);\n    for (int i = 0; i \u003c 26; i++) {\n        try (PrintWriter out = new PrintWriter(\n            new OutputStreamWriter(\n                new FileOutputStream(\"tmp/\" + (i+1) + \".txt\")))) {\n            String collect = list.subList(i * count, (i + 1) * count).stream()\n                .collect(Collectors.joining(\"\\n\"));\n            out.print(collect);\n        } catch (IOException e) {\n        }\n    }\n}\n```\n\n### 模板代码\n\n模版代码中封装了多线程读取文件的代码：\n\n```java\nprivate static \u003cV\u003e void demo(Supplier\u003cMap\u003cString,V\u003e\u003e supplier, \nBiConsumer\u003cMap\u003cString,V\u003e,List\u003cString\u003e\u003e consumer) {\n    Map\u003cString, V\u003e counterMap = supplier.get();\n    List\u003cThread\u003e ts = new ArrayList\u003c\u003e();\n    for (int i = 1; i \u003c= 26; i++) {\n        int idx = i;\n        Thread thread = new Thread(() -\u003e {\n            List\u003cString\u003e words = readFromFile(idx);\n            consumer.accept(counterMap, words);\n        });\n        ts.add(thread);\n    }\n \n    ts.forEach(t-\u003et.start());\n    ts.forEach(t-\u003e {\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            }\n    });\n \n    System.out.println(counterMap);\n}\n \npublic static List\u003cString\u003e readFromFile(int i) {\n    ArrayList\u003cString\u003e words = new ArrayList\u003c\u003e();\n    try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(\"tmp/\" \n+ i +\".txt\")))) {\n        while(true) {\n            String word = in.readLine();\n            if(word == null) {\n                break;\n            }\n            words.add(word);\n        }\n        return words;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n### 实现\n\n1. 提供一个 map 集合，用来存放每个单词的计数结果，key 为单词，value 为计数\n2. 提供一组操作，保证计数的安全性，会传递 map 集合以及 单词 List\n\n#### LongAdder实现\n\n借助LongAdder实现原子的自增。\n\n```java\ndemo(\n    () -\u003e new ConcurrentHashMap\u003cString, LongAdder\u003e(),\n    (map, words) -\u003e {\n        for (String word : words) {\n            // 注意不能使用 putIfAbsent，此方法返回的是上一次的 value，首次调用返回 null\n            map.computeIfAbsent(word, (key) -\u003e new LongAdder()).increment();\n        }\n    }\n);\n```\n\n#### 函数式编程\n\n```java\ndemo(\n    () -\u003e new ConcurrentHashMap\u003cString, Integer\u003e(),\n    (map, words) -\u003e {\n        for (String word : words) {\n            // 函数式编程，无需原子变量\n            map.merge(word, 1, Integer::sum);\n        }\n    }\n);\n```\n\n## 源码分析\n\u003e JDK8源码。\n\u003e 解决HashMap的[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/HashMap#JDK7并发死链|并发问题]]。\n\n### 重要属性和内部类\n\n```java\n// 默认为 0\n// 当初始化时, 为 -1\n// 当扩容时, 为 -(1 + 扩容线程数)\n// 当初始化或扩容完成后，为 下一次的扩容的阈值大小\nprivate transient volatile int sizeCtl;\n \n// 整个 ConcurrentHashMap 就是一个 Node[]\nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {}\n \n// hash 表\ntransient volatile Node\u003cK,V\u003e[] table;\n \n// 扩容时的 新 hash 表\nprivate transient volatile Node\u003cK,V\u003e[] nextTable;\n \n// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点\nstatic final class ForwardingNode\u003cK,V\u003e extends Node\u003cK,V\u003e {}\n \n// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node\nstatic final class ReservationNode\u003cK,V\u003e extends Node\u003cK,V\u003e {}\n \n// 作为 treebin 的头节点, 存储 root 和 first\nstatic final class TreeBin\u003cK,V\u003e extends Node\u003cK,V\u003e {}\n \n// 作为 treebin 的节点, 存储 parent, left, right\nstatic final class TreeNode\u003cK,V\u003e extends Node\u003cK,V\u003e {}\n```\n\n### 重要方法\n\n```java\n// 获取 Node[] 中第 i 个 Node\nstatic final \u003cK,V\u003e Node\u003cK,V\u003e tabAt(Node\u003cK,V\u003e[] tab, int i)\n    \n// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值\nstatic final \u003cK,V\u003e boolean casTabAt(Node\u003cK,V\u003e[] tab, int i, Node\u003cK,V\u003e c, Node\u003cK,V\u003e v)\n    \n// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值\nstatic final \u003cK,V\u003e void setTabAt(Node\u003cK,V\u003e[] tab, int i, Node\u003cK,V\u003e v)\n```\n\n### 构造方法\n\n```java\npublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor \u003e 0.0f) || initialCapacity \u003c 0 || concurrencyLevel \u003c= 0)\n        throw new IllegalArgumentException();\n    if (initialCapacity \u003c concurrencyLevel)   // Use at least as many bins\n        initialCapacity = concurrencyLevel;   // as estimated threads\n    long size = (long)(1.0 + (long)initialCapacity / loadFactor);\n    // tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... \n    int cap = (size \u003e= (long)MAXIMUM_CAPACITY) ?\n\t    // tableSizeFor()会将实际大小设置为2^n\n        MAXIMUM_CAPACITY : tableSizeFor((int)size);\n    this.sizeCtl = cap;\n}\n```\n\n### get方法\n\n全程未加锁，性能比较高\n\u003e HashTable的get全程有synchronized锁。\n\n桶下标计算：(n - 1) \u0026 h)，其中n是数组长度，h是hash值，相当于是取模运算，[[3-计算机科学/0-数据结构与算法/快速取模|快速取模]]。\n\n```java\npublic V get(Object key) {\n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e e, p; int n, eh; K ek;\n    // spread 方法能确保返回结果是正数\n    // 负数在接下来的流程中有额外用途\n    int h = spread(key.hashCode());\n    // 如果table不为空并且含有元素\n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026\n\t    // 根据桶下标找链表\n        (e = tabAt(tab, (n - 1) \u0026 h)) != null) {\n        // 如果头结点已经是要查找的 key\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))\n                return e.val;\n        }\n        // hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找\n        else if (eh \u003c 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        // 正常遍历链表, 用 equals 比较\n        while ((e = e.next) != null) {\n            if (e.hash == h \u0026\u0026\n                ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n### put方法\n\n和普通HashMap不同，这里不允许空的kay和value。\n树化阈值是8。\n\n```java\npublic V put(K key, V value) {\n\t// 第三个参数表示重复的key输入，是否用新值覆盖旧值，默认false覆盖\n    return putVal(key, value, false);\n}\n \nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n\t普通hashMap允许有空key和value，这里不允许\n    if (key == null || value == null) throw new NullPointerException();\n    // 其中 spread 方法会综合高位低位, 具有更好的 hash 性\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK,V\u003e[] tab = table;;) {\n        // f 是链表头节点\n        // fh 是链表头结点的 hash\n        // i 是链表在 table 中的下标\n        Node\u003cK,V\u003e f; int n, i, fh;\n        // hash表为空或长度为0：要创建 table （和懒加载有关）\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环\n            tab = initTable();\n        // 要创建链表头节点\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            // 添加链表头使用了 cas, 无需 synchronized\n            if (casTabAt(tab, i, null,\n                         new Node\u003cK,V\u003e(hash, key, value, null)))\n                break;\n        }\n        // 帮忙扩容\n        // 判断头节点是否是forwardingNode\n        else if ((fh = f.hash) == MOVED)\n\t        // 锁住某个待扩容的桶中链表，帮忙扩容\n            // 帮忙之后, 进入下一轮循环\n            tab = helpTransfer(tab, f);\n        // hashTable 即未正在扩容，又已初始化完毕，并产生了冲突\n        else {\n            V oldVal = null;\n            // 锁住链表头节点\n            // 桶下标冲突时才会加锁\n            // 只对该桶链表头节点加锁\n            synchronized (f) {\n                // 再次确认链表头节点没有被移动\n                if (tabAt(tab, i) == f) {\n                    // 链表\n                    if (fh \u003e= 0) {\n                        binCount = 1;  // 链表长度\n                        // key没有要追加，key有了要更新\n                        // 遍历链表\n                        for (Node\u003cK,V\u003e e = f;; ++binCount) {\n                            K ek;\n                            // 找到相同的 key\n                            // hash码相等、同一对象、key值相等\n                            if (e.hash == hash \u0026\u0026\n                                ((ek = e.key) == key ||\n                                 (ek != null \u0026\u0026 key.equals(ek)))) {\n                                oldVal = e.val;\n                                // 更新value\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node\u003cK,V\u003e pred = e;\n                            // 已经是最后的节点了, 新增 Node, 追加至链表尾 \n\n                            if ((e = e.next) == null) {\n                            pred.next = new Node\u003cK,V\u003e(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 红黑树\n                    else if (f instanceof TreeBin) {\n                        Node\u003cK,V\u003e p;\n                        binCount = 2;\n                        // putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode\n                        if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key,\n                                                              value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            // 释放链表头节点的锁\n            }\n\t        //根据链表长度决定优化策略 转红黑树/扩容\n            if (binCount != 0) {                \n                if (binCount \u003e= TREEIFY_THRESHOLD)\n                    // 如果链表长度 \u003e= 树化阈值(8), 进行链表转为红黑树\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // 增加 size 计数\n    // 使用了类似LongAdder的方式\n    // 该方法包含了扩容的逻辑\n    addCount(1L, binCount);\n    return null;\n}\n\n// 保证只有一个线程能成功创建hash表\nprivate final Node\u003cK,V\u003e[] initTable() {\n    Node\u003cK,V\u003e[] tab; int sc;\n    // 若hash表还未被创建\n    while ((tab = table) == null || tab.length == 0) {\n\t    // 有其它线程正在创建hash表了\n        if ((sc = sizeCtl) \u003c 0)\n            Thread.yield();  // 让出cpu使用权（弱让出）\n        // 尝试将 sizeCtl 设置为 -1（-1表示初始化 table）\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            // 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建 \n            try {\n                if ((tab = table) == null || tab.length == 0) {\n\t                // 使用预设容量sc进行hash表创建\n\t                // 默认容量16\n                    int n = (sc \u003e 0) ? sc : DEFAULT_CAPACITY;\n                    Node\u003cK,V\u003e[] nt = (Node\u003cK,V\u003e[])new Node\u003c?,?\u003e[n];\n                    table = tab = nt;\n                    // sc转成下次要扩容时的阈值\n                    sc = n - (n \u003e\u003e\u003e 2);\n                }\n\n            } finally {\n            sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n \n// check 是之前 binCount 的个数\nprivate final void addCount(long x, int check) {\n    CounterCell[] as; long b, s;\n    if (\n        // 已经有了 counterCells, 向 cell 累加\n        (as = counterCells) != null ||\n        // 还没有, 向 baseCount 累加\n        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)\n    ) {\n        CounterCell a; long v; int m;\n        boolean uncontended = true;\n        if (\n            // 还没有 counterCells\n            as == null || (m = as.length - 1) \u003c 0 ||\n            // 还没有 cell\n            (a = as[ThreadLocalRandom.getProbe() \u0026 m]) == null ||\n            // cell cas 增加计数失败\n            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))\n           ) {\n            // 创建累加单元数组和cell, 累加重试\n            fullAddCount(x, uncontended);\n            return;\n        }\n        if (check \u003c= 1)\n            return;\n        // 获取元素个数\n        s = sumCount();\n    }\n    if (check \u003e= 0) {\n        Node\u003cK,V\u003e[] tab, nt; int n, sc;\n        while (s \u003e= (long)(sc = sizeCtl) \u0026\u0026 (tab = table) != null \u0026\u0026\n               (n = tab.length) \u003c MAXIMUM_CAPACITY) {\n            int rs = resizeStamp(n);\n            if (sc \u003c 0) {\n                if ((sc \u003e\u003e\u003e RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex \u003c= 0)\n                    break;\n                // newtable 已经创建了，帮忙扩容\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            // 需要扩容，这时 newtable 未创建\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n\n                                         (rs \u003c\u003c RESIZE_STAMP_SHIFT) + 2))\n                                         transfer(tab, null);\n            s = sumCount();\n        }\n    }\n}\n```\n\n### size方法\n\nsize 计算实际发生在 put，remove 改变集合元素的操作之中\n- 没有竞争发生，向 baseCount 累加计数\n- 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数\n\t- counterCells 初始有两个 cell\n\t- 如果计数竞争比较激烈，会创建新的 cell 来累加计数\n\n```java\npublic int size() {\n    long n = sumCount();\n    return ((n \u003c 0L) ? 0 :\n            (n \u003e (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :\n            (int)n);\n}\n \nfinal long sumCount() {\n    CounterCell[] as = counterCells; CounterCell a;\n    // 将 baseCount 计数与所有 cell 计数累加\n    long sum = baseCount;\n    if (as != null) {\n        for (int i = 0; i \u003c as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\n```\n\n## 总结\n\nJava 8 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）\n\n- 初始化，使用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|cas]] 来保证并发安全，**懒惰**初始化 table\n- 树化，当 table.length \u003c **64** 时，先尝试**扩容**，超过 64 时，并且 bin.length \u003e **8** 时，会将链表树化，树化过程会用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]] 锁住链表头\n- put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的**尾部**\n- get，**无锁**操作仅需要保证[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]]，扩容过程中 get 操作在旧table拿到的是 ForwardingNode 则说明正在扩容并且当前桶已被搬迁，它会让 get 操作在新 table 进行搜索\n- 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]，但这时妙的是其它竞争[[3-计算机科学/2-计算机组成原理/线程|线程]]也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 **1/6** 的节点会被复制到新 table 中\n- size，元素个数保存在 baseCount 中，[[3-计算机科学/2-计算机组成原理/并发|并发]]时的个数变动保存在 CounterCell[] 当中（类似[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/LongAdder|LongAdder]]）。最后统计数量时累加即可","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentLinkedQueue":{"title":"ConcurrentLinkedQueue","content":"# ConcurrentLinkedQueue\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CountdownLatch":{"title":"CountdownLatch","content":"# CountdownLatch\n\n用来进行[[3-计算机科学/2-计算机组成原理/线程|线程]][[3-计算机科学/2-计算机组成原理/同步|同步]]协作，等待所有线程完成倒计时。\n其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一\n\n## 使用\n\n### 基本流程\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n \n    new Thread(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    }).start();\n \n    new Thread(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    }).start();\n \n    new Thread(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    }).start();\n \n    log.debug(\"waiting...\");\n    latch.await();\n    log.debug(\"wait end...\");\n}\n```\n\n\u003e当然可以用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/join|join]]实现类似功能，但join是更底层的接口，使用起来比较繁琐。\n\n### 配合线程池\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    service.submit(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    service.submit(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    service.submit(() -\u003e {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    service.submit(()-\u003e{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n## 原理\n\n**CountDownLatch**是一种同步辅助，让我们多个线程执行任务时，需要等待线程执行完成后，才能执行下面的语句，之前线程操作时是使用`Thread.join`方法进行等待，**CountDownLatch**内部使用了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/AQS|AQS]]锁，其实内部有一个**state**字段，通过该字段来控制锁的操作。\n\n**CountDownLatch**内部是将**state**作为计数器来使用，比如我们初始化时，**state**计数器为3，同时开启三个线程当有一个线程执行成功，每当有一个线程执行完成后就将**state**值减少1，直到减少到为0时，说明所有线程已经执行完毕。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier":{"title":"CyclicBarrier","content":"# CyclicBarrier\n\n[ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。\n\n\u003e 与CountdownLatch不同，CyclicBarrier可以重复使用。\n\n```java\nCyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行\n \nnew Thread(()-\u003e{\n    System.out.println(\"线程1开始..\"+new Date());\n    try {\n        cb.await(); // 当个数不足时，等待\n    } catch (InterruptedException | BrokenBarrierException e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"线程1继续向下运行...\"+new Date());\n}).start();\n \nnew Thread(()-\u003e{\n    System.out.println(\"线程2开始..\"+new Date());\n    try { Thread.sleep(2000); } catch (InterruptedException e) { }\n    try {\n        cb.await(); // 2 秒后，线程个数够2，继续运行\n    } catch (InterruptedException | BrokenBarrierException e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"线程2继续向下运行...\"+new Date());\n}).start();\n```\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/FutureTask":{"title":"FutureTask","content":"# FutureTask\n\nFutureTask 能够接收 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Callable|Callable]] 类型的参数，用来处理有返回结果的情况。\n\n```java\nFutureTask\u003cV\u003e implements RunnableFuture\u003cV\u003e\ninterface RunnableFuture\u003cV\u003e extends Runnable, Future\u003cV\u003e  // Future.get()用来返回任务的返回值\n\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C":{"title":"原子操作","content":"# 原子操作\n\nJDK提供了一些用于原子操作的类，在`java.util.concurrent.atomic`包下面。在JDK 11中，有如下17个类：\n![[z-oblib/z2-attachments/原子类 1.jpg]]\n从名字就可以看得出来这些类大概的用途：\n\n- 原子更新基本类型\n- 原子更新数组\n- 原子更新引用\n- 原子更新字段（属性）\n\n## 以`AtomicInteger`的`getAndAdd(int delta)`方法为例\n\n\u003e实际就是调用native方法，获取某个对象内存空间偏移offset处的变量，循环尝试获取该变量的值是否与线程持有值一致，一致则替换成目标值，不一致表示有其它线程修改过了。\n\n先看看这个方法的源码：\n\n```java\npublic final int getAndAdd(int delta) {\n    return U.getAndAddInt(this, VALUE, delta);\n}\n```\n\n这里的U其实就是一个`Unsafe`对象：\n\n```java\nprivate static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();\n```\n\n所以其实`AtomicInteger`类的`getAndAdd(int delta)`方法是调用`Unsafe`类的方法来实现的：\n\n```java\n@HotSpotIntrinsicCandidate\npublic final int getAndAddInt(Object o, long offset, int delta) {\n    int v;\n    do {\n        v = getIntVolatile(o, offset);\n    } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n    return v;\n}\n```\n\n\u003e 注：这个方法是在JDK 1.8才新增的。在JDK1.8之前，`AtomicInteger`源码实现有所不同，是基于for死循环的，有兴趣的读者可以自行了解一下。\n\n我们来一步步解析这段源码。首先，对象`o`是`this`，也就是一个`AtomicInteger`对象。然后`offset`是一个常量`VALUE`。这个常量是在`AtomicInteger`类中声明的：\n\n```java\nprivate static final long VALUE = U.objectFieldOffset(AtomicInteger.class, \"value\");\n```\n\n同样是调用的`Unsafe`的方法。从方法名字上来看，是得到了一个对象字段偏移量。\n\n\u003e 用于获取某个字段相对Java对象的“起始地址”的偏移量。\n\u003e \n\u003e 一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，\n\u003e \n\u003e 用这个方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。\n\n继续看源码。前面我们讲到，[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|CAS]]是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。\n\n这里声明了一个v，也就是要返回的值。从`getAndAddInt`来看，它返回的应该是原来的值，而新的值的`v + delta`。\n\n这里使用的是**do-while循环**。这种循环不多见，它的目的是**保证循环体内的语句至少会被执行一遍**。这样才能保证return 的值`v`是我们期望的值。\n\n循环体的条件是一个CAS方法：\n\n```java\npublic final boolean weakCompareAndSetInt(Object o, long offset,\n                                          int expected,\n                                          int x) {\n    return compareAndSetInt(o, offset, expected, x);\n}\n\npublic final native boolean compareAndSetInt(Object o, long offset,\n                                             int expected,\n                                             int x);\n```\n\n可以看到，最终其实是调用的我们之前说到了CAS [[native|native]]方法。那为什么要经过一层`weakCompareAndSetInt`呢？从JDK源码上看不出来什么。在JDK 8及之前的版本，这两个方法是一样的。\n\n\u003e 而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。\n\n根据本文第一篇参考文章（文末链接），它跟[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]有关。\n\n简单来说，`weakCompareAndSet`操作仅保留了`volatile`自身变量的特性，而除去了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/happens-before|happens-before]]规则带来的内存语义。也就是说，`weakCompareAndSet`**无法保证处理操作目标的volatile变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。**这在一定程度上可以提高性能。\n\n再回到循环条件上来，可以看到它是在不断尝试去用CAS更新。如果更新失败，就继续重试。那为什么要把获取“旧值”v的操作放到循环体内呢？其实这也很好理解。前面我们说了，CAS如果旧值V不等于预期值E，它就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他[[3-计算机科学/2-计算机组成原理/线程|线程]]改变之后的旧值了，因此放在了do循环体内。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%AE%9E%E7%8E%B0%E7%9A%84CAS":{"title":"Java实现的CAS","content":"# Java实现的CAS\n\n前面提到，CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。\n\n在Java中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法，其中就有几个关于CAS的：\n\n```java\nboolean compareAndSwapObject(Object o, long offset,Object expected, Object x);\nboolean compareAndSwapInt(Object o, long offset,int expected,int x);\nboolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n当然，他们都是`public native`的。\n\nUnsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。\n\nLinux的X86下主要是通过`cmpxchgl`这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用`lock`指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。\n\n当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的`park`和`unpark`， LockSupport类底层就是调用了这两个方法。还有支持反射操作的`allocateInstance()`方法。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LinkedBlockingQueue":{"title":"LinkedBlockingQueue","content":"# LinkedBlockingQueue\n\n## 入队出队\n\n类似[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/AQS|AQS]]中的等待队列:\n\n```java\npublic class LinkedBlockingQueue\u003cE\u003e extends AbstractQueue\u003cE\u003e\n        implements BlockingQueue\u003cE\u003e, java.io.Serializable {\n    static class Node\u003cE\u003e {\n    E item;\n \n        /**\n         * 下列三种情况之一\n         * - 真正的后继节点\n         * - 自己, 发生在出队时\n         * - null, 表示是没有后继节点, 是最后了\n         */\n        Node\u003cE\u003e next;\n \n        Node(E x) { item = x; }\n    }\n}\n```\n\n1. 初始化链表 `last = head = new Node\u003cE\u003e(null);` Dummy 节点用来占位，item 为 null\n![[z-oblib/z2-attachments/Pasted image 20220613205635.png]]\n2. 当一个节点入队 last = last.next = node;\n![[z-oblib/z2-attachments/Pasted image 20220613205651.png]]\n3. 再来一个节点入队 last = last.next = node;\n![[z-oblib/z2-attachments/Pasted image 20220613205701.png]]\n4. 出队\n```java\nNode\u003cE\u003e h = head;\nNode\u003cE\u003e first = h.next;\nh.next = h; // help GC\nhead = first;\nE x = first.item;\nfirst.item = null;\nreturn x;\n```\nh = head\n![[z-oblib/z2-attachments/Pasted image 20220613205729.png]]\nfirst = h.next\n![[z-oblib/z2-attachments/Pasted image 20220613205737.png]]\nh.next = h\n![[z-oblib/z2-attachments/Pasted image 20220613205741.png]]\nhead = first\n```java\nE x = first.item;\nfirst.item = null;\nreturn x;\n```\n![[z-oblib/z2-attachments/Pasted image 20220613205753.png]]\n\n## 加锁\n\n==高明之处==在于用了两把锁和 dummy 节点：\n- 用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行\n- 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行\n\t- 消费者与消费者线程仍然串行\n\t- 生产者与生产者线程仍然串行\n\n线程安全分析：\n- 当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争\n- 当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争\n- 当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞\n\n```java\n// 用于 put(阻塞) offer(非阻塞)\nprivate final ReentrantLock putLock = new ReentrantLock();\n \n// 用户 take(阻塞) poll(非阻塞)\nprivate final ReentrantLock takeLock = new ReentrantLock();\n```\n\n### put方法\n\n特点：由生产者叫醒其它生产者，使用signal而不是signalAll，防止不必要的竞争。\n\n```java\npublic void put(E e) throws InterruptedException {\nif (e == null) throw new NullPointerException();\n    int c = -1;\n    Node\u003cE\u003e node = new Node\u003cE\u003e(e);\n    final ReentrantLock putLock = this.putLock;\n    // count 用来维护元素计数\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        // 满了等待\n        while (count.get() == capacity) {\n            // 倒过来读就好: 等待 notFull\n            notFull.await();\n        }\n        // 有空位, 入队且计数加一\n        enqueue(node);\n        // c取得时count+1前的值\n        c = count.getAndIncrement();  \n        // 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程\n        if (c + 1 \u003c capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    // 如果队列中有一个元素, 叫醒 take 线程\n    if (c == 0)\n        // 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争\n        signalNotEmpty();\n}\n```\n\n### take方法\n\n```java\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c \u003e 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    // 如果队列中只有一个空位时, 叫醒 put 线程\n    // 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c \u003c capacity\n    if (c == capacity)\n        // 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争\n        signalNotFull()\n        return x;\n}\n```\n\n## 性能分析\n\n主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较\n- Linked 支持有界，Array 强制有界\n- Linked 实现是链表，Array 实现是数组\n- Linked 是懒惰的，而 Array 需要提前初始化 Node 数组\n- Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的，减少垃圾回收开销\n- Linked 两把锁，Array 一把锁，Linked性能更好","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LongAdder":{"title":"LongAdder","content":"# LongAdder\n\n## 原理\n\nLongAdder 类有几个关键域：\n```java\n// 累加单元数组, 懒惰初始化\ntransient volatile Cell[] cells;\n \n// 基础值, 如果没有竞争, 则用 cas 累加这个域\ntransient volatile long base;\n \n// 在 cells 创建或扩容时, 置为 1, 表示加锁\ntransient volatile int cellsBusy;\n```\n\ncellsBusy用到了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS锁|CAS锁]]的方法。\n\n### Cell\n\nCell为累加单元：\n\n```java\n// 防止缓存行伪共享\n@sun.misc.Contended \nstatic final class Cell {\n    volatile long value;\n    Cell(long x) { value = x; }\n    \n    // 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值\n    final boolean cas(long prev, long next) {\n        return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);\n    }\n    // 省略不重要代码\n}\n```\n\n[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/伪共享|伪共享]]","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock":{"title":"ReentrantLock","content":"# ReentrantLock\n\n\u003e 相当于是一个java层面实现的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|monitor]]。\n\n## 特点\n\n相对于 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]] 它具备如下特点：\n- 可中断（放弃争抢锁）\n- 可以设置超时时间\n- 可以设置为公平锁\n\t- 先到先得，而不是随机争抢\n\t- 解决线程[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/饥饿|饥饿]]问题\n- 支持多个条件变量\n\t- 条件变量相当于synchronized中的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/wait\u0026notify|waitSet]]，不满足条件的可以在wait_set等待\n\t- 支持多个条件变量意味着有多个waitSet，可以根据不同条件进入不同set等待\n- 与 synchronized 一样，都支持可重入\n\n\u003e state标识资源是否为锁定状态。\n\n## 语法\n\n```java\n// 获取锁\nreentrantLock.lock();\ntry {\n    // 临界区\n} finally {\n    // 释放锁\n    reentrantLock.unlock();\n}\n```\n\n\u003e 阿里手册：reentrantLock.lock()放在try外。\n\n要保证：\n- lock/unlock成对出现\n- unlock在finally中执行\n\n## 特性\n\n### 可重入\n\nsynchronized(对象)中对象的作用实际上是一个指针，关连（指向）了底层的monitor对象，而reentrantLock的对象本身就是类似一个Monitor的存在。\n\n```java\nstatic ReentrantLock lock = new ReentrantLock();\n \npublic static void main(String[] args) {\n    method1();\n}\n \npublic static void method1() {\n    lock.lock();\n    try {\n        log.debug(\"execute method1\");\n        method2();\n    } finally {\n        lock.unlock();\n    }\n}\n \npublic static void method2() {\n    lock.lock();\n    try {\n        log.debug(\"execute method2\");\n        method3();\n    } finally {\n        lock.unlock();\n    }\n}\n \npublic static void method3() {\n    lock.lock();\n    try {\n        log.debug(\"execute method3\");\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n- 当lock.lock()成功，则当前线程成为lock的owner\n- 当lock.lock()失败，当前线程会被加入到lock的等待队列中\n\n### 可打断\n\n\u003e 被动避免死等\n\n等待锁的过程中，其它[[3-计算机科学/2-计算机组成原理/线程|线程]]可以用interrupt()终止我的等待。\n\n```java\nReentrantLock lock = new ReentrantLock();\n \nThread t1 = new Thread(() -\u003e {\nlog.debug(\"启动...\");\n    try {\n        lock.lockInterruptibly();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n        log.debug(\"等锁的过程中被打断\");\n        return;\n    }\n    try {\n        log.debug(\"获得了锁\");\n    } finally {\n        lock.unlock();\n    }\n}, \"t1\");\n \n \nlock.lock();\nlog.debug(\"Main获得了锁\");\nt1.start();\ntry {\n    sleep(1);\n    t1.interrupt();\n    log.debug(\"执行打断\");\n} finally {\n    lock.unlock();\n}\n```\n\n### 锁超时\n\n\u003e主动避免死等\n\n```java\nReentrantLock lock = new ReentrantLock();\nThread t1 = new Thread(() -\u003e {\n    log.debug(\"启动...\");\n    if (!lock.tryLock()) {\n        log.debug(\"获取立刻失败，返回\");\n        return;\n    }\n    try {\n        log.debug(\"获得了锁\");\n    } finally {\n        lock.unlock();\n    }\n}, \"t1\");\n \nlock.lock();\nlog.debug(\"获得了锁\");\nt1.start();\ntry {\n    sleep(2);\n} finally {\n    lock.unlock();\n}\n```\n\n### 公平锁\n\n\u003e不公平：新线程会无视队列尝试获取一次锁，失败则进入等待队列。等待队列中的线程还是有序唤醒的。\n\u003e公平锁一般没有必要，会降低[[3-计算机科学/2-计算机组成原理/并发|并发]]性能。\n\n### 条件变量\n\n- synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待\n- ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比\n\t- synchronized 是那些不满足条件的线程都在一间休息室等消息\n\t- 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒\n\n使用要点：\n- await 前需要获得锁\n- await 执行后，会释放锁，进入 conditionObject 等待\n- await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁\n- 竞争 lock 锁成功后，从 await 后继续执行\n\n```java\nstatic ReentrantLock lock = new ReentrantLock();\nstatic Condition waitCigaretteQueue = lock.newCondition();\nstatic Condition waitbreakfastQueue = lock.newCondition();\nstatic volatile boolean hasCigrette = false;\nstatic volatile boolean hasBreakfast = false;\n \npublic static void main(String[] args) {\n    new Thread(() -\u003e {\n        try {\n            lock.lock();\n            while (!hasCigrette) {\n            try {\n                    waitCigaretteQueue.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            log.debug(\"等到了它的烟\");\n        } finally {\n            lock.unlock();\n        }\n    }).start();\n \n    new Thread(() -\u003e {\n        try {\n            lock.lock();\n            while (!hasBreakfast) {\n                try {\n                    waitbreakfastQueue.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            log.debug(\"等到了它的早餐\");\n        } finally {\n            lock.unlock();\n        }\n    }).start();\n \n    sleep(1);\n    sendBreakfast();\n    sleep(1);\n    sendCigarette();\n}\n \nprivate static void sendCigarette() {\n    lock.lock();\n    try {\n        log.debug(\"送烟来了\");\n        hasCigrette = true;\n        waitCigaretteQueue.signal();\n    } finally {\n        lock.unlock();\n    }\n}\n \nprivate static void sendBreakfast() {\n    lock.lock();\n    try {\n        log.debug(\"送早餐来了\");\n        hasBreakfast = true;\n        waitbreakfastQueue.signal();\n    } finally {\n\n        lock.unlock();\n        }\n}\n```\n\n## 原理\n\n\u003e 头节点必定是一个线程为null的哨兵节点，防止等待队列被删到空。\n\n### 非公平\n\n![[z-oblib/z2-attachments/Pasted image 20220609203458.png]]\n\n#### 加解锁流程\n\n从构造器开始看，默认为非公平锁实现：\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n\n\u003e NonfairSync 继承自 AQS。\n\n无竞争时：\n\n![[z-oblib/z2-attachments/Pasted image 20220609210612.png]]\n\n出现第一个竞争：\n\n![[z-oblib/z2-attachments/Pasted image 20220609210641.png]]\n\nThread-1 执行了：\n1. CAS 尝试将 state 由 0 改为 1，结果失败\n2. 进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败\n3. 接下来进入 addWaiter 逻辑，构造 Node 队列\n\t- 图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态\n\t- Node 的创建是懒惰的\n\t- 其中第**一**个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程\n\n\u003e 哨兵节点当作是一个一直存在的等待队列头节点。作用是防止等待队列被删到空。\n\u003e 因为出队和入队可能同时发生，如果队列长度是1，此时把头节点直接删掉，可能导致新加到队尾的节点链到了错误的前驱节点，造成空指针异常。\n\u003e 所以将废弃的节点值置为null，当作新的头节点（哨兵节点），而不是直接删除。\n\n![[z-oblib/z2-attachments/Pasted image 20220609211231.png]]\n\n当前线程进入 **acquireQueued** 逻辑：\n1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞\n2. 如果自己是紧邻着 head（排第**二**位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败\n3. 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false\n![[z-oblib/z2-attachments/Pasted image 20220609211430.png]]\n4. shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败\n5. 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true\n6. 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）\n\n![[z-oblib/z2-attachments/Pasted image 20220609211502.png]]\n再次有多个线程经历上述过程竞争失败，变成这个样子\n![[z-oblib/z2-attachments/Pasted image 20220609211515.png]]\nThread-0 释放锁，进入 tryRelease 流程，如果成功\n- 设置 exclusiveOwnerThread 为 null\n- state = 0\n\n![[z-oblib/z2-attachments/Pasted image 20220609211528.png]]\n当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程\n找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1\n回到 Thread-1 的 acquireQueued 流程\n\n![[z-oblib/z2-attachments/Pasted image 20220609211542.png]]\n如果加锁成功（没有竞争），会设置\n- exclusiveOwnerThread 为 Thread-1，state = 1\n- head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread\n\u003e 清空后，Thread-1节点被当作新的哨兵节点\n- 原本的 head 因为从链表断开，而可被垃圾回收\n如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了\n\n![[z-oblib/z2-attachments/Pasted image 20220609211557.png]]\n如果不巧又被 Thread-4 占了先\n- Thread-4 被设置为 exclusiveOwnerThread，state = 1\n- Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞\n\n#### 加锁源码\n\n```java\n// Sync 继承自 AQS\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n    \n    // 加锁实现\n    final void lock() {\n        // 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            // 如果尝试失败，进入 ㈠\n            acquire(1);\n    }\n    \n    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处\n    public final void acquire(int arg) {\n        // ㈡ tryAcquire        \n        if (\n            !tryAcquire(arg) \u0026\u0026 \n            // 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        ) {\n            selfInterrupt();\n        }\n    }\n    \n    // ㈡ 进入 ㈢\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n    \n    // ㈢ Sync 继承过来的方法, 方便阅读, 放在此处\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        // 如果还没有获得锁\n        if (c == 0) {\n            // 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入\n        else if (current == getExclusiveOwnerThread()) {\n            // state++\n            int nextc = c + acquires;\n            if (nextc \u003c 0) // overflow\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        // 获取失败, 回到调用处\n        return false;\n    }\n    \n    // ㈣ AQS 继承过来的方法, 方便阅读, 放在此处\n\n    private Node addWaiter(Node mode) {\n    // 将当前线程关联到一个 Node 对象上, 模式为独占模式\n        Node node = new Node(Thread.currentThread(), mode);\n        // 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                // 双向链表\n                pred.next = node;\n                return node;\n            }\n        }\n        // 尝试将 Node 加入 AQS, 进入 ㈥\n        enq(node);\n        return node;\n    }\n    \n    // ㈥ AQS 继承过来的方法, 方便阅读, 放在此处\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) {\n                // 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）\n                if (compareAndSetHead(new Node())) {\n                    tail = head;\n                }\n            } else {\n                // cas 尝试将 Node 对象加入 AQS 队列尾部\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n    \n    // ㈤ AQS 继承过来的方法, 方便阅读, 放在此处\n    final boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                // 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取\n                if (p == head \u0026\u0026 tryAcquire(arg)) {\n                    // 获取成功, 设置自己（当前线程对应的 node）为 head\n                    setHead(node);\n                    // 上一个节点 help GC\n                    p.next = null;\n                    failed = false;\n                    // 返回中断标记 false\n\n                    return interrupted;\n                    }\n                if (\n                    // 判断是否应当 park, 进入 ㈦\n                    shouldParkAfterFailedAcquire(p, node) \u0026\u0026\n                    // park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧\n                    parkAndCheckInterrupt()\n                ) {\n                    interrupted = true;\n                }\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n    \n    // ㈦ AQS 继承过来的方法, 方便阅读, 放在此处\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        // 获取上一个节点的状态\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL) {\n            // 上一个节点都在阻塞, 那么自己也阻塞好了\n            return true;\n        }\n        // \u003e 0 表示取消状态\n        if (ws \u003e 0) {\n            // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus \u003e 0);\n            pred.next = node;\n        } else {\n            // 这次还没有阻塞\n            // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n    \n    // ㈧ 阻塞当前线程\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n}\n```\n\n\u003e是否需要 unpark 是由当前节点的**前驱**节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的  waitStatus 决定\n\n#### 解锁源码\n\n```java\n// Sync 继承自 AQS\nstatic final class NonfairSync extends Sync {\n    // 解锁实现\n    public void unlock() {\n        sync.release(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final boolean release(int arg) {\n        // 尝试释放锁, 进入 ㈠\n        if (tryRelease(arg)) {\n            // 队列头节点 unpark\n            Node h = head;            \n            if (\n                // 队列不为 null\n                h != null \u0026\u0026 \n                // waitStatus == Node.SIGNAL 才需要 unpark\n                h.waitStatus != 0\n            ) {\n                // unpark AQS 中等待的线程, 进入 ㈡\n                unparkSuccessor(h);\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    // ㈠ Sync 继承过来的方法, 方便阅读, 放在此处\n    protected final boolean tryRelease(int releases) {\n        // state--\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;\n        // 支持锁重入, 只有 state 减为 0, 才释放成功\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n    \n    // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处\n    private void unparkSuccessor(Node node) {\n        // 如果状态为 Node.SIGNAL 尝试重置状态为 0\n        // 不成功也可以\n        int ws = node.waitStatus;\n        if (ws \u003c 0) {\n            compareAndSetWaitStatus(node, ws, 0);\n        }\n \n        // 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的\n        Node s = node.next;\n        // 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点\n        if (s == null || s.waitStatus \u003e 0) {\n            s = null;\n            for (Node t = tail; t != null \u0026\u0026 t != node; t = t.prev)\n                if (t.waitStatus \u003c= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n}\n```\n\n### 可重入\n\n```java\nstatic final class NonfairSync extends Sync {\n    // ...\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入\n        else if (current == getExclusiveOwnerThread()) {\n            // state++\n            int nextc = c + acquires;\n            if (nextc \u003c 0) // overflow\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    protected final boolean tryRelease(int releases) {\n        // state--(releases==1) \n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;  // 只减计数，未释放锁\n        // 支持锁重入, 只有 state 减为 0, 才释放成功\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n}\n```\n\n### 不可打断\n\n\u003e 默认的模式。\n\n在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了：\n\n```java\n// Sync 继承自 AQS\nstatic final class NonfairSync extends Sync {\n    // ...\n    \n    private final boolean parkAndCheckInterrupt() {\n        // 如果打断标记已经是 true, 则 park 会失效\n        LockSupport.park(this);\n        // 返回是否被打断过，interrupted 会清除打断标记（为了二次park不受标记影响）\n        return Thread.interrupted();\n    }\n\t// 线程没法立刻获得锁时，会进入该方法\n    final boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head \u0026\u0026 tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null;\n                    failed = false;\n                    // 还是需要获得锁后, 才能返回打断状态（返回到acquire里）\n                    return interrupted;\n                }\n                if (\n                    shouldParkAfterFailedAcquire(p, node) \u0026\u0026\n                    parkAndCheckInterrupt()\n                ) {\n                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true\n                    interrupted = true;\n                    // 但是没有做其它处理，还是会进入循环\n                    // 循环中还是会去尝试获取锁，进入park阻塞\n                }\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n    \n\n    public final void acquire(int arg) {\n    if (\n            !tryAcquire(arg) \u0026\u0026 \n            // 前面函数被打断后返回到这里\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        ) {\n            // 如果打断状态为 true，会执行下属方法\n            // 重新产生一次中断\n            selfInterrupt();\n        }\n    }\n    \n    static void selfInterrupt() {\n        // 重新产生一次中断\n        Thread.currentThread().interrupt();\n    }\n}\n```\n\n### 可打断\n\n```java\nstatic final class NonfairSync extends Sync {\n    public final void acquireInterruptibly(int arg) throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        // 如果没有获得到锁, 进入 ㈠\n        if (!tryAcquire(arg))\n            doAcquireInterruptibly(arg);\n    }\n    \n    // ㈠ 可打断的获取锁流程\n    private void doAcquireInterruptibly(int arg) throws InterruptedException {\n        final Node node = addWaiter(Node.EXCLUSIVE);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head \u0026\u0026 tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) \u0026\u0026\n                    parkAndCheckInterrupt()) {\n                    // 在 park 过程中如果被 interrupt 会进入此\n                    // 这时候抛出异常, 而不会再次进入 for (;;)\n                    throw new InterruptedException();\n                    // 不会再进入for循环等待\n                }\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n}\n```\n\n### 非公平锁\n\n\n\n### 公平锁\n\n\u003e 先检查等待队列是否为空，而不是上来就CAS抢占锁。\n\n```java\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n \n    final void lock() {\n        acquire(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final void acquire(int arg) {\n        if (\n            !tryAcquire(arg) \u0026\u0026 \n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        ) {\n            selfInterrupt();\n        }\n    }\n \n    // 与非公平锁主要区别在于 tryAcquire 方法的实现\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 先检查 AQS 队列中是否有前驱节点, 没有才去竞争\n            // 而不是上来就尝试CAS\n            if (!hasQueuedPredecessors() \u0026\u0026\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc \u003c 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n    \n    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处\n    public final boolean hasQueuedPredecessors() {\n        Node t = tail;\n        Node h = head;\n        Node s;\n        // h != t 时表示队列中有 Node\n        return h != t \u0026\u0026\n            (\n\t            // 老大是占位用的节点\n                // (s = h.next) == null 表示队列中还有没有老二\n                (s = h.next) == null || \n                // 或者队列中老二线程不是此线程\n                s.thread != Thread.currentThread()\n            );\n    }\n}\n```\n\n### 条件变量\n\n每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject:\n\n#### await流程\n\n开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程。\n创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部。\n\n![[z-oblib/z2-attachments/Pasted image 20220609233958.png]]\n\n接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁：\n\u003efullyRelease是释放掉重入的锁。\n\n![[z-oblib/z2-attachments/Pasted image 20220609234005.png]]\n\n当前线程释放锁，unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功：\n\n![[z-oblib/z2-attachments/Pasted image 20220609234027.png]]\n\npark 阻塞 Thread-0：\n\n![[z-oblib/z2-attachments/Pasted image 20220609234041.png]]\n\n```java\npublic final void await() throws InterruptedException {  \n    if (Thread.interrupted())  \n        throw new InterruptedException();  \n    Node node = addConditionWaiter();  \n    // fullyRelease作用是可以释放掉重入的锁\n    int savedState = fullyRelease(node);  \n    int interruptMode = 0;  \n    while (!isOnSyncQueue(node)) {  \n\t    // 阻塞自己， 等待被唤醒\n        LockSupport.park(this);  \n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)  \n            break;  \n    }  \n    if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE)  \n        interruptMode = REINTERRUPT;  \n    if (node.nextWaiter != null) // clean up if cancelled  \n        unlinkCancelledWaiters();  \n    if (interruptMode != 0)  \n        reportInterruptAfterWait(interruptMode);  \n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantReadWriteLock":{"title":"ReentrantReadWriteLock","content":"# ReentrantReadWriteLock\n\n当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select ...from ... lock in share mode\n提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：\n\n## 使用\n\n```java\nclass DataContainer {\n    private Object data;\n    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();\n    private ReentrantReadWriteLock.ReadLock r = rw.readLock();\n    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();\n \n    public Object read() {\n        log.debug(\"获取读锁...\");\n        r.lock();\n        try {\n            log.debug(\"读取\");\n            sleep(1);\n            return data;\n        } finally {\n            log.debug(\"释放读锁...\");\n            r.unlock();\n        }\n    }\n \n    public void write() {\n        log.debug(\"获取写锁...\");\n        w.lock();\n        try {\n            log.debug(\"写入\");\n            sleep(1);\n        } finally {\n            log.debug(\"释放写锁...\");\n            w.unlock();\n        }\n    }\n}\n```\n\n### 注意\n\n读锁不支持条件变量\n重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待\n```java\nr.lock();\ntry {\n    // ...\n    w.lock();\n    try {\n        // ...\n    } finally{\n        w.unlock();\n    }\n} finally{\n  r.unlock();\n}\n \n```\n- 重入时降级支持：即持有写锁的情况下去获取读锁\n```java\n// 缓存数据操作示例\nclass CachedData {\n   Object data;\n    // 是否有效，如果失效，需要重新计算 data\n   volatile boolean cacheValid;\n   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n   void processCachedData() {\n\t// 先获取读锁\n     rwl.readLock().lock();\n     // 判断缓存数据没有失效\n     if (!cacheValid) {\n       // 获取写锁前必须释放读锁\n       // 读锁不支持升级成写锁\n       rwl.readLock().unlock();\n       rwl.writeLock().lock();\n       try {\n\t      // 双重检查\n         // 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新\n         if (!cacheValid) {\n           data = ...\n           cacheValid = true;\n         }\n         // 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存\n         rwl.readLock().lock();\n       } finally {\n       // 释放写锁的一瞬间会切换为读锁\n       rwl.writeLock().unlock();\n       }\n     }\n     // 自己用完数据, 释放读锁  \n     try {\n       use(data);\n     } finally {\n       rwl.readLock().unlock();\n     }\n   }\n}\n```\n\u003e 用到了[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式#双重校验锁|双重校验]]的思路。\n\n## 应用\n\n\u003e 保证缓存与数据库之间的一致性。\n\n涉及到[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/缓存更新策略|缓存更新策略]]的问题。\n\n使用读写锁实现一个简单的按需加载缓存，[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/一致性缓存|一致性缓存]]。\n\n## 流程\n\n\u003e state标识是否为锁定状态，并且通过把32位拆分成高低16位，区分是读/写锁。\n\n### t1 w.lock，t2 r.lock\n\n1. t1 成功上锁，流程与 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/ReentrantLock|ReentrantLock]] 加锁相比没有特殊之处，不同是**写**锁状态占了 state 的**低** 16 位，而**读**锁使用的是 state 的**高** 16 位。\n![[z-oblib/z2-attachments/Pasted image 20220610202746.png]]\n2. t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败\n\t- tryAcquireShared 返回值表示：\n\t\t- -1 表示失败\n\t\t- 0 表示成功，但后继节点不会继续唤醒\n\t\t- 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1\n![[z-oblib/z2-attachments/Pasted image 20220610202901.png]]\n3. 这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态\n![[z-oblib/z2-attachments/Pasted image 20220610202935.png]]\n4. t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁\n5. 如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park\n![[z-oblib/z2-attachments/Pasted image 20220610203007.png]]\n\n ### t3 r.lock，t4 w.lock \n\n这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子：\n![[z-oblib/z2-attachments/Pasted image 20220610203154.png]]\n\n### t1 w.unlock\n\n![[z-oblib/z2-attachments/Pasted image 20220610204847.png]]\n1. 接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行\n2. 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一\n3. 这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点\n![[z-oblib/z2-attachments/Pasted image 20220610204940.png]]\n4. **一次性解锁多个连续的share节点**：事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行\n5. 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一\n![[z-oblib/z2-attachments/Pasted image 20220610205244.png]]\n6. 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点\n![[z-oblib/z2-attachments/Pasted image 20220610205306.png]]\n7. 下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点\n\n### t2 r.unlock，t3 r.unlock\n\n\u003e 同一批读锁都释放了（依靠计数器），才能真正去唤醒后续的独占节点。\n\n1. t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零\n![[z-oblib/z2-attachments/Pasted image 20220610211041.png]]\n2. t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即\n![[z-oblib/z2-attachments/Pasted image 20220610211104.png]]\n3. 之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束\n![[z-oblib/z2-attachments/Pasted image 20220610211128.png]]\n\n## 源码\n\n### 写上锁\n\n```java\nstatic final class NonfairSync extends Sync {\n    // ... 省略无关代码\n    \n    // 外部类 WriteLock 方法, 方便阅读, 放在此处\n    public void lock() {\n        sync.acquire(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final void acquire(int arg) {\n        if (\n            // 尝试获得写锁失败\n            !tryAcquire(arg) \u0026\u0026\n            // 将当前线程关联到一个 Node 对象上, 模式为独占模式\n            // 进入 AQS 队列阻塞\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        ) {\n            selfInterrupt();\n        }\n    }\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    // 返回是否获取锁成功\n    protected final boolean tryAcquire(int acquires) {\n        // 获得低 16 位, 代表写锁的 state 计数\n        Thread current = Thread.currentThread();\n\n        int c = getState();\n        int w = exclusiveCount(c);\n\n\t\t// 有锁\n        if (c != 0) {\n            if (\n                // c != 0 and w == 0 表示有读锁, 或者\n                w == 0 || \n                // 如果 exclusiveOwnerThread 不是自己\n                current != getExclusiveOwnerThread()\n            ) {\n                // 获得锁失败\n                return false;\n            }\n            // 写锁计数超过低 16 位, 报异常\n            if (w + exclusiveCount(acquires) \u003e MAX_COUNT)\n                throw new Error(\"Maximum lock count exceeded\");\n            // 写锁重入, 获得锁成功\n            setState(c + acquires);\n            return true;\n        }        \n        if (\n            // 判断写锁是否应该阻塞, 或者\n            writerShouldBlock() ||\n            // 尝试更改计数失败\n            !compareAndSetState(c, c + acquires)\n        ) {\n            // 获得锁失败\n            return false;\n        }\n        // 获得锁成功\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n    \n    // 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞\n    final boolean writerShouldBlock() {\n        return false;\n    }\n}\n```\n\n### 写释放\n\n```java\nstatic final class NonfairSync extends Sync {\n    // ... 省略无关代码\n    \n    // WriteLock 方法, 方便阅读, 放在此处\n    public void unlock() {\n        sync.release(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final boolean release(int arg) {\n        // 尝试释放写锁成功\n        if (tryRelease(arg)) {\n            // unpark AQS 中等待的线程\n            Node h = head;\n            // 如果有，唤醒后继节点\n            if (h != null \u0026\u0026 h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    protected final boolean tryRelease(int releases) {\n        if (!isHeldExclusively())\n            throw new IllegalMonitorStateException();\n        int nextc = getState() - releases;\n        // 因为可重入的原因, 写锁计数为 0, 才算释放成功\n        boolean free = exclusiveCount(nextc) == 0;\n        if (free) {\n            setExclusiveOwnerThread(null);\n        }\n        setState(nextc);\n        return free;\n    }\n}\n```\n\n### 读上锁\n\n```java\nstatic final class NonfairSync extends Sync {\n    \n    // ReadLock 方法, 方便阅读, 放在此处\n    public void lock() {\n        sync.acquireShared(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final void acquireShared(int arg) {\n        // tryAcquireShared 返回负数, 表示获取读锁失败\n        if (tryAcquireShared(arg) \u003c 0) {\n            doAcquireShared(arg);\n        }\n    }\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    protected final int tryAcquireShared(int unused) {\n        Thread current = Thread.currentThread();\n        int c = getState();\n        // 如果是其它线程持有写锁, 获取读锁失败\n        if (            \n            exclusiveCount(c) != 0 \u0026\u0026\n            getExclusiveOwnerThread() != current\n        ) {\n            return -1;\n            }\n        int r = sharedCount(c);\n        if (\n            // 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且\n            !readerShouldBlock() \u0026\u0026\n            // 小于读锁计数, 并且\n            r \u003c MAX_COUNT \u0026\u0026\n            // 尝试增加计数成功\n            compareAndSetState(c, c + SHARED_UNIT)\n        ) {\n            // ... 省略不重要的代码\n            return 1;\n        }\n        return fullTryAcquireShared(current);\n    }\n    \n    // 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁\n    // true 则该阻塞, false 则不阻塞\n    final boolean readerShouldBlock() {\n        return apparentlyFirstQueuedIsExclusive();\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞\n    final int fullTryAcquireShared(Thread current) {\n        HoldCounter rh = null;\n        for (;;) {\n            int c = getState();\n            if (exclusiveCount(c) != 0) {\n                if (getExclusiveOwnerThread() != current)\n                    return -1;\n            } else if (readerShouldBlock()) {\n                // ... 省略不重要的代码\n            }\n            if (sharedCount(c) == MAX_COUNT)\n                throw new Error(\"Maximum lock count exceeded\");\n            if (compareAndSetState(c, c + SHARED_UNIT)) {\n                // ... 省略不重要的代码\n                return 1;\n            }\n        }\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    private void doAcquireShared(int arg) {\n        // 将当前线程关联到一个 Node 对象上, 模式为共享模式\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n\n                if (p == head) {\n                // 再一次尝试获取读锁\n                    int r = tryAcquireShared(arg);\n                    // 成功\n                    if (r \u003e= 0) {\n                        // ㈠\n                        // r 表示可用资源数, 在这里总是 1 允许传播\n                        //（唤醒 AQS 中下一个 Share 节点）\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        if (interrupted)\n                            selfInterrupt();\n                        failed = false;\n                        return;\n                    }\n                }\n                if (\n                    // 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）\n                    shouldParkAfterFailedAcquire(p, node) \u0026\u0026\n                    // park 当前线程\n                    parkAndCheckInterrupt()\n                ) {\n                    interrupted = true;\n                }\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n    \n    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        // 设置自己为 head\n        setHead(node);\n        \n        // propagate 表示有共享资源（例如共享读锁或信号量）\n        // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE\n        // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE\n        if (propagate \u003e 0 || h == null || h.waitStatus \u003c 0 ||\n            (h = head) == null || h.waitStatus \u003c 0) {\n            Node s = node.next;\n            // 如果是最后一个节点或者是等待共享读锁的节点\n            if (s == null || s.isShared()) {\n                // 进入 ㈡\n                doReleaseShared();\n            }\n        }\n    }\n    \n    // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处\n    private void doReleaseShared() {\n        // 如果 head.waitStatus == Node.SIGNAL ==\u003e 0 成功, 下一个节点 unpark\n        // 如果 head.waitStatus == 0 ==\u003e Node.PROPAGATE, 为了解决 bug, 见后面分析\n        for (;;) {\n            Node h = head;\n            // 队列还有节点\n            if (h != null \u0026\u0026 h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    // 下一个节点 unpark 如果成功获取读锁\n                    // 并且下下个节点还是 shared, 继续 doReleaseShared\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 \u0026\u0026\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n}\n```\n\n- tryAcquireShared 返回值表示：\n\t- -1 表示失败\n\t- 0 表示成功，但后继节点不会继续唤醒（这里用不到0）\n\t- 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1\n\n### 读释放\n\n```java\nstatic final class NonfairSync extends Sync {\n    \n    // ReadLock 方法, 方便阅读, 放在此处\n    public void unlock() {\n        sync.releaseShared(1);\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n    \n    // Sync 继承过来的方法, 方便阅读, 放在此处\n    // 判断计数器是否满足可以释放锁\n    protected final boolean tryReleaseShared(int unused) {\n        // ... 省略不重要的代码\n        for (;;) {\n            int c = getState();\n            int nextc = c - SHARED_UNIT;\n            if (compareAndSetState(c, nextc)) {\n                // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程\n                // 计数为 0 才是真正释放\n                return nextc == 0;\n            }\n        }\n    }\n    \n    // AQS 继承过来的方法, 方便阅读, 放在此处\n    private void doReleaseShared() {\n        // 如果 head.waitStatus == Node.SIGNAL ==\u003e 0 成功, 下一个节点 unpark\n        // 如果 head.waitStatus == 0 ==\u003e Node.PROPAGATE \n        for (;;) {\n            Node h = head;\n            if (h != null \u0026\u0026 h != tail) {\n                int ws = h.waitStatus;\n                // 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0\n                // 防止 unparkSuccessor 被多次执行\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析\n                else if (ws == 0 \u0026\u0026\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }    \n}\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Runnable":{"title":"Runnable","content":"# Runnable\n\n用来承载供Thread对象执行的任务，将任务从Thread中抽出来可以更加灵活。\n\n```java\nRunnable runnable = () -\u003e log.debug(\"runnable\");  // lambda\nThread t2 = new Thread(runnable);\n```\n\n因为Runnable是一个@FunctionalInterface接口，所以可以通过[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/lambda|lambda]]的形式实现。\n通过把方法包装成Runnable更加灵活，并且Runnable对[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]等高级API更加友好。这种思想也就是[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/组合优于继承|组合优于继承]]。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Semaphore":{"title":"Semaphore","content":"# Semaphore\n\n[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的[[3-计算机科学/2-计算机组成原理/线程|线程]]上限。\n\n## 应用\n\n- 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）\n- 用  Semaphore 实现简单连接池，对比『[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/享元模式|享元模式]]』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的\n\n### 简化连接池\n\n一种享元模式应用。\n\n```java\nclass Pool {\n    // 1. 连接池大小\n    private final int poolSize;\n \n    // 2. 连接对象数组\n    private Connection[] connections;\n \n    // 3. 连接状态数组 0 表示空闲， 1 表示繁忙\n    private AtomicIntegerArray states;\n \n    private Semaphore semaphore;\n    // 4. 构造方法初始化\n    public Pool(int poolSize) {\n        this.poolSize = poolSize;\n        // 让许可数与资源数一致\n        this.semaphore = new Semaphore(poolSize);\n        this.connections = new Connection[poolSize];\n        this.states = new AtomicIntegerArray(new int[poolSize]);\n        for (int i = 0; i \u003c poolSize; i++) {\n            connections[i] = new MockConnection(\"连接\" + (i+1));\n        }\n    }\n \n    // 5. 借连接\n    public Connection borrow() {// t1, t2, t3\n        // 获取许可\n        try {\n            semaphore.acquire(); // 没有许可的线程，在此等待\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int i = 0; i \u003c poolSize; i++) {\n            // 获取空闲连接\n            if(states.get(i) == 0) {\n                if (states.compareAndSet(i, 0, 1)) {\n                    log.debug(\"borrow {}\", connections[i]);\n                    return connections[i];\n                }\n            }\n        }\n        // 不会执行到这里\n        return null;\n    }\n    // 6. 归还连接\n    public void free(Connection conn) {\n        for (int i = 0; i \u003c poolSize; i++) {\n            if (connections[i] == conn) {\n                states.set(i, 0);\n                log.debug(\"free {}\", conn);\n                semaphore.release();\n                break;\n            }\n        }\n    }\n}\n```\n\n## 原理\n\n### 加解锁流程\n\nSemaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一。\n\n1. 刚开始，permits（state）为 3，这时 5 个线程来获取资源\n![[z-oblib/z2-attachments/Pasted image 20220610231154.png]]\n2. 假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞\n![[z-oblib/z2-attachments/Pasted image 20220610231219.png]]\n3. 这时 Thread-4 释放了 permits，状态如下\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/StampedLock":{"title":"StampedLock","content":"# StampedLock\n\n该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用。\n\n\u003e 一个特殊的读写锁。\n\n## 使用\n\n### 读锁\n\n```java\nlong stamp = lock.readLock();\nlock.unlockRead(stamp);\n```\n\n### 写锁\n\n```java\nlong stamp = lock.writeLock();\nlock.unlockWrite(stamp);\n```\n\n### 乐观读\n\nStampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。\n\n```java\nlong stamp = lock.tryOptimisticRead();\n// 验戳\nif(!lock.validate(stamp)){\n    // 锁升级\n}\n```\n\n### 用例\n\n提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：\n```java\nclass DataContainerStamped {\n    private int data;\n    private final StampedLock lock = new StampedLock();\n \n    public DataContainerStamped(int data) {\n        this.data = data;\n    }\n \n    public int read(int readTime) {\n        long stamp = lock.tryOptimisticRead();\n        log.debug(\"optimistic read locking...{}\", stamp);\n        sleep(readTime);\n        if (lock.validate(stamp)) {\n            log.debug(\"read finish...{}, data:{}\", stamp, data);\n            return data;\n        }\n        // 锁升级 - 读锁\n        log.debug(\"updating to read lock... {}\", stamp);\n        try {\n            stamp = lock.readLock();\n            log.debug(\"read lock {}\", stamp);\n            sleep(readTime);\n            log.debug(\"read finish...{}, data:{}\", stamp, data);\n            return data;\n        } finally {\n            log.debug(\"read unlock {}\", stamp);\n            lock.unlockRead(stamp);\n        }\n    }\n \n    public void write(int newData) {\n        long stamp = lock.writeLock();\n        log.debug(\"write lock {}\", stamp);\n        try {\n            sleep(2);\n            this.data = newData;\n        } finally {\n            log.debug(\"write unlock {}\", stamp);\n            lock.unlockWrite(stamp);\n        }\n    }\n}\n```\n\n\n## 缺点\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Thread":{"title":"Thread","content":"# Thread\n\nThread是一个实现了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Runnable|Runnable]]接口的类，创建一个包含自定义任务的Thread对象有两种方式：\n1. 通过继承Thread类并重写run()方法来实现。\n2. 通过实例化Thread类时传入Runnable对象来实现。\n\n可以用两种方式来实现因为Thread中默认的run()方法采用了代理的思想：\n\n```java\n@Override  \npublic void run() {  \n    if (target != null) {  \n        target.run();  \n    }  \n}\n```\n\n上述代码target就是传入的Runnable对象，如果没有传入，则需要继承Thread并重写该方法。这样的方式就能实现有两种方式来创建自己的Thread类。而通过把方法包装成Runnable对象再传递给Thread更加灵活，并且Runnable对[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]等高级API更加友好。这种思想也就是[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/组合优于继承|组合优于继承]]。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor":{"title":"ThreadPoolExecutor","content":"# ThreadPoolExecutor\n\n![[z-oblib/z2-attachments/Pasted image 20220607225611.png]]\n\n## 线程池状态\n\nThreadPoolExecutor 使用 int 的高 3 位来表示[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]状态，低 29 位表示[[3-计算机科学/2-计算机组成原理/线程|线程]]数量：\n\n| 状态名     | 高3位 | 接收新任务 | 处理阻塞队列任务 | 说明                                       |\n| ---------- | ----- | ---------- | ---------------- | ------------------------------------------ |\n| RUNNING    | 111   | Y          | Y                |                                            |\n| SHUTDOWN   | 000   | N          | Y                | 不会接收新任务，但会处理阻塞队列剩余任务   |\n| STOP       | 001   | N          | N                | 会中断正在执行的任务，并抛弃阻塞队列任务   |\n| TIDYING    | 010   |            |                  | 任务全执行完毕，活动线程为 0 即将进入 终结 |\n| TERMINATED | 011   |            |                  | 终结状态                                           |\n\n从数字上比较，TERMINATED \u003e TIDYING \u003e STOP \u003e SHUTDOWN \u003e RUNNING。\n\u003e 有符号位，111为负数，所以RUNNING最小。\n\n目的不主要是节约空间：这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/CAS|cas]] 原子操作进行赋值。\n\n```java\n// c 为旧值， ctlOf 返回结果为新值\nctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));\n \n// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n## 构造方法\n\n\u003e 构造方法的参数决定了线程池的大多数行为。\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n- corePoolSize 核心线程数目 (最多保留的线程数)\n- maximumPoolSize 最大线程数目\n- keepAliveTime 生存时间 - 针对救急线程\n- unit 时间单位 - 针对救急线程\n- workQueue [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/阻塞队列|阻塞队列]]\n- threadFactory 线程工厂 - 可以为线程创建时起个好名字\n- handler 拒绝策略\n\u003e 可以类比[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/自定义线程池|自定义线程池]]中的相关设计思路。\n\n### 线程工作方式\n\n在核心线程都被占用的情况下，救急线程会出来执行任务，任务执行完后会销毁。\n而核心线程在无任务的情况下不会销毁。\n\n![[z-oblib/z2-attachments/Pasted image 20220607231221.png]]\n![[z-oblib/z2-attachments/Pasted image 20220607231227.png]]\n\n- 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。\n- 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。\n- 如果队列选择了**有界队列**，那么任务超过了队列大小时，会创建 `maximumPoolSize - corePoolSize`数目的线程来**救急**。\n\t\u003e 救急线程配合有界队列使用。\n- 如果线程到达 `maximumPoolSize` 仍然有新任务这时会执行拒绝策略。\n- JDK提供了4种拒绝策略：\n\t1. AbortPolicy 让调用者抛出RejectedExecutionException 异常，这是默认策略\n\t2. CallerRunsPolicy 让调用者运行任务\n\t3. DiscardPolicy 放弃本次任务\n\t4. DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之\n- 其它著名框架也提供了拒绝策略实现：\n\t- Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题\n\t- Netty 的实现，是创建一个新线程来执行任务\n\t- ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略\n\t- PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略\n- 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。\n\n![[z-oblib/z2-attachments/Pasted image 20220607231450.png]]\n\n## 工厂方法\n\n\u003e 构造方法的参数太多，用起来可能比较麻烦，JDK又提供了工具类提供很多工厂方法，创建不同线程池，内部就是调用上述构造方法并传递不同参数。\n\n根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池。\n\n### newFixedThreadPool\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue\u003cRunnable\u003e());\n}\n```\n\n#### 特点\n\n- 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间\n- 阻塞队列是无界的，可以放任意数量的任务\n\n#### 使用场景\n\n适用于任务量已知，相对耗时的任务。\n\n### newCachedThreadPool\n\n\u003e 全员都是外包@华为\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue\u003cRunnable\u003e());\n}\n```\n\n#### 特点\n\n- 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着：\n\t- 全部都是救急线程（60s 后可以回收）\n\t- 救急线程可以无限创建\n- 队列采用了 SynchronousQueue 实现特点是，它**没有容量**，没有线程来取是放不进去的（一手交钱、一手交货）\n- 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 \n\n#### 使用场景\n\n适合任务数比较**密集**，但每个任务**执行时间**较**短**的情况。\n\n### newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n\t// 没有直接返回线程池对象\n\t// 用装饰器模式进行了包装\n\t// 限制了返回对象能调用的方法\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue\u003cRunnable\u003e()));\n}\n```\n\n#### 特点\n\n- 健壮性：\n\t- 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，后续要创建的线程也无法执行。\n\t- 而线程池还会新建一个线程，保证池的正常工作，一个线程失败不影响后续线程执行。\n- Executors.newSingleThreadExecutor() 线程个数始终为1\n\t- 线程数不能修改。\n\t- FinalizableDelegatedExecutorService 应用的是[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/装饰器模式]]，只对外暴露了ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，防止设置被修改。\n- Executors.newFixedThreadPool(1) 初始时为1时和SingleThreadExecutor一样：\n\t- 线程数后续还可以修改。\n\t- 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改核心线程数。\n\n#### 使用场景\n\n希望多个任务排队执行：线程数固定为 **1**，任务数多于 1 时，会放入**无界**队列排队。任务执行完毕，这唯一的线程也**不会**被释放。\n\n## 提交任务\n\n```java\n// 执行任务\nvoid execute(Runnable command);\n \n// 提交任务 task，用返回值 Future 获得任务执行结果\n// 保护性暂停模式\n// 用来在主线程种接收线程池种线程返回的结果\n\u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task);\n \n// 提交 tasks 中所有任务\n\u003cT\u003e List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)\n        throws InterruptedException;\n \n// 提交 tasks 中所有任务，带超时时间\n\u003cT\u003e List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n \n// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消\n\u003cT\u003e T invokeAny(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)\n\n        throws InterruptedException, ExecutionException;\n        // 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间\n\u003cT\u003e T invokeAny(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n```\n\n- submit的返回值靠[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/保护性暂停|保护性暂停]]实现，Future类似GuardedObject。\n\n## 关闭线程池\n\n### shutdown\n\n```java\n/*\n线程池状态变为 SHUTDOWN\n - 不会接收新任务\n - 但已提交任务会执行完\n - 此方法不会阻塞调用线程的执行\n*/\nvoid shutdown();\n```\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 修改线程池状态\n        advanceRunState(SHUTDOWN);\n        // 仅会打断空闲线程\n        interruptIdleWorkers();\n        onShutdown(); // 扩展点 ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)\n    // 让那些还未结束的线程自灭，我不管了\n    tryTerminate();\n}\n```\n\n### shutdownNow\n\n```java\n/*\n线程池状态变为 STOP\n - 不会接收新任务\n - 会将队列中的任务返回\n - 并用 interrupt 的方式中断正在执行的任务\n*/\nList\u003cRunnable\u003e shutdownNow();\n```\n\n```java\npublic List\u003cRunnable\u003e shutdownNow() {\nList\u003cRunnable\u003e tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        // 修改线程池状态\n        advanceRunState(STOP);\n        // 打断所有线程\n        interruptWorkers();\n        // 获取队列中剩余任务\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试终结\n    tryTerminate();\n    return tasks;\n}\n```\n\n## 其它方法\n\n```java\n// 不在 RUNNING 状态的线程池，此方法就返回 true\nboolean isShutdown();\n \n// 线程池状态是否是 TERMINATED\nboolean isTerminated();\n \n// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待\n// 等待线程全部结束或等待超时\nboolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;\n```\n\n## 任务异常处理\n\n ### 主动捕捉\n\n```java\nExecutorService pool = Executors.newFixedThreadPool(1);\npool.submit(() -\u003e {\n    try {\n        log.debug(\"task1\");\n        int i = 1 / 0;\n    } catch (Exception e) {\n        log.error(\"error:\", e);\n    }\n});\n```\n\n### 使用Future\n\n```java\nExecutorService pool = Executors.newFixedThreadPool(1);\nFuture\u003cBoolean\u003e f = pool.submit(() -\u003e {\n    log.debug(\"task1\");\n    int i = 1 / 0;\n    return true;\n});\nlog.debug(\"result:{}\", f.get());\n```\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Timer":{"title":"Timer","content":"# Timer\n\n在[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/任务调度线程池|任务调度线程池]]功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由**同一个**线程来调度，因此所有任务都是**串行**执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。\n\n```java\npublic static void main(String[] args) {\n    Timer timer = new Timer();\n    TimerTask task1 = new TimerTask() {\n        @Override\n        public void run() {\n            log.debug(\"task 1\");\n\n            sleep(2);\n            }\n    };\n    TimerTask task2 = new TimerTask() {\n        @Override\n        public void run() {\n            log.debug(\"task 2\");\n        }\n    };\n    // 使用 timer 添加两个任务，希望它们都在 1s 后执行\n    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行\n    timer.schedule(task1, 1000);\n    timer.schedule(task2, 1000);\n}\n```\n\n## 缺点\n\n后一个线程的执行会受到前一个线程的影响：\n- 开始时间会受制于前一个线程的执行时间。\n- 前一个线程异常会影响后面的线程。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Unsafe":{"title":"Unsafe","content":"# Unsafe\n\nUnsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。\n\n```java\npublic class UnsafeAccessor {\n    static Unsafe unsafe;\n \n    static {\n        try {            \n            Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            theUnsafe.setAccessible(true);\n            unsafe = (Unsafe) theUnsafe.get(null);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            throw new Error(e);\n        }\n    }\n \n    static Unsafe getUnsafe() {\n        return unsafe;\n    }\n}\n```\n\n通过反射获取：\n\n```java\nimport sun.misc.Unsafe;  \n  \nimport java.lang.reflect.Field;  \n  \npublic class Test18Unsafe {  \n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {  \n        Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");  \n        theUnsafe.setAccessible(true);  // 访问私有成员  \n        Unsafe unsafe = (Unsafe) theUnsafe.get(null);  \n        System.out.println(unsafe);  \n    }  \n}\n```\n\n## CAS操作\n\n#TODO","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/forkjoin":{"title":"fork\u0026join","content":"# fork\u0026join\n\n## 概念\n\n- Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 **cpu** 密集型运算\n- 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解\n- Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率\n- Fork/Join 默认会创建与 cpu 核心数大小**相同**的线程池\n\n## 使用\n\n提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务：\n\n```java\nclass AddTask1 extends RecursiveTask\u003cInteger\u003e {\n \n    int n;\n \n    public AddTask1(int n) {\n        this.n = n;\n    }\n \n    @Override\n    public String toString() {\n        return \"{\" + n + '}';\n    }\n \n    @Override\n    protected Integer compute() {\n        // 如果 n 已经为 1，可以求得结果了\n        if (n == 1) {\n            log.debug(\"join() {}\", n);\n            return n;\n        }\n        \n        // 将任务进行拆分(fork)\n        AddTask1 t1 = new AddTask1(n - 1);\n        t1.fork();\n        log.debug(\"fork() {} + {}\", n, t1);\n        \n        // 合并(join)结果\n        int result = n + t1.join();\n        log.debug(\"join() {} + {} = {}\", n, t1, result);\n        return result;\n    }\n}\n```\n\n提交给ForkJoinPool执行：\n\n```java\npublic static void main(String[] args) {\n    ForkJoinPool pool = new ForkJoinPool(4);\n    System.out.println(pool.invoke(new AddTask1(5)));\n}\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220608214020.png]]\n\n## 改进\n\n```java\nclass AddTask3 extends RecursiveTask\u003cInteger\u003e {\n    \n    int begin;\n    int end;\n \n    public AddTask3(int begin, int end) {\n        this.begin = begin;\n        this.end = end;\n    }\n \n    @Override\n    public String toString() {\n        return \"{\" + begin + \",\" + end + '}';\n    }\n \n    @Override\n    protected Integer compute() {\n        // 5, 5\n        if (begin == end) {\n            log.debug(\"join() {}\", begin);\n            return begin;\n        }\n\n        // 4, 5\n        if (end - begin == 1) {\n            log.debug(\"join() {} + {} = {}\", begin, end, end + begin);\n            return end + begin;\n        }\n        \n        // 1 5\n        int mid = (end + begin) / 2; // 3\n \n        AddTask3 t1 = new AddTask3(begin, mid); // 1,3\n        t1.fork();\n        AddTask3 t2 = new AddTask3(mid + 1, end); // 4,5\n        t2.fork();\n        log.debug(\"fork() {} + {} = ?\", t1, t2);\n \n        int result = t1.join() + t2.join();\n        log.debug(\"join() {} + {} = {}\", t1, t2, result);\n        return result;\n    }\n}\n```\n\n提交给 ForkJoinPool 来执行：\n\n```java\npublic static void main(String[] args) {\n    ForkJoinPool pool = new ForkJoinPool(4);\n    System.out.println(pool.invoke(new AddTask3(1, 10)));\n}\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220608214123.png]]\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/happens-before":{"title":"happens-before","content":"# happens-before\n\n## 什么是happens-before\n\n**如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。**\n\n一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。\n\nJMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。\n\n而对于程序员，JMM提供了**happens-before规则**（JSR-133规范），满足了程序员的需求——简单易懂，并且提供了足够强的内存可见性保证。换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。\n\nJMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。\n\nhappens-before关系的定义如下：\n1. 概念：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n2. 实际是结果为导向：两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。**如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序**。\n\n\u003ehappens-before关系本质上和as-if-serial语义是一回事。\nas-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。\n\n## 满足的几种情况\n\n### synchronized\n\n线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见：\n```java\nstatic int x;\nstatic Object m = new Object();\n \nnew Thread(()-\u003e{\n    synchronized(m) {\n        x = 10;\n        }\n},\"t1\").start();\n \nnew Thread(()-\u003e{\n    synchronized(m) {\n        System.out.println(x);\n    }\n},\"t2\").start();\n```\n\n### volatile\n\n线程对 volatile 变量的写，对**接下来**其它线程对该变量的读可见\n```java\nvolatile static int x;\n \nnew Thread(()-\u003e{\n    x = 10;\n},\"t1\").start();\n \nnew Thread(()-\u003e{\n    System.out.println(x);\n},\"t2\").start();\n```\n\n### 线程启动前\n\n线程 start 前对变量的写，对该线程开始后对该变量的读可见\n```java\nstatic int x;\n \nx = 10;\n \nnew Thread(()-\u003e{\n    System.out.println(x);\n},\"t2\").start();\n```\n\n### 线程结束前\n线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）\n```java\nstatic int x;\n \nThread t1 = new Thread(()-\u003e{\n    x = 10;\n},\"t1\");\nt1.start();\n \nt1.join();\nSystem.out.println(x);\n```\n\n### 线程打断\n\n线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）\n```java\nstatic int x;\n \npublic static void main(String[] args) {\n    Thread t2 = new Thread(()-\u003e{\n        while(true) {\n            if(Thread.currentThread().isInterrupted()) {\n                System.out.println(x);\n                break;\n            }\n        }\n    },\"t2\");\n    t2.start();\n \n    new Thread(()-\u003e{\n        sleep(1);\n        x = 10;\n        t2.interrupt();\n    },\"t1\").start();\n \n    while(!t2.isInterrupted()) {\n        Thread.yield();\n    }\n    System.out.println(x);\n}\n```\n\n### 默认值\n\n对变量默认值（0，false，null）的写，对其它线程对该变量的读可见\n\n### 传递性\n\nvolatile的特性：\n```java\nvolatile static int x;\nstatic int y;\n \nnew Thread(()-\u003e{    \n    y = 10;\n    x = 20;\n},\"t1\").start();\n \nnew Thread(()-\u003e{\n    // x=20 对 t2 可见, 同时 y=10 也对 t2 可见\n    System.out.println(x); \n},\"t2\").start();\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/interrupt":{"title":"interrupt","content":"# interrupt\n\n## 打断 sleep, wait, join 的线程\n\ninterrupt强行打断线程：\n\n线程会记录本身是否被打断过，但是sleep, wait, join 以异常的方式响应interrupt后会清除异常标记，isInterrupted() == false。\n\n```java\npublic static void main(String[] args) throws InterruptedException {  \n    Thread t1 = new Thread(()-\u003e{  \n        log.debug(\"sleep...\");  \n        try {  \n            Thread.sleep(5000);  \n        } catch (InterruptedException e) {  \n            throw new RuntimeException(e);  \n        }  \n    });  \n    t1.start();  \n    Thread.sleep(500);  // 主线程等t1先睡着  \n    t1.interrupt();  \n    log.debug(\"打断标记：{}\", t1.isInterrupted());  \n}\n```\n\n## 打断正常运行的线程\n\ninterrupt让你自行了断：\n\n对于正常运行的线程，interrupt主要是设置打断标记，由线程代码根据打断标记来抉择当前线程是要继续运行还是就此终止。\n\n```java\npublic static void main(String[] args) throws InterruptedException {  \n    Thread t1 = new Thread(()-\u003e{  \n        while (true){  \n            boolean interrupted = Thread.currentThread().isInterrupted();  \n            if(interrupted) {  \n                log.debug(\"我被打断了\");  \n                break;            }\n        }  \n    });  \n    t1.start();  \n    Thread.sleep(500);  \n    log.debug(\"interrupt\");  \n    t1.interrupt();  \n}\n```\n\n### 为什么会不一样\n\n因为线程睡着的时候没法也不知道别人有没有打断他，线程没有在执行，所以由其他人强行把他杀了。\n\n而线程没有睡着的时候，能感知到是否有别的线程在打断他，这样就能让线程自己自行了断，方便做一些善后处理。\n\n## 打断park的线程\n\n```java\nprivate static void test3() throws InterruptedException {\n    Thread t1 = new Thread(() -\u003e {\n        log.debug(\"park...\");\n        LockSupport.park();\n        log.debug(\"unpark...\");\n        log.debug(\"打断状态：{}\", Thread.currentThread().isInterrupted());\n        LockSupport.park();  // 这里park不起效\n    }, \"t1\");\n    t1.start();\n\n \n    sleep(0.5);\n    t1.interrupt();\n}\n```\n\npark只能在打断标记是false的时候起效果，isInterrupted不会重置打断标记，所以第二个park不起效。可以用interrupted重置打断标记。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B":{"title":"java守护线程","content":"# java守护线程\n\n主线程结束时不管守护线程还有没有其它任务，都会强制结束守护线程。\n\n主要用在：\n- 垃圾回收器线程。\n- Tomcat中的Accetor和Poller线程。（结束tomcat后不会等待当前请求处理完成而是会直接结束运行）。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2":{"title":"java线程上下文切换（Thread Context Switch）","content":"# java线程上下文切换（Thread Context Switch）\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：\n- 线程的 cpu 时间片用完\n- 垃圾回收\n- 有更高优先级的线程需要运行\n- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\n\n- 当 Context Switch 发生时，需要由操作系统**保存当前线程的状态**，并恢复另一个线程的状态。\n- Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是**线程私有**的。\n- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。\n- Context Switch 频繁发生会影响性能。\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81":{"title":"java线程状态","content":"# java线程状态\n\n\u003e [[3-计算机科学/2-计算机组成原理/线程状态|线程状态]]\n\n根据Java API Thread.State枚举，有6种状态：\n\n![[z-oblib/z2-attachments/Pasted image 20220526174139.png]]\n\n\u003e BLOCKED是指线程正在等待获取锁；WAITING是指线程正在等待其他线程发来的通知（notify），收到通知后，可能会顺序向后执行（RUNNABLE），也可能会再次获取锁，进而被阻塞住（BLOCKED）。\n\n## 状态转换\n\n### 1. NEW --\u003e RUNNABLE\n- NEW [[3-计算机科学/2-计算机组成原理/线程|线程]]刚被创建，但是还没有调用 start() 方法，**还未与操作系统线程相关联**。\n- 当调用 t.start() 方法时，由 NEW --\u003e RUNNABLE。\n\n\u003e 注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）。\n\n### 2. RUNNABLE \u003c--\u003e WAITING\n1. 调用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/wait\u0026notify|wait\u0026notify]] 在RUNNABLE 和 AWITING间转换，t 线程用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]](obj) 获取了对象锁后：\n\t- 调用 obj.wait() 方法时，t 线程从 RUNNABLE --\u003e WAITING\n\t- 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时\n\t\t- 竞争锁成功，t 线程从 WAITING --\u003e RUNNABLE \n\t\t- 竞争锁失败，t 线程从 WAITING --\u003e BLOCKED \n- BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分。\n- TERMINATED 当线程代码运行结束。\n\n### 3. RUNNABLE \u003c--\u003e WAITING\n\n- 当前线程调用 t.[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/join|join]]() 方法时，当前线程从 RUNNABLE --\u003e WAITING\n\t- 注意是**当前线程**在**t 线程对象**的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|Monitor]]上等待\n- t 线程运行结束，或调用了当前线程的 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/interrupt|interrupt]]() 时，当前线程从 WAITING --\u003e RUNNABLE\n\n### 4. RUNNABLE \u003c--\u003e WAITING\n\n- 当前线程调用 LockSupport.[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/park\u0026unpark|park]]() 方法会让当前线程从 RUNNABLE --\u003e WAITING\n- 调用 LockSupport.[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/park\u0026unpark|unpark]](目标线程) 或调用了线程 的 interrupt() ，会让目标线程从WAITING --\u003e RUNNABLE\n\n### 5. RUNNABLE \u003c--\u003e TIMED_WAITING\n\nt 线程用 synchronized(obj) 获取了对象锁后：\n\t- 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --\u003e TIMED_WAITING\n\t- t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/interrupt|interrupt]]() 时\n\t\t- 竞争锁成功，t 线程从 TIMED_WAITING --\u003e RUNNABLE \n\t\t- 竞争锁失败，t 线程从 TIMED_WAITING --\u003e BLOCKED \n\n### 6. RUNNABLE \u003c--\u003e TIMED_WAITING\n\n- 当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --\u003e TIMED_WAITING\n\t- 注意是当前线程在t 线程对象的监视器上等待\n- 当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从TIMED_WAITING --\u003e RUNNABLE\n\n### 7. RUNNABLE \u003c--\u003e TIMED_WAITING\n\n- 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --\u003e TIMED_WAITING \n- 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --\u003e RUNNABLE \n\n### 8. RUNNABLE \u003c--\u003e TIMED_WAITING\n\n- 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --\u003e TIMED_WAITING\n- 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--\u003e RUNNABLE\n\n### 9. RUNNABLE \u003c--\u003e BLOCKED\n\n- t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --\u003e BLOCKED \n- 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --\u003e RUNNABLE ，其它失败的线程仍然 BLOCKED \n\n### 10. RUNNABLE --\u003e TERMINATED\n\n- 当前线程所有代码运行完毕，进入 TERMINATED\n\n\n## blocked和waiting区别\n\n线程可以通过wait,join,LockSupport.park方式进入wating状态，进入wating状态的线程等待唤醒(notify或notifyAll)才有机会获取cpu的时间片段来继续执行。\n线程的 blocked状态往往是无法进入同步方法/代码块来完成的。这是因为无法获取到与同步方法/代码块相关联的锁。\n\n与wating状态相关联的是等待队列，与blocked状态相关的是同步队列，一个线程由等待队列迁移到同步队列时，线程状态将会由wating转化为blocked。可以这样说，blocked状态是处于wating状态的线程重新焕发生命力的必由之路。\n\n ## 总结\n\njava把线程交给操作系统后就任由操作系统去调度了，所以操作系统层面的可运行/运行/阻塞对于java程序来说是一样的，jvm不会去细分这几种状态，同一就是RUNNABLE。\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E9%81%BF%E5%85%8D%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6":{"title":"java避免临界区竞态条件","content":"# java避免临界区竞态条件\n\n[[3-计算机科学/2-计算机组成原理/临界区|临界区]] [[3-计算机科学/2-计算机组成原理/竞态条件|竞态条件]]\n\n- 阻塞式解决方案\n\t- [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]\n\t- Lock\n- 非阻塞式解决方案\n\t- 原子变量","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/join":{"title":"join","content":"# join\n\njoin()方法是Thread类的一个实例方法。让**当前**线程陷入等待，等待某个其它[[3-计算机科学/2-计算机组成原理/线程|线程]]运行结束，**谁调用就等待谁**，join起到了[[3-计算机科学/2-计算机组成原理/同步|同步]]的作用。\n\njoin()底层就是wait()。\n\n有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。\n\n如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。\n\n示例代码：\n\n```java\npublic class Join {\n    static class ThreadA implements Runnable {\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(\"我是子线程，我先睡一秒\");\n                Thread.sleep(1000);\n                System.out.println(\"我是子线程，我睡完了一秒\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new ThreadA());\n        thread.start();\n        thread.join();\n        System.out.println(\"如果不加join方法，我会先被打出来，加了就不一样了\");\n    }\n}\n```\n\n\u003e 注意join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)。\n\u003e \n\u003e 实际上，通过源码你会发现，join()方法及其重载方法底层都是利用了wait(long)这个方法。\n\u003e \n\u003e 对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理。\n\n## 原理\n\n底层设计模式是[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/保护性暂停|保护性暂停]]。\n\n一个线程等待另一个线程的结束。\n\n```java\npublic final synchronized void join(long millis)  \nthrows InterruptedException {  \n    long base = System.currentTimeMillis();  // 获取当前时间\n    long now = 0;  \n\t// 参数合法性判断\n    if (millis \u003c 0) {  \n        throw new IllegalArgumentException(\"timeout value is negative\");  \n    }  \n    \n    if (millis == 0) {  \n        while (isAlive()) {  \n            wait(0);  \n        }  \n    } else {  \n\t    // 判断虚假唤醒\n        while (isAlive()) {  \n            long delay = millis - now;  // 更新还要等多久\n            // 超时了就不再等了\n            if (delay \u003c= 0) {  \n                break;  \n            }  \n            wait(delay);  // 如果被虚假唤醒，就重新进入wait并等待剩余时间\n            now = System.currentTimeMillis() - base;  // 更新已经过了多久\n        }  \n    }  \n}\n```\n\nisAlive()是本地方法，由子线程（被等待的线程）调用，判断子线程是否还活着。\n\n在主线程中调用t1.join()[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized#成员方法|同步方法]]，会**把t1当作锁对象**，而成功调用t1.join()代表主线程获取到了当前的t1锁对象，因此wait是针对主线程生效的。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/monitor":{"title":"monitor","content":"# monitor\n\n监视器/管程。\n\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]] 给对象上锁（重量级）之后，该[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/对象头|对象头]]的[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 中就被设置指向 Monitor 对象的指针。\n\nMonitor 结构：\n![[z-oblib/z2-attachments/Pasted image 20220527172014.png]]\n\n1. Monitor 中 Owner 初始为 null。\n2. 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner。\n3. 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行synchronized(obj)，就会进入 EntryList BLOCKED。\n4. Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的。\n5. 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。\n\n\u003e 注意：\nsynchronized 必须是进入同一个对象的 monitor 才有上述的效果，\n不加 synchronized 的对象不会关联监视器，不遵从以上规则。\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/parkunpark":{"title":"park\u0026unpark","content":"# park\u0026unpark\n\n## 特点\n\n### 与 wait\u0026notify相比\n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park \u0026 unpark 是以线程为单位来阻塞/唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精准。\n- park \u0026 unpark 可以先 unpark，而 wait \u0026 notify 不能先 notify。\n\n## 原理\n\n**每个线程都有自己的一个 Parker 对象**，由三部分组成 _counter ， _cond 和 _mutex 打个比喻：\n- 线程就像一个旅人，Parker 就像他随身携带的背包：\n\t- 条件变量就好比背包中的帐篷\n\t- `_counter` 就好比背包中的备用干粮（0 为耗尽，1 为充足）\n- 调用 park 就是要看需不需要停下来歇息\n\t- 如果备用干粮耗尽，那么钻进帐篷歇息\n\t- 如果备用干粮充足，那么不需停留，继续前进\n- 调用 unpark，就好比令干粮充足\n\t- 如果这时线程还在帐篷，就唤醒让他继续前进\n\t- 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进\n\t\t- 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮\n\n1. 当前线程调用 Unsafe.park() 方法\n2. 检查 `_counter` ，本情况为 0，这时，获得 `_mutex` 互斥锁\n3. 线程进入 `_cond` 条件变量阻塞\n4. 设置 `_counter` = 0\n![[z-oblib/z2-attachments/Pasted image 20220529205721.png]]\n5. 调用 Unsafe.unpark(Thread_0) 方法，设置 `_counter` 为 1\n6. 唤醒 `_cond` 条件变量中的 Thread_0\n7. Thread_0 恢复运行\n8. 设置 `_counter` 为 0\n![[z-oblib/z2-attachments/Pasted image 20220529205853.png]]\n9. 调用 Unsafe.unpark(Thread_0) 方法，设置 `_counter` 为 1\n10. 唤醒 `_cond` 条件变量中的 Thread_0\n11. Thread_0 恢复运行\n12. 设置 `_counter` 为 0","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep":{"title":"sleep","content":"# sleep\n\nsleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间，睡眠是指让线程放弃当前CPU的时间片，但是并不会释放锁，抱着锁睡觉。它有这样两个方法：\n\n- Thread.sleep(long)\n- Thread.sleep(long, int)\n\n\u003e 同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。\n\n\n## 作用\n\n1. 调用 sleep 会让当前线程从 Running  进入 Timed Waiting 状态（阻塞）。\n2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException。\n3. 睡眠结束后的线程未必会立刻得到执行。\n4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。\n\n## 打断睡眠（非唤醒）\n\nsleep()是可以打断的，而打断的方式是通过InterruptedException异常，所以sleep()需要捉起来。\n\n注意打断睡眠不是唤醒，不会继续做睡醒后要做的工作，而是直接通过异常处理跳出了。所以sleep()后的内容（try范围内）不会被执行。\n\n相当于拔掉一个昏迷的人的氧气管，而不是叫醒他。\n\n```java\nThread t4 = new Thread(){  \n    @Override  \n    public void run() {  \n        log.debug(\"enter sleep...\");  \n        try {  \n            Thread.sleep(2000);  \n            log.debug(\"i'm awake\");  // 这里不会执行  \n        } catch (InterruptedException e) {  \n            log.debug(\"fvck, who interrupting me\");  // 这里会执行\n            throw new RuntimeException(e);  \n        }  \n    }  \n};\n```","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"sleep和wait的区别","content":"# sleep和wait的区别\n\n- **[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/sleep|sleep]]方法是不会释放当前的锁的，而wait方法会。** 这也是最常见的一个多线程面试题。\n-   wait可以指定时间，也可以不指定；而sleep必须指定时间。\n-   wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。\n-   wait必须放在同步块或同步方法中，而sleep可以在任意位置。","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized":{"title":"synchronized","content":"# synchronized\n\n## 简介\n\n俗称**对象锁**，采用互斥的方式让同一时刻只有一个[[3-计算机科学/2-计算机组成原理/线程|线程]]能持有对象锁。其它线程再想获取这个对象锁时就会**阻塞**住。这样就能保证拥有锁的线程可以安全的执行[[3-计算机科学/2-计算机组成原理/临界区|临界区]]内的代码，不用担心线程[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]。\n\n## 特点\n- synchronized**不可中断**（不可放弃争抢锁）：\n\t- 不可中断的意思是等待获取锁的时候不可中断，拿到锁之后可中断，没获取到锁的情况下，中断操作一直不会生效。\n- synchronized规定：线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。保证了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|内存可见性]]。\n- synchronized代码块中的代码越多，上锁时间越长，尽量减少锁的粒度。\n- synchronized可以保证原子性、可见性，并且对外部展现有序性，即内部的重排序不会影响外部（而不是不会发生重排序）（因为同一时刻进入synchronized代码块的只有一个线程，单线程下重排序无影响）。\n\t- 要想保证有序性，就要把东西全部交给synchronized管理，而不能暴露一部分在外面，这也是[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式#双重校验锁|双重检查锁]]实现时要加[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]]。\n\n## 语法\n\n```java\nsynchronized(对象)\n{\n\t// 临界区\n}\n```\n\n## 流程\n\n### 比喻\n\n![[z-oblib/z2-attachments/Pasted image 20220526224204.png]]\n\n1. `synchronized(对象)`中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人。\n2. 当线程 t1 执行到 `synchronized(room)`时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 `count++` 代码。\n3. 这时候如果 t2 也运行到了 `synchronized(room)` 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了。\n4. 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，**t1 仍拿着钥匙**，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入。\n5. 当 t1 执行完 `synchronized{}` 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 `count--` 代码。\n\n![[z-oblib/z2-attachments/Pasted image 20220527095647.png]]\n\n### 总结\n\nsynchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。\n\n## 使用场景\n\n`synchronized`关键字可以用到4个种场景:\n1. Instance methods\n2. Static methods\n3. Code blocks inside instance methods\n4. Code blocks inside static methods\n\n### 成员方法\n\n```java\npublic synchronized void add(int value){\n      this.count += value;\n}\n```\n\n等价于锁在所属对象上：\n\n```java\nclass Test{\n    public void test() {\n        synchronized(this) {\n        \n        }\n    }\n}\n```\n\n### 静态方法\n\n- 同步静态方法属于类对象。在VM中只有一个类对象，因此不管有几个对象，只能有一个线程执行静态同步方法。\n\n```java\npublic static synchronized void add(int value){\n      count += value;\n}\n```\n\n等价于锁在类对象上：\n\n```java\nclass Test{\n    public static void test() {\n        synchronized(Test.class) {\n            \n        }\n    }\n}\n```\n\n### 实例方法代码块\n\n- 不需要同步整个方法，只需要同步方法里面的一部分，可以借助同步块来完成工作。\n- 括号中的对象是同步代码调用的实例，本例中是`this`。这个对象称为监视对象。\n- 在该对象上本方法被声明为同步的。\n\n**代码块必须要传递一个对象作为锁的载体，可以是独立创建的对象或者是代码块所在实例本身（this指针）。**\n\n```java\npublic void add(int value){\n\tsynchronized(this){\n\t   this.count += value;   \n\t}\n}\n```\n\n下面两个方法的代码，效果是一样的：\n- 只能有一个线程执行(针对同一个对象) \n- 第二个方法是不同的线程执行的时候会在同步块里面发生等待(针对同一对象)\n\n```java\npublic class MyClass {\n    public synchronized void log1(String msg1, String msg2){\n        log.writeln(msg1);\n        log.writeln(msg2);\n    }\n    \n    public void log2(String msg1, String msg2){\n        synchronized(this){\n            log.writeln(msg1);\n            log.writeln(msg2);\n        }\n    }\n}\n```\n\n### 静态方法代码块\n\n下面两个静态方法是在类对象上的:\n- 一个线程只能在同一时间执行上面的任何一个方法。\n- 对于第二个方法：只能有一个线程在代码块里面执行。\n\n```java\n  public class MyClass {\n\n    public static synchronized void log1(String msg1, String msg2){\n       log.writeln(msg1);\n       log.writeln(msg2);\n    }\n\n  \n    public static void log2(String msg1, String msg2){\n       synchronized(MyClass.class){\n          log.writeln(msg1);\n          log.writeln(msg2);  \n       }\n    }\n  }\n```\n\n## 底层实现\n\n\u003e https://github.com/farmerjohngit/myblog/issues/12\n\n### 代码块级\n\n同步代码块的加锁、解锁是通过 Javac 编译器实现的，底层是借助`monitorenter`和`monitorerexit`。\n\n```java\nstatic final Object lock = new Object();\nstatic int counter = 0;\n \npublic static void main(String[] args) {\n    synchronized (lock) {\n        counter++;\n    }\n}\n```\n\n```java\npublic static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n\tCode:\n      stack=2, locals=3, args_size=1\n         0: getstatic     #2                  // \u003c- lock引用 （synchronized开始）\n         3: dup\n         4: astore_1                          // lock引用 -\u003e slot 1\n         5: monitorenter                      // 将 lock对象 MarkWord 置为 Monitor 指针\n         6: getstatic     #3                  // \u003c- i\n         9: iconst_1                          // 准备常数 1\n        10: iadd                              // +1\n        11: putstatic     #3                  // -\u003e i\n        14: aload_1                           // \u003c- lock引用\n        15: monitorexit                       // 将 lock对象 MarkWord 重置, 唤醒 EntryList\n        16: goto          24\n        19: astore_2                          // e -\u003e slot 2 \n        20: aload_1                           // \u003c- lock引用\n        21: monitorexit                       // 将 lock对象 MarkWord 重置, 唤醒 EntryList\n        22: aload_2                           // \u003c- slot 2 (e)\n        23: athrow                            // throw e\n        24: return\n      Exception table:\n         from    to  target type\n             6    16    19   any\n            19    22    19   any\n      LineNumberTable:\n        line 8: 0\n        line 9: 6\n        line 10: 14\n        line 11: 24\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      25     0  args   [Ljava/lang/String;\n      StackMapTable: number_of_entries = 2\n        frame_type = 255 /* full_frame */\n          offset_delta = 19\n          locals = [ class \"[Ljava/lang/String;\", class java/lang/Object ]\n          stack = [ class java/lang/Throwable ]\n        frame_type = 250 /* chop */\n          offset_delta = 4\n```\n\n从字节码中可知同步语句块的实现使用的是`monitorenter`和`monitorexit`指令，其中`monitorenter`指令指向同步代码块的开始位置，`monitorexit`指令则指明同步代码块的结束位置，当执行`monitorenter`指令时，当前线程将试图获取[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/Mark Word|mark word]]里面存储的[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|monitor]]，当 `monitor`的进入计数器为 0，那线程可以成功取得`monitor`，并将计数器值设置为1，取锁成功。\n\n`monitorenter`指令会将Mark Word置为Monitor指针，再之前会保存对象的hash code等信息。\n\n如果当前线程已经拥有 `monitor` 的持有权，那它可以重入这个 `monitor` ，重入时计数器的值也会加 1。倘若其他线程已经拥有`monitor`的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即`monitorexit`指令被执行，执行线程将释放 `monitor`并设置计数器值为0 ，其他线程将有机会持有 `monitor` 。\n\n`monitorexit`指令会从复制的备份中恢复对象的hash code等信息。\n\n值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 `monitorenter` 指令都有执行其对应 `monitorexit` 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 `monitorenter` 和 `monitorexit` 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 `monitorexit` 指令。从上面的字节码中也可以看出有两个`monitorexit`指令，它就是异常结束时被执行的释放`monitor` 的指令。\n\n异常处理会根据Exception table：\n在6-16行/19-22行发生异常，都会跳转到19行，19行就是释放锁的地方。\n```java\nException table:\n from    to  target type\n\t 6    16    19   any\n\t19    22    19   any\n```\n\n### 方法级\n\n同步方法的加锁、解锁是通过 Javac 编译器实现的，底层是借助`ACC_SYNCHRONIZED`访问标识符来实现的，代码如下所示：\n\n```java\npublic class Hello {\n    public synchronized void test() {\n        System.out.println(\"test\");\n    }\n}\n```\n\n**方法级的同步是隐式**，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 `ACC_SYNCHRONIZED` 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 `ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了，执行线程将先持有`monitor`，然后再执行方法，最后在方法完成(无论是正常完成还是非正常完成)时释放`monitor`。在方法执行期间，执行线程持有了`monitor`，其他任何线程都无法再获得同一个`monitor`。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的`monitor`将在异常抛到同步方法之外时自动释放。\n\n下面我们看看字节码层面如何实现：\n\n```java\npublic class Hello {\n  public Hello();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"\u003cinit\u003e\":()V\n       4: return\n  public synchronized void test();\n    Code:\n       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #3                  // String test\n       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n\n## synchronized的不足之处\n\nsynchronized是用操作系统提供的monitor实现的，所以开销比较大，也不是很灵活：\n- 如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，**同一时间只能有一个线程执行**。\n- synchronized无法知道线程有没有成功获取到锁。\n- 使用synchronized，如果临界区因为IO或者[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/sleep|sleep]]方法等原因阻塞了，而当前线程又没有释放锁，就会导致**所有线程等待**。\n\n\u003e 针对性能问题，java6开始有了[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]和[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/偏向锁|偏向锁]]。\n\u003e 针对功能性问题，在locks包下的锁解决了。\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/waitnotify":{"title":"wait\u0026notify","content":"# wait\u0026notify\n\n## wait\n\n### 为什么需要wait\n\n- 由于条件不满足，小南不能继续进行计算\n- 但小南如果一直占用着锁，其它人就得一直阻塞，效率太低\n![[z-oblib/z2-attachments/Pasted image 20220528165543.png]]\n- 于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开，\n- 其它人可以由老王随机安排进屋\n- 直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法）\n![[z-oblib/z2-attachments/Pasted image 20220528165605.png]]\n- 小南于是可以离开休息室，重新进入竞争锁的队列\n![[z-oblib/z2-attachments/Pasted image 20220528165629.png]]\n\n### 原理\n\n![[z-oblib/z2-attachments/Pasted image 20220528170242.png]]\n\n1. Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态\n\u003e 不管是等外卖的还是等烟的都会在一个房间里等待，唤醒的时候不能区分。[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/ReentrantLock|ReentrantLock]]改进了这一点。\n3. BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片\n4. BLOCKED 线程会在 Owner 线程释放锁时唤醒\n5. WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争\n\n\u003e waiting和blocked状态下的线程在本质上都是blocked状态，但waiting线程是在等待叫号（所以用Set），而blocked是在排队（所以用List）。\n\n### 使用\n\n- wait和notify是针对重量级锁的。\n- obj.wait() 让进入 object 监视器的线程到 waitSet 等待。\n- obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 。\n- obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒。\n它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法。\n\n## notify\n\nnotify若遇到多个wait线程，不能指定叫醒谁，只能随机叫醒或者都叫醒。这种情况叫做**虚假唤醒**。\n\n通过notifyAll唤醒所有wait线程，并在被唤醒中改用while循环判断条件，这样能防止虚假唤醒。\n\n## 正确使用方式\n\n```java\nsynchronized(lock) {\n    while(条件不成立) {\n        lock.wait();\n    }\n    // 干活\n}\n \n//另一个线程\nsynchronized(lock) {\n    lock.notifyAll();\n}\n```\n\n注意wait线程使用while(条件)，唤醒者使用notifyAll()。\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/yield":{"title":"yield","content":"# yield\n\n## 作用\n\n1. 调用 yield 会让当前线程从 Running 进入 Runnable  就绪状态，然后调度执行其它线程。\n2. 具体的实现依赖于操作系统的任务调度器。\n\n","lastmodified":"2023-01-23T15:37:51.750680517Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/NIO/NIO%E5%9F%BA%E7%A1%80":{"title":"一. NIO 基础","content":"\n# 一. NIO 基础\n\nnon-blocking io 非阻塞 IO\n\n## 1. 三大组件\n\n### 1.1 Channel \u0026 Buffer\n\nchannel 有一点类似于 stream，它就是读写数据的**双向通道**，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\n\n```mermaid\ngraph LR\nchannel --\u003e buffer\nbuffer --\u003e channel\n```\n\n常见的 Channel 有\n\n- FileChannel\n- DatagramChannel\n- SocketChannel\n- ServerSocketChannel\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\n- ByteBuffer\n    - MappedByteBuffer\n    - DirectByteBuffer\n    - HeapByteBuffer\n- ShortBuffer\n- IntBuffer\n- LongBuffer\n- FloatBuffer\n- DoubleBuffer\n- CharBuffer\n\n### 1.2 Selector\n\nselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n\n#### 多线程版设计\n\n```mermaid\ngraph TD\nsubgraph 多线程版\nt1(thread) --\u003e s1(socket1)\nt2(thread) --\u003e s2(socket2)\nt3(thread) --\u003e s3(socket3)\nend\n```\n\n#### ⚠️ 多线程版缺点\n\n- 内存占用高\n- 线程上下文切换成本高\n- 只适合连接数少的场景\n\n#### 线程池版设计\n\n```mermaid\ngraph TD\nsubgraph 线程池版\nt4(thread) --\u003e s4(socket1)\nt5(thread) --\u003e s5(socket2)\nt4(thread) -.-\u003e s6(socket3)\nt5(thread) -.-\u003e s7(socket4)\nend\n```\n\n#### ⚠️ 线程池版缺点\n\n- 阻塞模式下，线程仅能处理一个 socket 连接\n- 仅适合短连接场景\n\n\u003e Socket API 工作在阻塞模式下：一个线程同时只能处理一个socket连接，直到socket断开。\n\u003e 早期Tomcat用此设计思路来处理HTTP等短连接较多的场景，适合HTTP1.0短链接，不适合HTTP1.1长连接。\n\n#### selector 版设计\n\n\u003e 底层是调用了操作系统的 select\u0026poll\u0026epoll 接口。\n\nselector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在**非阻塞**模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）。\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --\u003e selector\nselector --\u003e c1(channel)\nselector --\u003e c2(channel)\nselector --\u003e c3(channel)\nend\n```\n\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n\n## 2. ByteBuffer\n\n有一普通文本文件 data.txt，内容为\n\n```\n1234567890abcd\n```\n\n使用 FileChannel 来读取文件内容\n\n```java\n@Slf4j\npublic class ChannelDemo1 {\n    public static void main(String[] args) {\n        try (RandomAccessFile file = new RandomAccessFile(\"helloword/data.txt\", \"rw\")) {\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(10);\n            do {\n                // 向 buffer 写入\n                int len = channel.read(buffer);\n                log.debug(\"读到字节数：{}\", len);\n                if (len == -1) {\n                    break;\n                }\n                // 切换 buffer 读模式\n                buffer.flip();\n                while(buffer.hasRemaining()) {\n                    log.debug(\"{}\", (char)buffer.get());\n                }\n                // 切换 buffer 写模式\n                buffer.clear();\n            } while (true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n```\n\n### 2.1 ByteBuffer 正确使用姿势\n\n1. 向 buffer 写入数据，例如调用 channel.read(buffer) (从channel读，并写入到buffer)\n2. 调用 `flip()` 切换至**读模式**\n3. 从 buffer 读取数据，例如调用 buffer.get()\n4. 调用 `clear()` 或 `compact()` 切换至**写模式**\n5. 重复 1~4 步骤\n\n### 2.2 ByteBuffer 结构\n\nByteBuffer 有以下重要属性\n\n- capacity 容量\n- position 读写指针下标\n- limit 读写量限制\n\n一开始\n\n![[z-oblib/z2-attachments/c8a78053293105a1ce22334ebe26853f.png]]\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![[z-oblib/z2-attachments/86a06b91acb74a9c2ff00a10004bdc3d.png]]\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n![[z-oblib/z2-attachments/c3197ff6217affbbcc20ab865ae58ee1.png]]\n\n读取 4 个字节后，状态\n\n![[z-oblib/z2-attachments/8202e9da57d2a913d86d057dc5140226.png]]\n\nclear 动作发生后，状态\n\n![[z-oblib/z2-attachments/c8a78053293105a1ce22334ebe26853f.png]]\n\ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n![[z-oblib/z2-attachments/a46df9c4e66a8e545792dbedfc4650fd.png]]\n\n#### 💡 调试工具类\n\n```java\npublic class ByteBufferUtil {\n    private static final char[] BYTE2CHAR = new char[256];\n    private static final char[] HEXDUMP_TABLE = new char[256 * 4];\n    private static final String[] HEXPADDING = new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 \u003e\u003e\u003e 4];\n    private static final String[] BYTE2HEX = new String[256];\n    private static final String[] BYTEPADDING = new String[16];\n\n    static {\n        final char[] DIGITS = \"0123456789abcdef\".toCharArray();\n        for (int i = 0; i \u003c 256; i++) {\n            HEXDUMP_TABLE[i \u003c\u003c 1] = DIGITS[i \u003e\u003e\u003e 4 \u0026 0x0F];\n            HEXDUMP_TABLE[(i \u003c\u003c 1) + 1] = DIGITS[i \u0026 0x0F];\n        }\n\n        int i;\n\n        // Generate the lookup table for hex dump paddings\n        for (i = 0; i \u003c HEXPADDING.length; i++) {\n            int padding = HEXPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding * 3);\n            for (int j = 0; j \u003c padding; j++) {\n                buf.append(\"   \");\n            }\n            HEXPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i = 0; i \u003c HEXDUMP_ROWPREFIXES.length; i++) {\n            StringBuilder buf = new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i \u003c\u003c 4 \u0026 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, '|');\n            buf.append('|');\n            HEXDUMP_ROWPREFIXES[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-hex-dump conversion\n        for (i = 0; i \u003c BYTE2HEX.length; i++) {\n            BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);\n        }\n\n        // Generate the lookup table for byte dump paddings\n        for (i = 0; i \u003c BYTEPADDING.length; i++) {\n            int padding = BYTEPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding);\n            for (int j = 0; j \u003c padding; j++) {\n                buf.append(' ');\n            }\n            BYTEPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-char conversion\n        for (i = 0; i \u003c BYTE2CHAR.length; i++) {\n            if (i \u003c= 0x1f || i \u003e= 0x7f) {\n                BYTE2CHAR[i] = '.';\n            } else {\n                BYTE2CHAR[i] = (char) i;\n            }\n        }\n    }\n\n    /**\n     * 打印所有内容\n     * @param buffer\n     */\n    public static void debugAll(ByteBuffer buffer) {\n        int oldlimit = buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin = new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println(\"+--------+-------------------- all ------------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    }\n\n    /**\n     * 打印可读取内容\n     * @param buffer\n     */\n    public static void debugRead(ByteBuffer buffer) {\n        StringBuilder builder = new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println(\"+--------+-------------------- read -----------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), buffer.limit());\n        System.out.println(builder);\n    }\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) {\n        if (isOutOfBounds(offset, length, buf.capacity())) {\n            throw new IndexOutOfBoundsException(\n                    \"expected: \" + \"0 \u003c= offset(\" + offset + \") \u003c= offset + length(\" + length\n                            + \") \u003c= \" + \"buf.capacity(\" + buf.capacity() + ')');\n        }\n        if (length == 0) {\n            return;\n        }\n        dump.append(\n                \"         +-------------------------------------------------+\" +\n                        NEWLINE + \"         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\" +\n                        NEWLINE + \"+--------+-------------------------------------------------+----------------+\");\n\n        final int startIndex = offset;\n        final int fullRows = length \u003e\u003e\u003e 4;\n        final int remainder = length \u0026 0xF;\n\n        // Dump the rows which have 16 bytes.\n        for (int row = 0; row \u003c fullRows; row++) {\n            int rowStartIndex = (row \u003c\u003c 4) + startIndex;\n\n            // Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + 16;\n            for (int j = rowStartIndex; j \u003c rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(\" |\");\n\n            // ASCII dump\n            for (int j = rowStartIndex; j \u003c rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append('|');\n        }\n\n        // Dump the last row which has less than 16 bytes.\n        if (remainder != 0) {\n            int rowStartIndex = (fullRows \u003c\u003c 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + remainder;\n            for (int j = rowStartIndex; j \u003c rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(HEXPADDING[remainder]);\n            dump.append(\" |\");\n\n            // Ascii dump\n            for (int j = rowStartIndex; j \u003c rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(BYTEPADDING[remainder]);\n            dump.append('|');\n        }\n\n        dump.append(NEWLINE +\n                \"+--------+-------------------------------------------------+----------------+\");\n    }\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {\n        if (row \u003c HEXDUMP_ROWPREFIXES.length) {\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        } else {\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex \u0026 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, '|');\n            dump.append('|');\n        }\n    }\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) {\n        return (short) (buffer.get(index) \u0026 0xFF);\n    }\n}\n```\n\n### 2.3 ByteBuffer 常见方法\n\n#### 分配空间\n\n可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\n\n```java\nBytebuffer buf = ByteBuffer.allocate(16);\n```\n\n#### 向 buffer 写入数据\n\n有两种办法\n\n- 调用 channel 的 read 方法 (从channel读，向buffer写)\n- 调用 buffer 自己的 put 方法\n\n```java\nint readBytes = channel.read(buf);\n```\n\n和\n\n```java\nbuf.put((byte)127);\n```\n\n#### 从 buffer 读取数据\n\n同样有两种办法\n\n- 调用 channel 的 write 方法（从buffer读，向channel写）\n- 调用 buffer 自己的 get 方法\n\n```java\nint writeBytes = channel.write(buf);\n```\n\n和\n\n```java\nbyte b = buf.get();\n```\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n- 可以调用 rewind 方法将 position 重新置为 0（从头重新读）\n- 或者调用 get(int i) 方法获取索引 i 的内容，它**不会**移动读指针\n\n#### mark 和 reset\n\n\u003e 对rewind的增强，可以回溯到指定位置而不只是起点。\n\nmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n\u003e **注意**\n\u003e rewind 和 flip 都会清除 mark 位置。\n\n#### 字符串与 ByteBuffer 互转\n\n```java\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\"你好\");\nByteBuffer buffer2 = Charset.forName(\"utf-8\").encode(\"你好\");\n\ndebug(buffer1);\ndebug(buffer2);\n\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());\nSystem.out.println(buffer3.toString());\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好\n```\n\n#### ⚠️ Buffer 的线程安全\n\n\u003e Buffer 是**非线程安全的**\n\n### 2.4 Scattering Reads\n\n分散读取，有一个文本文件 3parts.txt\n\n```\nonetwothree\n```\n\n使用如下方式读取，可以将数据填充至多个 buffer\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer a = ByteBuffer.allocate(3);\n    ByteBuffer b = ByteBuffer.allocate(3);\n    ByteBuffer c = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]{a, b, c});\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+\n```\n\n### 2.5 Gathering Writes\n\n使用如下方式写入，可以将多个 buffer 的数据填充至 channel\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer d = ByteBuffer.allocate(4);\n    ByteBuffer e = ByteBuffer.allocate(4);\n    channel.position(11);\n\n    d.put(new byte[]{'f', 'o', 'u', 'r'});\n    e.put(new byte[]{'f', 'i', 'v', 'e'});\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]{d, e});\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+\n```\n\n文件内容\n\n```\nonetwothreefourfive\n```\n\n### 2.6 练习\n\n网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔 但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\n- Hello,world\\n\n- I'm zhangsan\\n\n- How are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\n- Hello,world\\nI'm zhangsan\\nHo\n- w are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\n\n```java\npublic static void main(String[] args) {\n    ByteBuffer source = ByteBuffer.allocate(32);\n    //                     11            24\n    source.put(\"Hello,world\\nI'm zhangsan\\nHo\".getBytes());\n    split(source);\n\n    source.put(\"w are you?\\nhaha!\\n\".getBytes());\n    split(source);\n}\n\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    int oldLimit = source.limit();\n    for (int i = 0; i \u003c oldLimit; i++) {\n        if (source.get(i) == '\\n') {\n            System.out.println(i);\n            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());\n            // 0 ~ limit\n            source.limit(i + 1);\n            target.put(source); // 从source 读，向 target 写\n            debugAll(target);\n            source.limit(oldLimit);\n        }\n    }\n    source.compact();\n}\n```\n\n## 3. 文件编程\n\n### 3.1 FileChannel\n\n#### ⚠️ FileChannel 工作模式\n\n\u003e FileChannel 只能工作在阻塞模式下\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n- 通过 FileInputStream 获取的 channel 只能读\n- 通过 FileOutputStream 获取的 channel 只能写\n- 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n- 这时读取会返回 -1\n- 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n#### 强制写入\n\n操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n\n### 3.2 两个 Channel 传输数据\n\n```java\nString FROM = \"helloword/data.txt\";\nString TO = \"helloword/to.txt\";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println(\"transferTo 用时：\" + (end - start) / 1000_000.0);\n```\n\n输出\n\n```\ntransferTo 用时：8.2011\n```\n\n超过 2g 大小的文件传输\n\n```java\npublic class TestFileChannelTransferTo {\n    public static void main(String[] args) {\n        try (\n                FileChannel from = new FileInputStream(\"data.txt\").getChannel();\n                FileChannel to = new FileOutputStream(\"to.txt\").getChannel();\n        ) {\n            // 效率高，底层会利用操作系统的零拷贝进行优化\n            long size = from.size();\n            // left 变量代表还剩余多少字节\n            for (long left = size; left \u003e 0; ) {\n                System.out.println(\"position:\" + (size - left) + \" left:\" + left);\n                left -= from.transferTo((size - left), left, to);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n实际传输一个超大文件\n\n```\nposition:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219\n```\n\n### 3.3 Path\n\njdk7 引入了 Path 和 Paths 类\n\n- Path 用来表示文件路径\n- Paths 是工具类，用来获取 Path 实例\n\n```java\nPath source = Paths.get(\"1.txt\"); // 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source = Paths.get(\"d:\\\\1.txt\"); // 绝对路径 代表了  d:\\1.txt\n\nPath source = Paths.get(\"d:/1.txt\"); // 绝对路径 同样代表了  d:\\1.txt\n\nPath projects = Paths.get(\"d:\\\\data\", \"projects\"); // 代表了  d:\\data\\projects\n```\n\n- `.` 代表了当前路径\n- `..` 代表了上一级路径\n\n例如目录结构如下\n\n```\nd:\n    |- data\n        |- projects\n            |- a\n            |- b\n```\n\n代码\n\n```java\nPath path = Paths.get(\"d:\\\\data\\\\projects\\\\a\\\\..\\\\b\");\nSystem.out.println(path);\nSystem.out.println(path.normalize()); // 正常化路径\n```\n\n会输出\n\n```\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n```\n\n### 3.4 Files\n\n检查文件是否存在\n\n```java\nPath path = Paths.get(\"helloword/data.txt\");\nSystem.out.println(Files.exists(path));\n```\n\n创建一级目录\n\n```java\nPath path = Paths.get(\"helloword/d1\");\nFiles.createDirectory(path);\n```\n\n- 如果目录已存在，会抛异常 FileAlreadyExistsException\n- 不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n创建多级目录用\n\n```java\nPath path = Paths.get(\"helloword/d1/d2\");\nFiles.createDirectories(path);\n```\n\n拷贝文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.copy(source, target);\n```\n\n- 如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\n\n```java\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n```\n\n移动文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/data.txt\");\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n```\n\n- StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n删除文件\n\n```java\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.delete(target);\n```\n\n- 如果文件不存在，会抛异常 NoSuchFileException\n\n删除目录\n\n```java\nPath target = Paths.get(\"helloword/d1\");\n\nFiles.delete(target);\n```\n\n- 如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\n遍历目录文件\n\n```java\npublic static void main(String[] args) throws IOException {\n    Path path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\n    AtomicInteger dirCount = new AtomicInteger();\n    AtomicInteger fileCount = new AtomicInteger();\n    Files.walkFileTree(path, new SimpleFileVisitor\u003cPath\u003e(){\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(dir);\n            dirCount.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(file);\n            fileCount.incrementAndGet();\n            return super.visitFile(file, attrs);\n        }\n    });\n    System.out.println(dirCount); // 133\n    System.out.println(fileCount); // 1479\n}\n```\n\n统计 jar 的数目\n\n```java\nPath path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\nAtomicInteger fileCount = new AtomicInteger();\nFiles.walkFileTree(path, new SimpleFileVisitor\u003cPath\u003e(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        if (file.toFile().getName().endsWith(\".jar\")) {\n            fileCount.incrementAndGet();\n        }\n        return super.visitFile(file, attrs);\n    }\n});\nSystem.out.println(fileCount); // 724\n```\n\n删除多级目录\n\n```java\nPath path = Paths.get(\"d:\\\\a\");\nFiles.walkFileTree(path, new SimpleFileVisitor\u003cPath\u003e(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        Files.delete(file);\n        return super.visitFile(file, attrs);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) \n        throws IOException {\n        Files.delete(dir);\n        return super.postVisitDirectory(dir, exc);\n    }\n});\n```\n\n#### ⚠️ 删除很危险\n\n\u003e 删除是危险操作，确保要递归删除的文件夹没有重要内容\n\n拷贝多级目录\n\n```java\nlong start = System.currentTimeMillis();\nString source = \"D:\\\\Snipaste-1.16.2-x64\";\nString target = \"D:\\\\Snipaste-1.16.2-x64aaa\";\n\nFiles.walk(Paths.get(source)).forEach(path -\u003e {\n    try {\n        String targetName = path.toString().replace(source, target);\n        // 是目录\n        if (Files.isDirectory(path)) {\n            Files.createDirectory(Paths.get(targetName));\n        }\n        // 是普通文件\n        else if (Files.isRegularFile(path)) {\n            Files.copy(path, Paths.get(targetName));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlong end = System.currentTimeMillis();\nSystem.out.println(end - start);\n```\n\n## 4. 网络编程\n\n### 4.1 非阻塞 vs 阻塞\n\n#### 阻塞\n\n- 阻塞模式下，相关方法都会导致线程暂停\n    - ServerSocketChannel.accept 会在没有连接建立时让线程暂停\n    - SocketChannel.read 会在没有数据可读时让线程暂停\n    - 阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n- 单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n- 但多线程下，有新的问题，体现在以下方面\n    - 32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n    - 可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n服务器端\n\n```java\n// 使用 nio 来理解阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\n\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n// 3. 连接集合\nList\u003cSocketChannel\u003e channels = new ArrayList\u003c\u003e();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug(\"connecting...\");\n    \n    // \n    SocketChannel sc = ssc.accept();  // 阻塞方法，线程停止运行\n    log.debug(\"connected... {}\", sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        log.debug(\"before read... {}\", channel);\n        channel.read(buffer); // 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug(\"after read...{}\", channel);\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSystem.out.println(\"waiting...\");\n```\n\n#### 非阻塞\n\n- 非阻塞模式下，相关方法都会不会让线程暂停\n    - 在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\n    - SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept\n    - 写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n- 但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断**自旋**运行，白白浪费了 cpu\n- 数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\n\n服务器端，客户端代码不变\n\n```java\n// 使用 nio 来理解非阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false); // 非阻塞模式\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n// 3. 连接集合\nList\u003cSocketChannel\u003e channels = new ArrayList\u003c\u003e();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是 null\n    if (sc != null) {\n        log.debug(\"connected... {}\", sc);\n        sc.configureBlocking(false); // 非阻塞模式\n        channels.add(sc);\n    }\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read \u003e 0) {\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug(\"after read...{}\", channel);\n        }\n    }\n}\n```\n\n\u003e sc非阻塞模式下一个客户端连续发送多个包就会观测到粘包现象。\n\n#### 多路复用\n\n**单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用**\n\n- 多路复用**仅**针对网络 IO、普通文件 IO 没法利用多路复用\n- 如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n    - 有可连接事件时才去连接\n    - 有可读事件才去读取\n    - 有可写事件才去写入\n        - 限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n### 4.2 Selector\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --\u003e selector\nselector --\u003e c1(channel)\nselector --\u003e c2(channel)\nselector --\u003e c3(channel)\nend\n```\n\n好处\n\n- 一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n- 让这个线程能够被充分利用\n- 节约了线程的数量\n- 减少了线程上下文切换\n\n#### 创建\n\n```java\nSelector selector = Selector.open();\n```\n\n#### 绑定 Channel 事件\n\n也称之为注册事件，绑定的事件 selector 才会关心\n\n```java\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, 绑定事件);\n```\n\n- channel 必须工作在**非**阻塞模式\n- FileChannel **没有**非阻塞模式，因此不能配合 selector 一起使用\n- 绑定的事件类型可以有\n    - connect - 客户端连接成功时触发\n    - accept - 服务器端成功接受连接时触发\n    - read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\n    - write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n#### 监听 Channel 事件\n\n可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n\n方法1，阻塞直到绑定事件发生\n\n```java\nint count = selector.select();\n```\n\n\u003e select方法底层调用的是操作系统的[[3-计算机科学/3-操作系统/Linux/epoll|epoll]] 中epoll_wait接口，读取有状态的IO的阻塞方法，可设置超时。\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\n\n```java\nint count = selector.select(long timeout);\n```\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\n\n```java\nint count = selector.selectNow();\n```\n\n#### 💡 select 何时不阻塞\n\n\u003e -   事件发生时\n\u003e     -   客户端发起连接请求，会触发 accept 事件\n\u003e     -   客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\n\u003e     -   channel 可写，会触发 write 事件\n\u003e     -   在 linux 下 nio bug 发生时\n\u003e -   调用 selector.wakeup()\n\u003e -   调用 selector.close()\n\u003e -   selector 所在线程 interrupt\n\n### 4.3 处理 accept 事件\n\n客户端代码为\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket(\"localhost\", 8080)) {\n            System.out.println(socket);\n            socket.getOutputStream().write(\"world\".getBytes());\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n服务器端代码为\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count \u003c= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                // 拿到所有可读可写可连接的事件集合\n                Set\u003cSelectionKey\u003e keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator\u003cSelectionKey\u003e iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        log.debug(\"{}\", sc);\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### 💡 事件发生后能否不处理\n\n\u003e 事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是[[3-计算机科学/3-操作系统/Linux/epoll#水平触发|水平触发]]\n\n### 4.4 处理 read 事件\n\n\u003e下面的代码`int count = selector.select();`处的阻塞会同时被连接建立和客户端写入给唤醒。因为此时selector注册了两个事件类型。\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector sele ctor = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count \u003c= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                // 这里读写sc和连接建立的ssc公用了同一个selectedKeys集合\n                Set\u003cSelectionKey\u003e keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator\u003cSelectionKey\u003e iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        sc.configureBlocking(false);\n                        // 和连接建立部分共用同一个selector\n                        // 现在selector会同时被 OP_ACCEPT和OP_READ触发\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug(\"连接已建立: {}\", sc);\n                    } else if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(128);\n                        int read = sc.read(buffer);\n                        if(read == -1) {\n                            key.cancel();\n                            sc.close();\n                        } else {\n                            buffer.flip();\n                            debug(buffer);\n                        }\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n开启两个客户端，修改一下发送文字，输出\n\n```\nsun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+\n```\n\n#### 💡 为何要 iter.remove()\n\n\u003e 客户端断开连接会触发一次read事件。\n\n\u003e 因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n\u003e \n\u003e -   第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey\n\u003e -   第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n![[z-oblib/z2-attachments/59d24a4ab1f1de94f7fb23f9530238a1.png]]\n\nselectedKeys 集合就是绿框，有新事件发生就会把对应的key放进去，事件处理了只会更新key状态，不会自动从集合中删除key。\n\n#### 💡 cancel 的作用\n\n\u003e cancel 会取消注册在 selector 上的 channel，并从 **keys 集合**中删除 key 后续不会再监听事件\n\n#### ⚠️ 不处理边界的问题\n\n以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss=new ServerSocket(9000);\n        while (true) {\n            Socket s = ss.accept();\n            InputStream in = s.getInputStream();\n            // 这里这么写，有没有问题\n            byte[] arr = new byte[4];\n            while(true) {\n                int read = in.read(arr);\n                // 这里这么写，有没有问题\n                if(read == -1) {\n                    break;\n                }\n                System.out.println(new String(arr, 0, read));\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket max = new Socket(\"localhost\", 9000);\n        OutputStream out = max.getOutputStream();\n        out.write(\"hello\".getBytes());\n        out.write(\"world\".getBytes());\n        out.write(\"你好\".getBytes());\n        max.close();\n    }\n}\n```\n\n输出\n\n```\nhell\nowor\nld�\n�好\n```\n\n为什么？\n\n\u003e 一个字符会有多个字节，边界的字符可能不完整。\n\n#### 处理消息的边界\n\n![[z-oblib/z2-attachments/3b9638a1e23e235165906d2db3fdc238.png]]\n\n- 一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n- 另一种思路是按分隔符拆分，缺点是效率低\n- TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\n    - Http 1.1 是 TLV 格式\n    - Http 2.0 是 LTV 格式\n\n```mermaid\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 -\u003e\u003e s: 发送 01234567890abcdef3333\\r\ns -\u003e\u003e b1: 第一次 read 存入 01234567890abcdef\ns -\u003e\u003e b2: 扩容\nb1 -\u003e\u003e b2: 拷贝 01234567890abcdef\ns -\u003e\u003e b2: 第二次 read 存入 3333\\r\nb2 -\u003e\u003e b2: 01234567890abcdef3333\\r\n```\n\n##### 服务器端\n\n之前存在的问题：\n原来的buffer是try块中的本地变量，虽然buffer不够大不会报错，但是第一次没有读到终止符就不会输出内容，并且本地变量的原因第一次读取的内容也丢失了。\n\n水平触发保证了buffer不读完不会结束，所以会输出最后的`3333\\r`，但是前面的字符丢失了。\n\n但是也不能把buffer提到最外面，这样会存在多个channel的并发访问同一个buffer的问题了。\n\n可以将buffer作为附件关联到selector上。\n\n\n判断是否要扩容的方法：\ncompact会将未读取数据移到buffer开头，将状态转回写模式，并且position会放在剩余数据结尾。\n如果position 1== limit 说明compact之前的读未消耗掉任何数据。\n\n```java\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    for (int i = 0; i \u003c source.limit(); i++) {\n        // 找到一条完整消息\n        if (source.get(i) == '\\n') {\n            int length = i + 1 - source.position();\n            // 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            // 从 source 读，向 target 写\n            for (int j = 0; j \u003c length; j++) {\n                target.put(source.get());\n            }\n            debugAll(target);\n        }\n    }\n    source.compact(); // 0123456789abcdef  position 16 limit 16\n}\n\npublic static void main(String[] args) throws IOException {\n    // 1. 创建 selector, 管理多个 channel\n    Selector selector = Selector.open();\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    // 2. 建立 selector 和 channel 的联系（注册）\n    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    // key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug(\"sscKey:{}\", sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) {\n        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator(); // accept, read\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug(\"key: {}\", key);\n            // 5. 区分事件类型\n            if (key.isAcceptable()) { // 如果是 accept\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                // 一个服务端--客户端连接对应一个buffer\n                // 用户这个连接接下来发生的若干次读写\n                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment\n                // 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug(\"{}\", sc);\n                log.debug(\"scKey:{}\", scKey);\n            } else if (key.isReadable()) { // 如果是 read\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel\n                    // 获取 selectionKey 上关联的附件\n                    // 注意类型转换\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1\n                    if(read == -1) {\n                        key.cancel();\n                    } else {\n                        split(buffer);\n                        // 需要扩容\n                        if (buffer.position() == buffer.limit()) {\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); // 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        }\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                }\n            }\n        }\n    }\n}\n```\n\n##### 客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSocketAddress address = sc.getLocalAddress();\n// sc.write(Charset.defaultCharset().encode(\"hello\\nworld\\n\"));\nsc.write(Charset.defaultCharset().encode(\"0123\\n456789abcdef\"));\nsc.write(Charset.defaultCharset().encode(\"0123456789abcdef3333\\n\"));\nSystem.in.read();\n```\n\n#### ByteBuffer 大小分配\n\n- 每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer **不能**被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\n- ByteBuffer **不能**太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n    - 一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是**数据拷贝**耗费性能，参考实现 [http://tutorials.jenkov.com/java-performance/resizable-array.html](http://tutorials.jenkov.com/java-performance/resizable-array.html)\n    - 另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续**解析复杂**，优点是避免了拷贝引起的性能损耗\n\n### 4.5 处理 write 事件\n\n#### 一次无法写完例子\n\n- 非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n- 用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n    - 当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\n    - selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n    - 如果不取消，会每次可写均会触发 write 事件\n\n```java\npublic class WriteServer {\n\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector = Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) {\n            selector.select();\n\n            Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    SocketChannel sc = ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);\n                    // 1. 向客户端发送内容\n                    StringBuilder sb = new StringBuilder();\n                    for (int i = 0; i \u003c 3000000; i++) {\n                        sb.append(\"a\");\n                    }\n                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());\n                    int write = sc.write(buffer);\n                    // 3. write 表示实际写了多少字节\n                    System.out.println(\"实际写入字节:\" + write);\n                    // 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) {\n                        // read 1  write 4\n                        // 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        // 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    }\n                } else if (key.isWritable()) {\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    int write = sc.write(buffer);\n                    System.out.println(\"实际写入字节:\" + write);\n                    if (!buffer.hasRemaining()) { // 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class WriteClient {\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        SocketChannel sc = SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress(\"localhost\", 8080));\n        int count = 0;\n        while (true) {\n            selector.select();\n            Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isConnectable()) {\n                    System.out.println(sc.finishConnect());\n                } else if (key.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);\n                    count += sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                }\n            }\n        }\n    }\n}\n```\n\n\u003e 系统有一块网络数据的缓冲区，如果缓冲区满了，就不能继续写入。如果缓冲区可以继续接入，就会发送一个可写信号。\n\n#### 💡 write 为何要取消\n\n只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\n\n\u003e 可写事件是由本机网络缓冲区触发的，所以要确保自己确实有东西要写入时才响应触发。\n\n### 4.6 更进一步\n\n#### 💡 利用多线程优化\n\n\u003e 现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n\n分两组选择器\n\n- 单线程配一个选择器，专门处理 accept 事件\n- 创建 cpu 核心数的线程，**每个线程配一个选择器**，轮流处理 read 事件\n\n![[z-oblib/z2-attachments/707034e47cc2c8f588567de17b7b86a3.png]]\n\n```java\npublic class ChannelDemo7 {\n    public static void main(String[] args) throws IOException {\n        new BossEventLoop().register();\n    }\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable {\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start = false;\n        AtomicInteger index = new AtomicInteger();\n\n        public void register() throws IOException {\n            if (!start) {\n                ServerSocketChannel ssc = ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss = Selector.open();\n                SelectionKey ssckey = ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers = initEventLoops();\n                new Thread(this, \"boss\").start();\n                log.debug(\"boss start...\");\n                start = true;\n            }\n        }\n\n        public WorkerEventLoop[] initEventLoops() {\n//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];\n            for (int i = 0; i \u003c workerEventLoops.length; i++) {\n                workerEventLoops[i] = new WorkerEventLoop(i);\n            }\n            return workerEventLoops;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    boss.select();\n                    Iterator\u003cSelectionKey\u003e iter = boss.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                            SocketChannel sc = c.accept();\n                            sc.configureBlocking(false);\n                            log.debug(\"{} connected\", sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable {\n        private Selector worker;\n        private volatile boolean start = false;\n        private int index;\n\n        private final ConcurrentLinkedQueue\u003cRunnable\u003e tasks = new ConcurrentLinkedQueue\u003c\u003e();\n\n        public WorkerEventLoop(int index) {\n            this.index = index;\n        }\n\n        public void register(SocketChannel sc) throws IOException {\n            if (!start) {\n                worker = Selector.open();\n                new Thread(this, \"worker-\" + index).start();\n                start = true;\n            }\n            tasks.add(() -\u003e {\n                try {\n                    SelectionKey sckey = sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            worker.wakeup();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    worker.select();\n                    Runnable task = tasks.poll();\n                    if (task != null) {\n                        task.run();\n                    }\n                    Set\u003cSelectionKey\u003e keys = worker.selectedKeys();\n                    Iterator\u003cSelectionKey\u003e iter = keys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(128);\n                            try {\n                                int read = sc.read(buffer);\n                                if (read == -1) {\n                                    key.cancel();\n                                    sc.close();\n                                } else {\n                                    buffer.flip();\n                                    log.debug(\"{} message:\", sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            }\n                        }\n                        iter.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 改造成多线程时遇到的问题\n\nworker的选择器注册时机需要注意：\n在worker的register代码是这样的：\n\n```java\nif (!start) {  \n    selector = Selector.open();  \n    thread = new Thread(this, name);  \n    thread.start();  \n    start = true;  \n}\n```\n\n而父线程接收到新的连接建立事件后，向worker注册一个选择器，选择器的注册应该发生在`selector = Selector.open();`之后`thread.start();`之前。\n否则会发生空指针异常或者子线程先行启动阻塞死在run()中的`worker.select();`上导致选择器永远无法注册成功。\n\nworker一旦调用了register就会创建一个线程执行run方法，这时线程会阻塞在run中的selector.select方法中，并且此处还在连接建立阶段，没有读写事件发生。\n这会导致新的连接建立时，在管理连接建立的线程中无法正常调用`sc.register(selector, SelectionKey.OP_READ);`绑定sc的选择器，因为此时worker中的选择器已经是阻塞状态。\n\n解决方法：\n让register和select在同一个线程中执行方便控制先后顺序 --\u003e 将选择器注册动作交给子线程执行 --\u003e 需要将动作传递给子线程 --\u003e 用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程通讯|线程通讯]]：\n将sc的选择器注册动作包装成任务，通过消息队列传递给worker线程去执行。\n\n```java\npublic void register (SocketChannel sc) throws IOException {  \n    if (!start) {  \n        selector = Selector.open();  \n        thread = new Thread(this, name);  \n        thread.start();  \n        start = true;  \n    }  \n    queue.add(()-\u003e{  \n        try {  \n            sc.register(selector, SelectionKey.OP_READ);  \n        } catch (ClosedChannelException e) {  \n            throw new RuntimeException(e);  \n        }  \n    });  \n    selector.wakeup();  \n}\n```\n\n上述代码虽然thread实际可能会后于`selector.wakeup();`启动，但是wakeup有类似park\u0026unpark的提前释放的特性：\n\n\u003ewakeup使尚未返回的第一个选择操作立即返回。 如果另一个线程当前在调用select时被阻塞，那么调用将立即返回。如果当前没有进行选择操作，那么这些方法中的一个的**下一次**调用将立即返回\n\n#### 💡 如何拿到 cpu 个数\n\n\u003e -   Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\n\u003e -   这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\n### 4.7 UDP\n\n- UDP 是无连接的，client 发送数据不会管 server 是否开启\n- server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默**抛弃**\n\n首先启动服务器端\n\n```java\npublic class UdpServer {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            channel.socket().bind(new InetSocketAddress(9999));\n            System.out.println(\"waiting...\");\n            ByteBuffer buffer = ByteBuffer.allocate(32);\n            channel.receive(buffer);\n            buffer.flip();\n            debug(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\nwaiting...\n```\n\n运行客户端\n\n```java\npublic class UdpClient {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            ByteBuffer buffer = StandardCharsets.UTF_8.encode(\"hello\");\n            InetSocketAddress address = new InetSocketAddress(\"localhost\", 9999);\n            channel.send(buffer, address);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n接下来服务器端输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n```\n\n## 5. NIO vs BIO\n\n### 5.1 stream vs channel\n\n\u003estream是更高层抽象的接口，不会去关心系统对IO操作提供的一些缓冲区。\n\n- stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\n- stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n- 二者均为**全双工**，即读写可以同时进行\n\n### 💡 5.2 IO 模型\n\n同步阻塞、同步非阻塞、同步多路复用、异步阻塞（错的没有此情况）、异步非阻塞\n\u003e 异步一定是非阻塞的。\n\n\n- 同步：线程**自己**去获取结果（一个线程）\n- 异步：线程自己不去获取结果，而是由**其它线程**送结果（至少两个线程）\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n- 等待数据阶段\n- 复制数据阶段\n\n![[z-oblib/z2-attachments/9beda40e996875e42ae18f1a4010cb0e.png]]\n\n#### 阻塞 IO\n\n    \n![[z-oblib/z2-attachments/d6140fbe21ad3029c901c39fc656c80f.png]]\n    \n\n#### 非阻塞 IO\n\n\u003e 只有等待数据阶段是非阻塞的，复制数据阶段还是阻塞的。\n\u003e 等待数据时频繁的用户态内核态切换开销较大。\n \n![[z-oblib/z2-attachments/bee47ff0353597736841cb77f39de290.png]]\n    \n\n#### 多路复用\n\n![[z-oblib/z2-attachments/92295a6cadbef7f318b447c195cfdaaf.png]]\n\n#### 信号驱动\n\n不常用。\n\n#### 异步 IO\n\n![[z-oblib/z2-attachments/d24fd0f79f08ba57c427e8105d1b723b.png]]\n\n#### 阻塞 IO vs 多路复用\n\n    \n![[z-oblib/z2-attachments/b14515879b743602954685e6403970ad.png]]\n    \n![[z-oblib/z2-attachments/fe68785fc885d9bbfa4e9fa6a973dbe3.png]]\n\n\u003e 多路复用可以一次返回多个事件：相当于给事件本身加了个缓冲区。\n\u003e 但操作的时候只能线性一个个处理。\n\n#### 🔖 参考\n\nUNIX 网络编程 - 卷 I\n\n### 5.3 零拷贝\n\n\u003e 0拷贝是指不用拷贝到用户态的java内存，而直接在内核态的操作系统内存之间拷贝。\n\n#### 传统 IO 问题\n\n传统的 IO 将一个文件 通过 socket 写出\n\n```java\nFile f = new File(\"helloword/data.txt\");\nRandomAccessFile file = new RandomAccessFile(file, \"r\");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);\n```\n\n内部工作流程是这样的：\n\n![[z-oblib/z2-attachments/f89991c08c85fc0760ce56280440b6b6.png]]\n\n1. java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的**用户态**切换至**内核态**，去调用操作系统（Kernel）的读能力，将数据读入**内核缓冲区**。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\n    \n    \u003e DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n    \n2. 从**内核态**切换回**用户态**，将数据从**内核缓冲区**读入**用户缓冲区**（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n    \n3. 调用 write 方法，这时将数据从**用户缓冲区**（byte[] buf）写入 **socket 缓冲区**，cpu 会参与拷贝\n    \n4. 接下来要向网卡写数据，这项能力 java 又不具备，因此又得从**用户态**切换至**内核态**，调用操作系统的写能力，使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n    \n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n- 用户态与内核态的切换发生了 **3** 次，这个操作比较重量级\n- 数据拷贝了共 **4** 次\n\n#### NIO 优化\n\n通过 DirectByteBuf\n\n- ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存\n- ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存\n\n![[z-oblib/z2-attachments/c3dd38c405a8e36fc37c50dde0478ed8.png]]\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以**使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用**\n\n- 这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\n- java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\n    - DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\n    - 通过专门线程访问引用队列，根据虚引用释放堆外内存\n- 减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\n\n![[z-oblib/z2-attachments/ded2b7613a6a8c4981724457f2157b22.png]]\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 数据从**内核缓冲区**传输到 **socket 缓冲区**，cpu 会参与拷贝\n3. 最后使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n可以看到\n\n- 只发生了一次用户态与内核态的切换\n- 数据拷贝了 3 次\n\n进一步优化（linux 2.4）\n\n![[z-oblib/z2-attachments/f6c24eee6470e9511e439a78cbf37a99.png]]\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 只会将一些 offset 和 length 信息拷入 **socket 缓冲区**，几乎无消耗\n3. 使用 DMA 将 **内核缓冲区**的数据写入网卡，不会使用 cpu\n\n整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\n\n##### 优点\n\n- 更少的用户态与内核态的切换\n- 不利用 cpu 计算，减少 cpu 缓存伪共享 （使用DMA硬件进行数据传输）\n- 零拷贝适合**小**文件传输\n\t- 典型的传输例如网卡，发送的数据可能只被读取一次，但是占用了缓冲区的空间。\n\n### 5.3 AIO\n\nAIO（异步IO） 用来解决数据复制阶段的阻塞问题\n\n- 同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n- 异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n\u003e 异步模型需要底层操作系统（Kernel）提供支持\n\u003e \n\u003e -   Windows 系统通过 IOCP 实现了真正的异步 IO\n\u003e -   Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n#### 文件 AIO\n\n先来看看 AsynchronousFileChannel\n\n```java\n@Slf4j\npublic class AioDemo1 {\n    public static void main(String[] args) throws IOException {\n        try{\n            AsynchronousFileChannel s = \n                AsynchronousFileChannel.open(\n                    Paths.get(\"1.txt\"), StandardOpenOption.READ);\n            ByteBuffer buffer = ByteBuffer.allocate(2);\n            log.debug(\"begin...\");\n            s.read(buffer, 0, null, new CompletionHandler\u003cInteger, ByteBuffer\u003e() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    log.debug(\"read completed...{}\", result);\n                    buffer.flip();\n                    debug(buffer);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    log.debug(\"read failed...\");\n                }\n            });\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        log.debug(\"do other things...\");\n        System.in.read();\n    }\n}\n```\n\n输出\n\n```\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n```\n\n可以看到\n\n- 响应文件读取成功的是另一个线程 Thread-5\n- 主线程并没有 IO 操作阻塞\n\n#### 💡 守护线程\n\n默认文件 AIO 使用的线程都是守护线程，所以最后要执行 `System.in.read()` 以避免守护线程意外结束\n\n#### 网络 AIO\n\n```java\npublic class AioServer {\n    public static void main(String[] args) throws IOException {\n        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    }\n\n    private static void closeChannel(AsynchronousSocketChannel sc) {\n        try {\n            System.out.printf(\"[%s] %s close\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ReadHandler implements CompletionHandler\u003cInteger, ByteBuffer\u003e {\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            try {\n                if (result == -1) {\n                    closeChannel(sc);\n                    return;\n                }\n                System.out.printf(\"[%s] %s read\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            closeChannel(sc);\n            exc.printStackTrace();\n        }\n    }\n\n    private static class WriteHandler implements CompletionHandler\u003cInteger, ByteBuffer\u003e {\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) {\n                sc.write(attachment);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n            closeChannel(sc);\n        }\n    }\n\n    private static class AcceptHandler implements CompletionHandler\u003cAsynchronousSocketChannel, Object\u003e {\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) {\n            this.ssc = ssc;\n        }\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) {\n            try {\n                System.out.printf(\"[%s] %s connected\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            // 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            // 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode(\"server hello!\"), ByteBuffer.allocate(16), new WriteHandler(sc));\n            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            exc.printStackTrace();\n        }\n    }\n}\n```\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/%E6%9F%AF%E9%87%8C%E5%8C%96":{"title":"柯里化","content":"\n# 柯里化\n\n柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c) 。 柯里化不会调用函数。\n\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/%E9%97%AD%E5%8C%85":{"title":"闭包","content":"\n# 闭包\n\n闭包存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。\n环境里是若干对符号和值的对应关系，它既要包括[约束变量](https://zh.m.wikipedia.org/wiki/%E7%BA%A6%E6%9D%9F%E5%8F%98%E9%87%8F \"约束变量\")（该函数内部绑定的符号），也要包括[自由变量](https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F \"自由变量\")（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。\n\n## 参考\n\n[闭包 (计算机科学) - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.m.wikipedia.org/zh/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/GIL":{"title":"GIL","content":"\n# GIL\n\n在任意时间只有一个Python解释器在解释Python bytecode。\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2":{"title":"Python中16进制与字符串转换","content":"# Python中16进制与字符串转换\n\n## python3 中的字符串和编码\n\n- 在最新的 Python 3 版本中，字符串是以 Unicode 编码的\n- Python 的字符串类型是str\n- 在内存中以Unicode表示，一个字符对应若干个字节\n- 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的 bytes\n\n```\n注意区分 `'ABC'` 和` b'ABC'` ，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。\n```\n\n## hex()\n\n- hex() 函数用于将10进制整数转换成16进制，以字符串形式表示\n\n```\n注意! hex() 返回的结果不是整数, 而是 16 进制的字符串表示形式!\n```\n\n## 0x 表示的 16 进制数\n\n```py\na = 0xA\nb = 0x5\nc = a * b\nprint(a)\nprint(c)\n```\n\n输出的结果:\n\n```\n10\n50\n```\n\n```\n两个 16 进制数相乘, 结果是以 10 进制保存的!\n```\n\n## str.encode()\n\n以 Unicode 表示的 str 通过 encode() 方法可以编码为指定的 bytes\n\n```py\nstr.encode(encoding='UTF-8',errors='strict')\n```\n\n```py\n\u003e\u003e\u003e 'ABC'.encode('ascii')\nb'ABC'\n\u003e\u003e\u003e '中文'.encode('utf-8')\nb'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\n\u003e\u003e\u003e '中文'.encode('ascii')\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\n```\n\n- 纯英文的str可以用 ASCII , UTF-8, 编码为 bytes，内容是一样的\n- 含有中文的str可以用 UTF-8 编码为bytes。\n- 含有中文的str无法用ASCII编码\n    - 因为中文编码的范围超过了ASCII编码的范围\n\n```\n该方法返回编码后的字符串，它是一个 bytes 对象。\n```\n\n## bytes.decode()\n\n- 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是 bytes\n- 要把bytes变为str，就需要用decode()方法\n\n```py\nbytes.decode(encoding=\"utf-8\", errors=\"strict\")\n```\n\n```py\n\u003e\u003e\u003e b'ABC'.decode('ascii')\n'ABC'\n\u003e\u003e\u003e b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')\n'中文'\n```\n\n```\n该方法返回解码后的字符串!\n```\n\n如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节:\n\n```py\n\u003e\u003e\u003e b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')\n'中'\n\n```\n\n```\n在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换.\n```\n\n```\n字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，\n即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。\n```\n\n## bytes 与 str 的长度比较\n\n```py\ntext1 = 'abc'\ntext2 = b'abc'\ntext3 = '好'\ntext4 = text3.encode('utf-8')\nprint(len(text1))\nprint(len(text2))\nprint(len(text3))\nprint(len(text4))\nprint('text3:', text3)\nprint('text4:', text4)\n```\n\n输出:\n\n```\n3\n3\n1\n3\n```\n\n- len() 函数对 str 对象时计算的是字符数\n- len() 函数对 bytes 对象时计算的是字节数\n\n## binascii\n\n```\n`a2b_ *` 函数接受仅包含 ASCII 字符的 Unicode 字符串。  \n其他函数只接受类似字节的对象（如字节，字节数组和其他支持缓冲区协议的对象）。\n```\n\n### binascii.b2a_hex(data)\n\n- binascii.b2a_hex(data)\n- binascii.hexlify(data)\n\n\n- 接收 bytes 对象\n- 返回输入 bytes 对象的十六进制表示形式\n    - 返回的是 bytes 对象\n- 输入数据的每个字节都转换为相应的2位十六进制表示\n    - 返回的 bytes 对象长度是数据长度的两倍\n\n```\nstring(bytes对象) --\u003e 字符对应的 hex --\u003e hex 字面转化为 string(bytes对象)\n```\n\n### binascii.a2b_hex(hexstr)\n\n- binascii.a2b_hex(hexstr)\n- binascii.unhexlify(hexstr)\n\n- 接收仅包含 ASCII 字符的 Unicode 字符串\n- 也可以接收 bytes 对象\n- 返回十六进制字符串 hexstr 所表示的二进制数据\n    - 返回的是 bytes 对象\n- 该函数与b2a_hex（）的反函数\n- hexstr 必须包含偶数个十六进制数字\n    - 可以是大写或小写\n\n```\nstring --\u003e hex --\u003e bytes 对象\n```\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%81%8F%E5%87%BD%E6%95%B0":{"title":"Python偏函数","content":"\n# Python偏函数\n\n## 使用\n\n`functools`模块提供的一个功能，\n\nint('123', base=2) 可以根据base将字符串解析成对应的进制，偏函数可以用来固定函数的参数：\n\n```python\ndef int2(x, base=2):\n    return int(x, base)\n```\n\n`functools.partial`就是帮助我们创建一个偏函数的，不需要我们自己定义`int2()`，可以直接使用下面的代码创建一个新的函数`int2`：\n\n```python\n\u003e\u003e\u003e import functools\n\u003e\u003e\u003e int2 = functools.partial(int, base=2)\n\u003e\u003e\u003e int2('1000000')\n64\n\u003e\u003e\u003e int2('1010101')\n85\n```\n\n## 原理\n\n偏函数运用了闭包的特性，大体上partial的功能可以表示成下边的形式：\n\n```python\ndef partial(func, *part_args):\n    def wrapper(*extra_args):\n        args = list(part_args)\n        args.extend(extra_args)\n        return func(*args)\nreturn wrapper\n```\n\n利用闭包的特性记忆了部分参数的值。\n\n## 参考\n\n- [偏函数 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1016959663602400/1017454145929440)\n- [(1条消息) Python中partial函数的工作原理_sigma65535的博客-CSDN博客](https://blog.csdn.net/u010301542/article/details/78376279)\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92":{"title":"Python引用传递和值传递","content":"\n# Python引用传递和值传递\n\n解释器会查看对象引用（内存地址）指示的那个值的类型，**如果变量指示一个可变的值，就会按引用调用语义。如果所指示的数据的类型是不可变的，则会应用按值调用语义**。\n\n`列表 字典 集合`  \n总是会按引用传入函数，函数代码组中对变量数据结构的任何改变都会**反映到调用代码中**。\n\n`字符串 整数 元组`  \n总是会按值传入函数，函数中对变量的任何修改是这个函数私有的，**不会反映到调用代码中**。\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8":{"title":"Python网络爬虫入门","content":"# Python网络爬虫入门\n\n## 爬虫简介\n\n### 合法性\n\n- 抓取数据时现实生活中真实数据则合法\n- 抓取数据为原创数据则受版权保护\n\n### 背景调研\n\n#### 检查 robots.txt\n\n- 检查 robots.txt 可以最小化爬虫被封禁的可能\n- 发现和网络结构相关的线索\n\n##### 查看方法\n\n通过访问 http://example.webscraping.com/**robots.txt**, 得到内容:  \n\n```http\n## section 1\nUser-agent: BadCrawler  // 禁止用户代理为 BadCrawler 的爬虫爬取网站\nDisallow: /\n\n## section 2\nUser-agent: *\nDisallow: /trap       // 封禁爬取不允许链接的爬虫\nCrawl-delay: 5        // 两次请求应间隔 5 秒\n\n## section 3\nSitemap: http://example.webscraping.com/sitemap.xml\n```\n\n#### 检查网站地图\n\n- Sitemap 文件帮助爬虫定位最新的文件, 而无需爬取每一个网页\n- 网站地图提供了所以网页的链接\n- 该文件经常存在缺失, 过期或不完整的问题\n\n##### 查看方法\n\n通过访问 robots.txt 中定义的地图链接地址 http://example.webscraping.com/sitemap.xml\n\n```sh\nhttp://example.webscraping.com/places/default/view/Afghanistan-1\nhttp://example.webscraping.com/places/default/view/Aland-Islands-2\nhttp://example.webscraping.com/places/default/view/Albania-3\nhttp://example.webscraping.com/places/default/view/Algeria-4\nhttp://example.webscraping.com/places/default/view/American-Samoa-5\nhttp://example.webscraping.com/places/default/view/Andorra-6\nhttp://example.webscraping.com/places/default/view/Angola-7\nhttp://example.webscraping.com/places/default/view/Anguilla-8\nhttp://example.webscraping.com/places/default/view/Antarctica-9\nhttp://example.webscraping.com/places/default/view/Antigua-and-Barbuda-10\n......\n```\n\n#### 估算网站大小\n\n- 目标网站的大小会影响我们如何进行爬取\n\n##### 估算方法\n\n- 一个简单的方法是检查 Google 爬虫的结果, Google 很可能已经爬取过我们感兴趣的网站\n- 通过搜索的 `site` 关键词过滤域名结\n    - 在域名后添加 url 可以对结果进行过滤, 仅显示网页某些部分\n    - 可以从 http://www.google.com/advanced_search 了解参数\n\n```\nsite:example.webscraping.com       // 搜索全站\nsite:example.webscraping.com/places/default/view  // 只搜索国家页面\n```\n\n#### 识别网站所用技术\n\n使用 builtwith 模块检查网站构建的技术类型:\n\n```sh\npip install builtwish\n```\n\n用法:\n\n```python\n\u003e\u003e\u003e import builtwith\n\u003e\u003e\u003e builtwith.parse('http://example.webscraping.com')\n\n{u'javascript-frameworks': [u'jQuery', u'Modernizr', u'jQuery UI'], u'web-frameworks': [u'Web2py', u'Twitter Bootstrap'], u'programming-languages': [u'Python'], u'web-servers': [u'Nginx']}\n``` \n\n通过返回的信息, 该网站使用 python 的 web2py 框架, 还使用了一些 JavaScript 库, 因此内容可能嵌入在 HTML 中.\n\n#### 寻找网站所有者\n\n根据所有者来调整爬虫策略.\n\n##### WHOIS 查询\n\n```sh\npip install python-whois\n```\n\n用法:\n\n```python\n\u003e\u003e\u003e import whois\n\u003e\u003e\u003e print whois.whois('webscraping.com')\n\n{\n  \"updated_date\": [\n    \"2013-08-20 08:08:30\", \n    \"2013-08-20 08:08:29\"\n  ], \n  \"status\": [\n    \"clientDeleteProhibited https://icann.org/epp#clientDeleteProhibited\", \n    \"clientRenewProhibited https://icann.org/epp#clientRenewProhibited\", \n    \"clientTransferProhibited https://icann.org/epp#clientTransferProhibited\", \n    \"clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited\", \n    \"clientTransferProhibited http://www.icann.org/epp#clientTransferProhibited\", \n    \"clientUpdateProhibited http://www.icann.org/epp#clientUpdateProhibited\", \n    \"clientRenewProhibited http://www.icann.org/epp#clientRenewProhibited\", \n    \"clientDeleteProhibited http://www.icann.org/epp#clientDeleteProhibited\"\n  ], \n  \"name\": null, \n  \"dnssec\": \"unsigned\", \n  \"city\": null, \n  \"expiration_date\": \"2020-06-26 18:01:19\", \n  \"zipcode\": null, \n  \"domain_name\": \"WEBSCRAPING.COM\", \n  \"country\": \"AU\", \n  \"whois_server\": \"whois.godaddy.com\", \n  \"state\": \"Victoria\", \n  \"registrar\": \"GoDaddy.com, LLC\", \n  \"referral_url\": null, \n  \"address\": null, \n  \"name_servers\": [\n    \"NS1.WEBFACTION.COM\", \n    \"NS2.WEBFACTION.COM\", \n    \"NS3.WEBFACTION.COM\", \n    \"NS4.WEBFACTION.COM\"\n  ], \n  \"org\": null, \n  \"creation_date\": \"2004-06-26 18:01:19\", \n  \"emails\": \"abuse@godaddy.com\"\n}\n\n```\n\n### 编写第一个爬虫\n\n爬取 (srawling) 一般方式:\n- 爬取网站地图\n- 遍历每个网页的数据库 ID\n- 跟踪网页链接\n\n#### 下载网页\n\n使用 urllib2 模块下载 URL:  \n\ndownload.py:\n\n```python\n## coding=utf-8\nimport urllib2\n\n\ndef download(url, num_retries = 2):\n    print 'Downloading:', url\n    try:\n        html = urllib2.urlopen(url).read()\n    except urllib2.URLError as e:\n        print 'Download error:', e.reason\n        html = None\n    if num_retries \u003e 0:\n        if hasattr(e, 'code') and 500 \u003c= e.code \u003c 600:\n            return download(url, num_retries - 1)\n    return html\n```\n\ntest.py:\n\n```python\n## coding=utf-8\nimport download\n\nurl = raw_input(\"please type the url:\")  ## 输入url\nhtml = download.download(url)\nprint html\n```\n\n## 实际项目\n\n### 插件\n\n- requests\n    - 爬取网页\n- bs4\n    - 解析爬取的内容\n- openpyxl\n    - 导出 excel\n\n### user-agent\n\n浏览器中 F12, 网络一栏找到加载的一个 html文件. 里面有 user-agent 字段.  \n\n```python\nheaders = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0'}\n```","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8":{"title":"Python装饰器","content":"\n# Python装饰器\n\n## 简述\n\n- 装饰器是闭包的语法糖\n- 装饰器就是在目标函数\"周围\"加上附加的代码\n- 一般如插入日志、性能测试、事务处理、缓存、权限校验等场景\n- 装饰器是面向切面编程的设计思想\n\n## 简单装饰器\n\n### 目标函数\n\n```python\ndef foo():\n    print('i am foo')\n```\n\n### 额外代码\n\n打印log:\n\n```python\ndef foo():\n    print('i am foo')\n    print(\"foo is running\")\n```\n\n### 独立 log 函数\n\n```python\ndef use_logging(func):\n    print(\"%s is running\" % func.__name__)\n    func()\n\ndef foo():\n    print('i am foo')\n\nuse_logging(foo)\n```\n\n### 问题\n\n- 想要加强原函数，要修改函数调用处的代码逻辑，暴露了修改。\n\n## 改进装饰器\n\n```python\ndef use_logging(func):\n\n    def wrapper():\n        print(\"%s is running\" % func.__name__)\n        return func()   ## 把 foo 当做参数传递进来时，执行func()就相当于执行foo()\n    return wrapper\n\ndef foo():\n    print('i am foo')\n\nfoo = use_logging(foo)  ## 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper\nfoo()                   ## 执行foo()就相当于执行 wrapper()\n```\n\n### 为什么要用两层函数来表示装饰器?\n\n\u003e 因为要把增强功能和原始函数打包在一起，返回一个新的函数对象，而不是原地调用。\n\n#### 错误写法\n\n```python\ndef use_logging(func):\n    print(\"%s is running\" % func.__name__)\n    return func\n\n\ndef foo():\n    print('i an foo')\n    return 1\n\n\nfoo = use_logging(foo)\nfoo()\n```\n\n乍一看这么写和前面的代码效果一致, 但是其实很有问题:\n\n- 在 `foo = use_logging(foo)` 时就打印了`foo()`正在执行, 而实际还未执行, 逻辑错误\n- 无法实现在 `foo()` 执行后添加代码, 例如处理 `foo()` 的返回值\n\n#### 个人理解\n\n- 装饰器的外层代码起到**打包**的动作，**函数对象定义时不会执行**。\n    - 接收目标函数(不执行), 交给内层函数(打包), 返回内层函数(不执行)\n- 内层函数实现对目标函数的扩展, 并且**承担执行目标函数的功能**\n    - 内层函数的 `return func()` 时就 执行了目标函数了\n    - 因此 `wapper()` 可以在做到执行目标函数后再添加代码\n    \n    ```python\n    def wrapper():\n        print(\"%s is running\" % func.__name__)\n        func()\n        result = func()  ## 此时已经执行了目标函数\n        print(result)\n        return result\n    ```    \n    \n\n## @ 语法糖\n\n```python\ndef use_logging(func):\n\n    def wrapper():\n        print(\"%s is running\" % func.__name__)\n        return func()\n    return wrapper\n\n@use_logging\ndef foo():\n    print(\"i am foo\")\n\nfoo()\n```\n\n- 有了 @ 就可以省去 `foo = use_logging(foo)` 这一句, 直接调用 `foo()` 即可得到想要的结果\n- foo() 函数不需要做任何修改, 只需在定义的地方加上装饰器\n- 如果我们有其他的类似函数, 可以继续调用装饰器来修饰函数, 而不用重复修改函数或者增加新的封装\n\n装饰器在 Python 使用如此方便都要归因于 Python 的函数也是一个对象，能像普通的对象一样能作为参数传递给其他函数, 可以被赋值给其他变量, 可以作为返回值, 可以被定义在另外一个函数内。\n\n## 目标函数需要接受参数\n\n```python\ndef foo(name):\n    print(\"i am %s\" % name)\n```\n\n### 定义 wrapper 函数时候指定(目标函数的)参数\n\n```python\ndef wrapper(name):\n\tlogging.warn(\"%s is running\" % func.__name__)\n\treturn func(name)\nreturn wrapper\n```\n\n### 装饰器不知道目标函数到底有多少个参数时\n\n用 `*args` 来代替:\n\n```python\ndef wrapper(*args):\n\tlogging.warn(\"%s is running\" % func.__name__)\n\treturn func(*args)\nreturn wrapper\n```\n\n### 目标函数定义了一些关键字参数\n\n例如:  \n\n```python\ndef foo(name, age=None, height=None):\n    print(\"I am %s, age %s, height %s\" % (name, age, height))\n```\n\nwrapper 函数指定关键字函数:  \n\n```python\ndef wrapper(*args, **kwargs):\n\t## args是一个数组，kwargs一个字典\n\tlogging.warn(\"%s is running\" % func.__name__)\n\treturn func(*args, **kwargs)\nreturn wrapper\n```\n\n## 增强功能部分需要参数\n\n参数控制操作外层打包程序的逻辑:  \n指定日志级别\n\n```python\ndef use_logging(level):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            if level == \"warn\":\n                logging.warn(\"%s is running\" % func.__name__)\n            elif level == \"info\":\n                logging.info(\"%s is running\" % func.__name__)\n            return func(*args)\n        return wrapper\n    return decorator\n\n@use_logging(level=\"warn\")\ndef foo(name='foo'):\n    print(\"i am %s\" % name)\n\nfoo()\n```\n\n- 它实际上是对原有装饰器的一个函数封装, 并返回一个装饰器\n- 可以将它理解为一个含有参数的闭包\n- 使用 `@use_logging(level=\"warn\")` 调用的时, Python 能够发现这一层的封装, 并把参数传递到装饰器的环境中\n\n\u003e 要定义三层就是因为有三类据说需要传递，但是不能混在同一个参数列表中：\n\u003e fun指针 / fun函数的参数 / 装饰器的参数\n\n## 类装饰器\n\n使用类装饰器主要依靠类的 `__call__` 方法, 当使用 `@` 形式将装饰器附加到函数上时, 就会调用此方法\n\n```python\nclass Foo(object):\n    def __init__(self, func):\n        self._func = func\n\n    def __call__(self):\n        print ('class decorator runing')\n        self._func()\n        print ('class decorator ending')\n\n@Foo\ndef bar():\n    print ('bar')\n\nbar()\n```\n\n## 找回目标函数元信息\n\n### 装饰器抹除了目标函数的元信息\n\n原函数的元信息不见了, 比如函数的 `docstring、__name__、参数列表`:\n\n```python\n## 装饰器\ndef logged(func):\n    def with_logging(*args, **kwargs):\n        print func.__name__      ## 输出 'with_logging'\n        print func.__doc__       ## 输出 None\n        return func(*args, **kwargs)\n    return with_logging\n\n## 函数\n@logged\ndef f(x):\n   \"\"\"does some math\"\"\"\n   return x + x * x\n\nlogged(f)\n```\n\n函数 `f` 被 `with_logging` 取代了, 它的 `docstring，__name__` 就是变成了 `with_logging` 函数的信息了.\n\n### functools.wraps\n\n- wraps本身也是一个装饰器\n- 它能把原函数的元信息拷贝到装饰器里面的 `func` 函数中\n- 使得装饰器里面的 `func` 函数也有和原函数 `foo` 一样的元信息\n\n```python\nfrom functools import wraps\ndef logged(func):\n    @wraps(func)\n    def with_logging(*args, **kwargs):\n        print func.__name__      ## 输出 'f'\n        print func.__doc__       ## 输出 'does some math'\n        return func(*args, **kwargs)\n    return with_logging\n\n@logged\ndef f(x):\n   \"\"\"does some math\"\"\"\n```\n\n## 装饰器顺序\n\n一个函数还可以同时定义多个装饰器:\n\n```py\n@a\n@b\n@c\ndef f ():\n    pass\n```\n\n执行顺序:  \n\n从里到外, **最先调用最里层的装饰器**, 最后调用最外层的装饰器:\n\n```py\nf = a(b(c(f)))\n```\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/%E7%9B%AE%E6%A0%87%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"目标包含关键字","content":"\n# 目标包含关键字\n\n\u003e [cmake：target_** 中的 PUBLIC，PRIVATE，INTERFACE - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/82244559)\n\n## PRIVATE\n\n模块自己使用，其它链接本模块的外部模块不使用。\n\n## INTERFACE\n\n模块自己不使用，其它链接本模块的外部模块使用。\n多用于在模块自己的`CMakeLists.txt`文件中指定要导入该文件而引入的东西，因为模块自己不需要自己的东西，只有外部需要用。\n\n## PUBLIC\n\n都使用：PRIVATE + INTERFACE\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/%E8%AE%BE%E5%AE%9A%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF":{"title":"设定头文件搜索路径的两种思路","content":"\n# 设定头文件搜索路径的两种思路\n\n## 指向源码目录，安装时再复制\n\n```cmake\ntarget_include_directories(mymodule INTERFACE ${PROJECT_SOURCE_DIR}/mymodule)\n\ninstall(FILES mymodule.h DESTINATION ${PROJECT_BINARY_DIR}/include)\n```\n\n## 编译前复制到安装目录再指向\n\n```cmake\nfile(INSTALL ${CMAKE_CURRENT_SOURCE_DIR}/mymodule.h\n                DESTINATION ${CMAKE_INSTALL_PREFIX}/include)\n\ninclude_directories(${CMAKE_INSTALL_PREFIX}/include)\n```\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4/target_include_directories":{"title":"target_include_directories","content":"\n# target_include_directories\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/cmake%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4":{"title":"cmake常用指令","content":"\n# cmake常用指令\n\n## add_subdirectory\n\n递归的去`add_subdirectory`指定的目录执行`cmake`调用子目录下的`CMakeLists.txt`文件。\n\n\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/cmake%E9%AA%A8%E6%9E%B6":{"title":"cmake骨架","content":"\n# cmake骨架\n\n## 主模块\n\n1. 设定Cmake版本要求\n2. 设定项目名称\n3. 设定语言标准\n4. 打开源码文件，添加可执行文件\n5. 设定编译选项\n6. 添加子模块目录\n7. 设定项目安装目录\n8. 设定头文件搜索路径\n9. 设定链接器搜索路径\n10. 设定安装路径\n    1. 设定`CMAKE_INSTALL_PREFIX`环境变量\n    2. 二进制文件安装路径\n    3. 头文件安装路径\n\n## 子模块\n\n1. 添加库文件\n2. 设定对外的头文件导入路径\n    1. [[3-计算机科学/6-应用开发/0-软件语言/cmake/项目命令/target_include_directories|target_include_directories]]指定头文件搜索目录\n    2. \n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cmake/file%E5%92%8Cinstall%E7%9A%84%E5%8C%BA%E5%88%AB":{"title":"file和install的区别","content":"\n# file和install的区别\n\nfile命令是在cmake阶段起效果的，可以进行文件操作包括复制文件到指定目录。\ninstall在make install时才起效果。\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6":{"title":"取地址操作符","content":"\n# 取地址操作符\n\n\u0026操作符返回操作数的地址。\n\n把一个现有变量的地址赋值给一个指针变量：\n\n```c\nint a, *b;\n...\nb = \u0026a;\n```\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%80%BC":{"title":"变量的地址与值","content":"\n# 变量的地址与值\n\n```c\nint a;\na = 9;\n```\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024011715.png]]\n\n一个变量在申明后，存在两个属性：地址、值。\n\n变量a在左值时操作的是地址，在右值时操作的是值。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B":{"title":"变量的存储类型","content":"\n# 变量的存储类型\n\n存储类型是指变量存储的内存类型，决定了变量何时创建、何时销毁、持续时间。\n\n## 存储区域\n\n- 普通内存\n- 运行时堆栈\n- 硬件寄存器\n\n## 缺省存储类型\n\n变量缺省存储类型取决于声明位置：\n- 声明在任何代码块外：静态内存\n\t- 在程序运行前创建\n\t- 程序执行期间一直存在\n\t- 始终保持原先的值，除非中途赋值或程序结束\n- 声明在代码块内部：堆栈\n\t- 该类型为自动类型（automatic），变量是自动变量\n\t- 可以显示使用auto关键字修改该种变量\n\t- 程序执行到变量声明时才创建该变量\n\t- 程序流程离开该代码块时变量被销毁\n\t- 代码块被多次执行时，自动变量每次都会重新创建\n\n## 改变存储类型\n\n\u003e 修改变量的存储类型不代表修改变量的作用域。\n\n- static修饰自动变量：转为静态存储。\n\t- 变量生命周期为整个程序执行期间。\n\t- 函数的形参不能声明为静态，因为实参总是在准版种传递给函数，用于支持递归。\n- register修饰自动变量：转为寄存器变量，存储于寄存器而不是内存。\n\t- 编译器不一定会处理register关键字。\n\t\t- 因寄存器数量有限，编译器只会选前几个变量为寄存器变量。\n\t\t- 编译器有自己的寄存器优化策略，则会忽略该关键字。\n\t\t- 可以把函数形参声明为寄存器变量。\n\t\t- 寄存器变量的使用使得函数需要在执行前保存寄存器状态，返回时恢复寄存器状态。\n\n## 变量初始化\n\n- 静态变量的初始值记录在可执行文件中的.bss段，程序加载后保存该值得内存地址会赋值给变量，未指定初始值则为0。\n- 自动变量的存储位置在程序链接时并不确定，所以没有初始值，显式的初始化将在代码块中插入一条赋值语句。\n\t- 在声明变量时初始化与先声明后赋值的效率一样。\n\t- 每次执行到自动变量声明时都会执行初始化语句。\n\t- 运行时的初始化支持任意表达式作为初始化值。\n\t- 自动变量未初始化时值都是垃圾。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC":{"title":"左值和右值","content":"\n# 左值和右值\n\n## 区别\n\n- 左值：可以出现在赋值符号左边的值。\n\t- 必须能标识一个特定的内存位置。\n- 右值：可以出现在赋值符号右边的值。\n\n间接访问、下标引用操作符返回的是左值，其余为右值。\n\n## 示例\n\n表达式不一定不能作为左值：\n\n下标引用实际上是一个操作符，但是这里作为左值是合法的，因为它标识了一个特定的位置，可以在以后的程序中引用它。\n\n```c\nint a[30];\n...\na[b+10] = 0;\n```\n\n`*`操作符也是一样：\n\n```c\nint a, *pi;\n...\npi = \u0026a;\n*pi = 20;\n```\n\n第二行左边`*pi`是一个表达式，`pi`的值是内存中某个特定位置的地址，`*`操作符使机器指向这个位置：\n- `*pi`作为左值：指定需要修改的位置。\n- `*pi`作为右值：取出当前存储于该位置的值。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E6%8A%80%E5%B7%A7/%E6%8C%89%E9%9C%80%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0":{"title":"按需实现函数","content":"\n# 按需实现函数\n\n```c\nint func(void);\nstatic inline int FUNC(void) {\n    return func ? func() : RET_FAILURE;\n}\n```\n\n需要添加一个汇编语言编译单元(MSVC)：\n\n```c\nglobal ?func@@YAXXZ\n?func@@YAXXZ equ 0\n```\n\n或者把 `int func(void)` 改成 `extern \"C\" int func(void);`。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E6%8C%87%E9%92%88":{"title":"指针","content":"\n# 指针\n\n指针变量本身就是一个数字，不存在内建的间接访问属性。除非显示的使用[[3-计算机科学/6-应用开发/0-软件语言/cpp/间接访问操作符|间接访问操作符]]。\n\n## 未初始化和非法的指针\n\n```c\nint *a;\n...\n*a = 12;\n```\n\na本身就是一个数字：\n- a是一个自动变量，意味着未对其进行初始化前其值是垃圾。\n- a是一个静态变量，意味着未显示初始化情况下其值始终为0。\n\n## 指针的指针\n\n```c\nint a = 12;\nint *b = \u0026a;\nint **c = \u0026b;\n```\n\n## 指针表达式\n\n涉及到[[3-计算机科学/6-应用开发/0-软件语言/cpp/变量的地址与值|变量的地址与值]]。\n\n```c\nchar ch = 'a';\nchar *cp = \u0026ch;\n```\n\n初始化如下：\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024005918.png]]\n\n### ch\n\n左值：表示表达式值为'a'\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010009.png]]\n\n右值：表达式为内存的地址（而不是地址上存的值）：\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010053.png]]\n\n### \u0026ch\n\n右值：变量ch的地址，但是\u0026ch本身的存储位置不确定，可能是栈上，可能在寄存器里，所以浮空表示。\n左值：\u0026ch位置不确定，或者说该变量没有对应的地址信息，无法作为左值使用。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010125.png]]\n\n### cp\n\n右值：cp是一个指针变量，其值记录的是ch的地址。\n左值：cp自己的地址。因为该表达式没有进行间接访问，所以没有箭头。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010336.png]]\n\n### \u0026cp\n\n右值：取cp的地址值，但是取出来不确定放在哪里。\n左值：\u0026cp没有自身的地址信息，无法作为左值。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010542.png]]\n\n### \\*cp\n\n右值：进行了一次间接访问，跳转到了ch的值\n左值：进行了一次间接访问，跳转到了ch的地址\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024010720.png]]\n\n### \\*cp+1\n\n右值：表达式最终结果存储位置未知，非法右值。\n左值：取ch的地址值并+1。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024012149.png]]\n\n### \\*(cp+1)\n\n右值：指针运算结果为右值。\n左值：`*`操作符将指针运算cp+1的结果（一个常量）转为了左值。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024132113.png]]\n\n### ++cp\n\n表达式结果返回的是一个右值，同时会更新掉cp的值。先获取cp值拷贝并增加值大小，再返回。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024133848.png]]\n\n## cp++\n\n表达式结果返回的是一个右值，同时会更新掉cp的值。先返回cp值拷贝，再增加cp的值。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024134817.png]]\n\n### \\*++p\n\n间接访问操作符作用于增值后的指针拷贝：\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024135020.png]]\n\n### \\*cp++\n\n后缀++操作符优先级高于\\*操作符：\n1. ++操作符产生cp的一份拷贝\n2. ++操作符增加cp的值\n3. cp的拷贝上执行间接访问\n\n\u003e 该表达式常出现在循环体内用于一次访问数组内容。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024223350.png]]\n\n### ++\\*p\n\n首先执行间接访问，再将cp指向位置上的值增加1，表达式结果是此时该值的一个拷贝。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221024225616.png]]\n\n### (\\*cp)++\n\n与++\\*p一样。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221025004740.png]]\n\n### ++\\*++cp\n\n1. 执行++cp，返回增加后的cp的值的拷贝。\n2. 对拷贝值进行左++操作。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221025005008.png]]\n\n## ++\\*cp++\n\n1. 执行cp++，返回原cp值的拷贝值。\n2. 执行对拷贝值的间接访问，效果等同于\\*cp\n3. 对cp所指向位置的值进行左++，返回增加后的拷贝值。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221025005545.png]]\n\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E6%95%B0%E7%BB%84":{"title":"数组","content":"\n# 数组\n\n## 数组名\n\n```c\nint b[10];\n```\n\n其中：\n- b[4] 的类型是int。\n- b的类型是数组名。\n- 数组名本质是一个常量[[3-计算机科学/6-应用开发/0-软件语言/cpp/指针|指针]]，但编译器会记录相关属性，如数组元素个数等。\n- 数组名的值是一个指向首元素的指针常量。\n- 只有数组名在表达式中使用时，编译器才会为它产生一个指针常量。\n- 指针常量意味着指针的值不能改变。\n\n两种情况下数组名不用指针常量来表示：\n- 数组名作为 sizeof 操作数时：\n    - sizeof返回数组的长度，而不是指向数组的指针长度。\n- 作为 \u0026  的操作数时：\n    - 取一个数组名的地址所产生的时一个指向数组的指针，而不是一个指向某个常量值的指针。\n\n```c\nint a[10];\nint b[10];\n...\nc = \u0026a[10];\n```\n\n- `\u0026a[0]`是一个指向数组第一个元素的指针，正是数组名本身的值，等价于 `c =a;`。\n- `b = a;` 和 `a = c;` 都是非法的，无法给指针常量赋值。\n\n## 下标引用\n\n```c\narray[下标]\n```\n\n等价于：\n\n```c\n*(array + (下标) )\n```\n\n### 等价关系\n\n```c\nint array[10];\nint *ap = array + 2;\n```\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221031001323.png]]\n\n- ap：array+2、\u0026array[2]。\n- \\*ap：array[2]、\\*(array+2)。\n- ap[0]：\\*(ap+(0))、array[2]。\n- ap+6：array+8、\u0026array[8]。\n- \\*(ap+6)：\\*(array+8)、array[8]。\n- ap[6]：\\*(array+8)、array[8]。\n- \u0026ap：合法但是没有对等的涉及array的表达式，无法预测编译器会把ap放在相对于array的何处。\n- ap[-1]：\\*(array+2-1)、array[1]。\n- ap[9]：array[11]，数组越界但编译器可能无法检测到此类错误。\n- 2[array]：\\*(2+(array))，array外括号可省略并交换顺序--\u003e\\*(array+2)，合法。\n\n例如下面这段代码会输出10：\n\n```c\nint main() {\n\tint array[10] = { 0,1,2,3,4,5,6,7,8,9 };\n\tint test[5] = { 0,1,2,3,4 };\n\tint *p = array;\n\tp[16] = 10;\n\tcout \u003c\u003c test[0];\n\treturn 0;\n}\n```\n\n\u003e 在一些场景会使用该技巧，例如嵌入式开发时对boot magic address的操作。\n\n## 数组与指针的差别\n\n```c\nint a[5];\nint *b;\n```\n\na和b都有指针值，都可以进行间接访问和下标引用，但是不能随意互换使用：\n- 声明一个数组时，编译器会根据指定元素数量为其保留内存空间，再创建数组名且值是指向该段空间起始位置的常量。\n- 声明一个指针时，编译器只会为指针本身保留空间，且不会初始化指向任何现有空间。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101015317.png]]\n\n## 指针与下标的选择\n\n上面两段代码中\n\n### 指针效率更高的场景\n\n\u003e 指针的效率和下标一样或者更高。\n\n```c\nint array[10], a;\nfor (a = 0; a\u003c10; a++)\n    array[a] = 0;\n```\n\n上一段代码，编译器先取出a的值，再乘以整型的长度4，循环执行。\n\n```c\nint array[10], *ap;\nfor (ap = array; ap\u003carray+10; ap++)\n    *ap = 0;\n```\n\n上段代码中，ap指针多次加上$1*4$的值。\n\n虽然都有多次乘法，但是第二个代码中的乘法总是$1*4$，即可在编译阶段优化。\n\n### 效率一样的场景\n\n```c\na = get_value();\narray[a] = 0;\n```\n\n```c\na = get_value();\n*(array+a) = 0;\n```\n\n上面两段代码中的a每次都是不确定的值，因此指针访问也不能被优化，所以效率一样。\n\n### 更复杂的场景\n\n```c\n#define SIZE 50\nint x[SIZE];\nint y[SIZE];\nint i;\nint *p1, *p2;\n\nint main() {\n    for(i=0;i\u003cSIZE;i++)\n        x[i]=y[i];\n}\n```\n\n```c\nint x[SIZE];\nint y[SIZE];\nint i;\nint *p1, *p2;\n\nint main() {\n    register int *p1, *p2;\n    for(p1=x ,p2=y;p1\u003c\u0026x[SIZE];)\n        *p1++=*p2++;\n}\n```\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101014553.png]]\n\n第二种方式更快，因为用到了寄存器变量，并且通过消除计数器来将循环边界的范围比较值放在编译阶段进行计算。\n\n## 数组名作为函数参数\n\n实参实际上是一个指针，而不是一个数组，因为函数并不会为数组参数分配内存空间，形参只是一个指针，指向了已经在其它地方分配好的内存空间。因此函数也无法知道数组的长度，需要显示的传递一个参数告知数组长度，且 `sizeof string`的值时指向字符串首个字符的指针的长度，而不是字符串的长度。\n下面两种形式相等，但仅限于当前上下文环境。\n\n```c\nint strlen(char *string);\nint strlen(char string[]);\n```\n\n## 多维数组\n\n```c\nint array[3][6];\n```\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101171935.png]]\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101171952.png]]\n\n多维数组的第一维实际上时另一个数组。上面例子中array可以看作时一个一维数组，包含3个元素，每个元素恰好是包含6个整型元素的数组。\n\narray这个名字的值指向第一个元素的指针，所以array是一个指向包含6个整型元素的数组的指针。\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101172727.png]]\n\narray+1也是指向包含6个整型元素的数组的指针，但是指向的是array的另一行：\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101172809.png]]\n\n`*(array+1)` 是一个指向整型的指针\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101172926.png]]\n\n`*(array+1)+5`：\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101173028.png]]\n\n`*(*(array+1)+5)`：执行间接访问操作。\n\n### 下标访问\n\n```c\nint matrix[3][10];\nmatrix[1][5];\n```\n\n![[3-计算机科学/6-应用开发/0-软件语言/cpp/z-attachments/Pasted image 20221101172653.png]]\n\n### 指向数组的指针\n\n```c\nint vector[10], *vp=vector;\nint matrix[3][10], *mp=matrix;\n```\n\n语句1合法，语句2不合法。因为matrix不是一个指向整型的指针，而是一个指向整型数组的指针，与 `int *mp`中mp的类型不符，应该声明如下：\n\n```c\nint (*p)[10];\n```\n\n下标引用优先级高于间接访问，但括号提高了间接访问的优先级保证其首先被执行，所以p是一个指针；\n执行下标访问后，确定了p指向某种类型的**数组**，数组的每个元素都是int。\n\n下面的例子包含了三种常见情况：\n\n```c\nint main() {\n\tint array[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };\n\tint* p1 = \u0026array[0][0];\n\tint* p2 = array[0];\n\tint (*p3)[4] = array;\n\tcout \u003c\u003c *(p1 + 1) \u003c\u003c endl;    // 2\n\tcout \u003c\u003c *(p2 + 1) \u003c\u003c endl;    // 2\n\tcout \u003c\u003c *(*(p3 + 1)) \u003c\u003c endl; // 5\n\treturn 0;\n}\n```\n\n### 多维数组作为函数参数\n\n参数中的多维数组名，实际传递的时指向数组第一个元素的指针。\n\n可以参考一维数组的情况：\n\n```c\nvoid func1(int *vec);\nvoid func1(int vec[]);\n...\nint vector[10];\n...\nfunc1(vector);\n```\n\n```c\n\n```\n\n二维数组：\n\n```c\nvoid func2(int (*mat)[10]);\nvoid func2(int mat[][10]);\n...\nint matrix[3][10];\n...\nfunc2(matrix);\n```\n\n关键是编译器必须要能知道第二个及以后各维的长度才能对各下标求值，函数形参必须声明\u003e=2维的长度。\n第一维的长度不重要，因为计算下标值时用不到。\n\n下列声明形式不正确：\n\n```c\nvoid func2(int **mat);\n```\n\n## 指针数组\n\n```c\nint *api[10];\n```\n\n下标引用优先级高于间接访问，在上述表达式中首先执行下标引用，api时某种类型的长度为10数组。返回数组首元素，再执行间接访问后是整型。\n最终api是一个数组，元素类型是指向整型的指针。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7":{"title":"标识符的链接属性","content":"\n# 标识符的链接属性\n\n## 分类\n\n- external 外部：标识符无论声明多少次、位于几个源文件，都表示同一个实体。\n- internal 内部：标识符在同一个文件内的所有声明都表示同一个实体。\n- none 默认：该标识符的多个声明被当作独立的个体。\n\n## 标识符链接属性判别\n\n示例代码：\n\n```c\ntypedef char *a;\nint b;\nint c(int d)\n{\n\tint e;\n\tint f(int g);\n\t...\n}\n```\n\n- a\n- b external\n- c external\n- d\n- e\n- f external\n- g\n\n## 变更标识符链接属性\n\n- 对缺省链接属性为 external 的标识符使用 static 可以将其转为 internal。\n- extern 为一个标识符指定 external 链接属性。\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6":{"title":"间接访问操作符","content":"\n# 间接访问操作符\n\n通过一个指针访问它所指向的地址的过程称为间接访问/解引用指针。\n\n`*`操作符是间接访问操作符。与[[3-计算机科学/6-应用开发/0-软件语言/cpp/指针|指针]]一起使用，用于访问指针所指向的值。该操作符需要一个右值（类型是指针类型表达式），返回一个左值。\n\n多个`*`操作符具有从右向左结合的特性：\n\n```c\nint **c = \u0026b;\n```\n\n等价于：\n\n```c\nint *(*c) = \u0026b;\n```\n\n## 示例\n\n表示表达式 `*a`的类型是int。\n\n```c\nint *a;\n```\n","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/gcc%E5%8F%82%E6%95%B0":{"title":"gcc参数","content":"\n# gcc参数\n\n- -E 预处理\n- -S 将源代码或预处理后文件编译为汇编文件\n- -c 编译为目标文件\n- -o 目标输出文件\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/gcc%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6":{"title":"gcc输出文件","content":"\n# gcc输出文件\n\n- .c 源文件\n- .h 头文件\n- .i 预处理后文件\n- .s 汇编语言文件\n- .o 目标文件\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/cpp/static%E5%85%B3%E9%94%AE%E5%AD%97":{"title":"static关键字","content":"\n# static关键字\n\n## 作用\n\n- 用于函数定义或代码块外变量声明时：改变[[3-计算机科学/6-应用开发/0-软件语言/cpp/标识符的链接属性|标识符的链接属性]]。\n- 用于代码块内变量声明时：改变[[3-计算机科学/6-应用开发/0-软件语言/cpp/变量的存储类型|变量的存储类型]]。\n","lastmodified":"2023-01-23T15:37:51.754680553Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97":{"title":"双层not_exists嵌套","content":"# 双层not_exists嵌套\n\n\u003e [SQL 中的 EXISTS 到底做了什么？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20005249)\n\u003e [SQL 双层 not exist 嵌套](https://blog.csdn.net/mtawaken/article/details/6573122)  \n\n## WHERE 做了什么\n\n```sql\nSELECT Sno, Sname\nFROM Student\nWHERE Sdept = 'IS'\n```\n\n1. DBMS 会扫描 表中的每一条记录\n1. 判断后面的逻辑表达式的值是否为 True\n   - 如果为 True，则将当前这条记录放到结果集里面去\n   - 如果逻辑表达式的值为 False 则不放\n\n## 相关子查询\n\n查询每个学生超过其选修的所有课程的平均成绩的课程的课程号:   \n```sql\nSELECT Cno\nFROM SC x\nWHERE Grade \u003e=\n(\n    SELECT AVG(Grade)\n    FROM SC y\n    WHERE y.Sno = x.Sno\n)\n```\n\n1. 扫描父查询中数据来源（如 SC 表）中的每一条记录\n1. 将当前这条记录中的，在子查询中会用到的值(Grade)代入到子查询中去\n1. 执行子查询并得到结果（可以看成是返回值）\n1. 再将这个结果代入到父查询的条件中(Grade \u003e=)\n1. 判断父查询的条件表达式的值是否为 True (WHERE 起作用)\n   - 若为 True，则将当前 SC 表中的这条记录（经过 SELECT 处理）后放到结果集中去\n   - 若为 False 则不放\n\n## (NOT) EXISTS 做了什么\n\n若存在:\n1. 判断子查询得到的结果集是否是一个空集\n   - 如果不是，则返回 True\n   - 如果是，则返回 False\n若不存在:\n返回结果与上述相反\n\n### 用法\n\n- 由exists引出的子查询，其目标列表达式通常都用*，因为EXISTS的子查询只返回真值或者假值，不返回选择出来的结果\n- 子查询中必须要有依赖父查询的条件\n- 每次查询时父查询表中的一个元组对子查询所有的元组进行判定\n  - 如果为true则父查询中的这个元组允许放入结果表\n  - 否则进行父查询下一个元组的判定\n\n## WHERE 和 (NOT) EXISTS 配合\n\n1. WHERE 根据其后语句的结果决定是否将当前遍历条目加入到结果集合中\n1. EXISTS 用于检验当前条目相关数据带入自身判断后的逻辑结果\n   1. 返回的是内部查询结果集是否为空的逻辑值\n1. WHERE 接受 EXISTS 返回的逻辑值做相应操作\n\n## 关系模型\n\n```\n学生（学号，姓名，系别，年龄）\n\n课程（课程号，课程名，学时）\n\n选读（学号，课程号，成绩）\n```\n\n## 问题: 检索选读全部课程的学生姓名\n\n答案:\n```sql\nselect 学生.姓名 from 学生\nwhere not exists\n(\n    select * from 课程 where not exists\n    (\n        select * from 选读 where 学号=学生.学号 and 课程号=课程.课程号\n    )\n)\n```\n\n## 分析\n\n1. 先取 Student 表中的第一个元组，得到其 Sno 列的值。\n1. 再取 Course 表中的第一个元组，得到其 Cno 列的值。\n1. 根据 Sno 与 Cno 的值，遍历 SC 表中的所有记录（也就是选课记录）\n   - 第二个 NOT EXISTS\n   - 若对于某个 Sno 和 Cno 的值来说，在 SC 表中找不到相应的记录，则说明该 Sno 对应的学生没有选修该 Cno 对应的课程。\n1. 对于某个学生来说，若在遍历 Course 表中所有记录（也就是所有课程）后，仍找不到任何一门他/她没有选修的课程，就说明此学生选修了全部的课程。\n   - 第一个 NOT EXISTS\n1. 将此学生放入结果元组集合中。\n1. 回到 STEP1，取 Student 中的下一个元组。\n1. 将所有结果元组集合显示。\n\n第一个 NOT EXISTS 对应第四步，第二个 NOT EXISTS 对应第三步\n\n注释:\n\n```sql\nselect 学生.姓名 from 学生  --结果集1, 结果集2为空对应的学生放入结果集1\nwhere not exists\n(\n    select * from 课程  --结果集2, 课表里x同学未选过的课组成\n    where not exists\n    (\n        select * from 选读\n        where 学号=学生.学号 and 课程号=课程.课程号  --找学生x选过的课的集合\n    )\n)\n```","lastmodified":"2023-01-23T15:37:51.766680662Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%A7%94%E6%B4%BE":{"title":"委派","content":"# 委派\n\nA  委派 B 做某事，则 B 内会有 A 的实例，并调用 A 的方法。\n\n```java\n// Java program to illustrate\n// delegation\nclass RealPrinter {\n\t// the \"delegate\"\n\tvoid print()\n\t{\n\t\tSystem.out.println(\"The Delegate\");\n\t}\n}\n\nclass Printer {\n\t// the \"delegator\"\n\tRealPrinter p = new RealPrinter();\n\n\t// create the delegate\n\tvoid print()\n\t{\n\t\tp.print(); // delegation\n\t}\n}\n\npublic class Tester {\n\n\t// To the outside world it looks like Printer actually prints.\npublic static void main(String[] args)\n\t{\n\t\tPrinter printer = new Printer();\n\t\tprinter.print();\n\t}\n}\n\n```","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF":{"title":"继承","content":"# 继承\n\nB 继承自 A，则 B 能获得 A 的属性，并接管操作。\n\n```java\n// Java program to illustrate\n// Inheritance\nclass RealPrinter {\n\t// base class implements method\n\tvoid print()\n\t{\n\t\tSystem.out.println(\"Printing Data\");\n\t}\n} 3 // Printer Inheriting functionality of real printer\n\tclass Printer extends RealPrinter {\n\n\tvoid print()\n\t{\n\t\tsuper.print(); // inside calling method of parent\n\t}\n}\n\npublic class Tester {\n\n\t// To the outside world it looks like Printer actually prints.\npublic static void main(String[] args)\n\t{\n\t\tPrinter printer = new Printer();\n\t\tprinter.print();\n\t}\n}\n\n```","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9":{"title":"继承和委派的选择","content":"\n# 继承和委派的选择\n\n- 想要表达 is-a 关系，使用[[3-计算机科学/6-应用开发/1-软件方法学/编程思想/继承|继承]]。\n- 想要将类传递给已有的API，使用继承。\n- 想要增强A，但A不能再被[[3-计算机科学/6-应用开发/1-软件方法学/编程思想/继承|继承]]，使用[[3-计算机科学/6-应用开发/1-软件方法学/编程思想/委派|委派]]。\n- 想要某方法并且不想覆盖该方法，使用[[3-计算机科学/6-应用开发/1-软件方法学/编程思想/委派|委派]]。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2":{"title":"两阶段终止","content":"\n# 两阶段终止\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F":{"title":"享元模式","content":"\n# 享元模式\n\n\u003e 可以用来解决[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/保护性拷贝|保护性拷贝]]频繁创建对象开销过大的问题。\n\u003e 重用数量有限的同一类对象。\n\n英文名称：Flyweight pattern。\n\n\u003ewikipedia： A ﬂyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects\n\n## 用例\n\n### 包装类\n\n在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：\n\n```java\npublic static Long valueOf(long l) {\n    final int offset = 128;\n    if (l \u003e= -128 \u0026\u0026 l \u003c= 127) { // will cache\n        return LongCache.cache[(int)l + offset];\n    }\n    return new Long(l);\n}\n```\n\n注意：\n- Byte, Short, Long 缓存的范围都是 -128~127\n- Character 缓存的范围是 0~127\n- Integer的默认范围是 -128~127\n\t- 最小值不能变\n\t- 但最大值可以通过调整虚拟机参数`Djava.lang.Integer.IntegerCache.high`来改变\n- Boolean 缓存了 TRUE 和 FALSE\n\n### String池\n\n### BigDecimal\n\nBigDecimal\n\n### BigInteger\n\nBigInteger\n\n### 数据库连接池\n\n```java\nclass Pool {\n    // 1. 连接池大小\n    private final int poolSize;\n \n    // 2. 连接对象数组\n    private Connection[] connections;\n \n    // 3. 连接状态数组 0 表示空闲， 1 表示繁忙\n    private AtomicIntegerArray states;\n \n    // 4. 构造方法初始化\n    public Pool(int poolSize) {\n        this.poolSize = poolSize;\n        this.connections = new Connection[poolSize];\n        this.states = new AtomicIntegerArray(new int[poolSize]);\n        for (int i = 0; i \u003c poolSize; i++) {\n            connections[i] = new MockConnection(\"连接\" + (i+1));\n        }\n    }\n \n    // 5. 借连接\n    public Connection borrow() {\n    while(true) {\n            for (int i = 0; i \u003c poolSize; i++) {\n                // 获取空闲连接\n                if(states.get(i) == 0) {\n                    if (states.compareAndSet(i, 0, 1)) {\n                        log.debug(\"borrow {}\", connections[i]);\n                        return connections[i];\n                    }\n                }\n            }\n            // 如果没有空闲连接，当前线程进入等待\n            synchronized (this) {\n                try {\n                    log.debug(\"wait...\");\n                    this.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n \n    // 6. 归还连接\n    public void free(Connection conn) {\n        for (int i = 0; i \u003c poolSize; i++) {\n            if (connections[i] == conn) {\n                states.set(i, 0);\n                synchronized (this) {\n                    log.debug(\"free {}\", conn);\n                    this.notifyAll();\n                }\n                break;\n            }\n        }\n    }\n}\n \nclass MockConnection implements Connection {\n  // 实现略\n}\n```\n\n使用：\n\n```java\nPool pool = new Pool(2);\nfor (int i = 0; i \u003c 5; i++) {\n    new Thread(() -\u003e {\n        Connection conn = pool.borrow();\n        try {\n            Thread.sleep(new Random().nextInt(1000));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        pool.free(conn);\n    }).start();\n}\n```\n\ncas操作适合短时间运行的代码片段，操作数据库可能时间比较长，适合用synchronized配合wait来阻塞线程。\n\n以上实现没有考虑：\n- 连接的动态增长与收缩\n- 连接保活（可用性检测）\n- 等待超时处理\n- 分布式 hash\n\n\u003e对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现。\n\u003etomcat的连接池相对简单，可以阅读一下源码。\n\n### 简化数据库连接池\n\n使用[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/Semaphore#简化连接池|Semaphore]]。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C":{"title":"保护性暂停","content":"\n# 保护性暂停\n\n## 基本实现\n\nGuarded Suspension：用于一个[[3-计算机科学/2-计算机组成原理/线程|线程]]等待另一个线程的执行结果，只适用于产生**一个**消息的情况。\n\n- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject。\n- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）。\n- JDK 中，[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/join|join]] 的实现、Future 的实现，采用的就是此模式。\n- 因为要等待另一方的结果，因此归类到[[3-计算机科学/2-计算机组成原理/同步|同步]]模式。\n\n![[z-oblib/z2-attachments/Pasted image 20220528230352.png]]\n\n\u003e 产生结果的线程和消费结果的线程要一一对应。\n\n### 实现\n\n```java\n@Slf4j  \npublic class Test10GuardedSuspention {  \n    public static void main(String[] args) {  \n        // T1 等待 T2 下载结果  \n        GuardedObj go = new GuardedObj();  \n        new Thread(()-\u003e{  \n            log.debug(\"等待结果\");  \n            go.get();  \n            log.debug(\"下载完成\");  \n        }).start();  \n  \n        new Thread(()-\u003e{  \n            log.debug(\"开始下载\");  \n            try {  \n                go.complate(Downloader.download());  \n            } catch (IOException e) {  \n                throw new RuntimeException(e);  \n            }  \n        }).start();  \n    }  \n}  \n  \nclass GuardedObj {  \n    private Object response;  \n\n    // 获取结果，t1调用  \n    public Object get(long millis) {  \n        synchronized (this) {  \n            // 1) 记录最初时间  \n            long begin = System.currentTimeMillis();  \n            // 2) 已经经历的时间  \n            long timePassed = 0;  \n  \n            // 用循环是因为要判断是否虚假唤醒  \n            // 判断东西有没有到\n            while (response == null) {  \n                // 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  \n                long waitTime = millis-timePassed;  \n                if (waitTime\u003c=0)  \n                    break;  \n                // 等待结果  \n                try {  \n                    this.wait(waitTime);  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                }  \n                // 更新经过的时间  \n                timePassed = System.currentTimeMillis()-begin;  \n            }  \n            return response;  \n        }  \n    }  \n  \n    // 产生结果 ，t2调用\n    public void complate(Object response) {  \n        synchronized (this) {  \n            // 给成员变量赋值  \n            this.response = response;  \n            this.notify();  \n        }  \n    }  \n}  \n  \nclass Downloader {  \n    public static List\u003cString\u003e download() throws IOException {  \n        List\u003cString\u003e lines = new ArrayList\u003c\u003e();  \n        HttpURLConnection conn = (HttpURLConnection) new URL(\"https://www.baidu.com/\").openConnection();  \n        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));  \n        String line;  \n        while ((line = reader.readLine())!=null)  \n            lines.add(line);  \n        return lines;  \n    }  \n}\n```\n\n### 与join方案相比\n\n- T2完成任务后可以执行其它任务，而join方案下载器下载完成只能等待T1执行完成。\n- join必须借助全局变量传递结果，而本方案结果都是局部的。\n\n## 增强实现\n\n多任务版。\n\n### 实现\n\n![[z-oblib/z2-attachments/Pasted image 20220529142327.png]]\n\n图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员。\n如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStreamReader;  \nimport java.net.HttpURLConnection;  \nimport java.net.URL;  \nimport java.nio.charset.StandardCharsets;  \nimport java.util.*;  \n  \n@Slf4j  \npublic class Test10GuardedSuspention {  \n    public static void main(String[] args) throws InterruptedException {  \n        for (int i=0; i\u003c3; i++) {  \n            new People().start();  \n        }  \n        Thread.sleep(3000);  // 等的时间太短会导致迭代器部分并发错误  \n        for (Integer id : MailBoxes.getIds()) {  \n            log.debug(\"叫出邮递员{}\", id);  \n            new Postman(id, \"||内容\" + id).start();  \n        }  \n    }  \n}  \n  \n@Slf4j  \nclass People extends Thread {  \n    @Override  \n    public void run() {  \n        // 收件人创建邮箱  \n        GuardedObj go = MailBoxes.createGuardedObj();  \n        log.debug(\"开始收信{}\", go.getId());  \n        // 超时等待收信  \n        Object mail = go.get(5000);  \n        if (mail!=null)  \n            log.debug(\"收到了{},内容{}\", go.getId(), mail);  \n        else            log.debug(\"{}超时未收到\", go.getId());  \n    }  \n}  \n  \n@Slf4j  \nclass Postman extends Thread {  \n    private int id;  \n    private String mail;  \n  \n    public Postman(int id, String mail) {  \n        this.id = id;  \n        this.mail = mail;  \n    }  \n  \n    @Override  \n    public void run() {  \n        GuardedObj go = MailBoxes.getGuardedObj(id);  \n        log.debug(\"往{}送信，内容{}\", id, mail);  \n        go.complate(mail);  \n    }  \n}  \n  \n// 类似蜂巢快递柜  \n@Slf4j  \nclass MailBoxes {  \n    private static Map\u003cInteger, GuardedObj\u003e box = new Hashtable\u003c\u003e();  // HashTable线程安全，HashMap线程不安全  \n    private static int id = 1;  \n  \n    // 产生唯一ID  \n    private static synchronized int generateId() {  \n        return id++;  \n    }  \n  \n    public static GuardedObj createGuardedObj() {  \n        GuardedObj go = new GuardedObj(generateId());  \n        box.put(go.getId(), go);  \n        return go;  \n    }  \n    public static Set\u003cInteger\u003e getIds() {  \n        log.debug(\"{}\",box.size());  \n        return box.keySet();  \n    }  \n  \n    // 快递柜你取完快递要把格子释放出去  \n    public static GuardedObj getGuardedObj(int id) {  \n        return box.remove(id);  \n    }  \n}  \n  \nclass GuardedObj {  \n    private Object response;  \n    private int id;  \n  \n    public int getId() {  \n        return id;  \n    }  \n  \n    public GuardedObj(int id) {  \n        this.id = id;  \n    }  \n  \n    // 获取结果  \n    public Object get(long millis) {  \n        synchronized (this) {  \n            // 1) 记录最初时间  \n            long begin = System.currentTimeMillis();  \n            // 2) 已经经历的时间  \n            long timePassed = 0;  \n            // 判断是否虚假唤醒  \n            while (response == null) {  \n                // 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等  \n                long waitTime = millis-timePassed;  \n                if (waitTime\u003c=0)  \n                    break;  \n                // 等待结果  \n                try {  \n                    this.wait(waitTime);  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                }  \n                // 更新经过的时间  \n                timePassed = System.currentTimeMillis()-begin;  \n            }  \n            return response;  \n        }  \n    }  \n  \n    // 产生结果  \n    public void complate(Object response) {  \n        synchronized (this) {  \n            // 给成员变量赋值  \n            this.response = response;  \n            this.notify();  \n        }  \n    }  \n}  \n  \nclass Downloader {  \n    public static List\u003cString\u003e download() throws IOException {  \n        List\u003cString\u003e lines = new ArrayList\u003c\u003e();  \n        HttpURLConnection conn = (HttpURLConnection) new URL(\"https://www.baidu.com/\").openConnection();  \n        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));  \n        String line;  \n        while ((line = reader.readLine())!=null)  \n            lines.add(line);  \n        return lines;  \n    }  \n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F":{"title":"单例模式","content":"\n# 单例模式\n\n## 线程安全的实现\n\n### 懒汉式：\n\n[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/Balking|balking]]模式：\n\n```java\npublic final class Singleton {\n    private Singleton() {\n    }\n \n    private static Singleton INSTANCE = null;\n \n    public static synchronized Singleton getInstance() {\n        if (INSTANCE == null) {\n\t        INSTANCE = new Singleton();\n        }\n        return INSTANCE;\n    }\n}\n```\n\n### 双重校验锁\n\n\u003e由懒汉模式改进\n\n#### 存在问题版\n\n可以发现上面的实现除了第一次和第二次必须要锁，后续只要简单判断标志位即可，所以外面多加一层判断标志，防止后续不必要的锁操作：\n\n```java\npublic final class Singleton {\n    private Singleton() {\n    }\n \n    private static Singleton INSTANCE = null;\n \n    public static Singleton getInstance() {\n\t    // 首次访问会[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]，但之后的访问就没有synchronized\n        if(INSTANCE == null) {\n\t        synchronized(Singleton.class) {\n\t\t        if (INSTANCE == null) {\n\t\t            INSTANCE = new Singleton();\n\t\t        }\n\t        }\n        }\n        return INSTANCE;\n    }\n}\n```\n\n\u003e理解上来说，最外层的判断才是后加的，双重校验锁是由懒汉模式进化而来。\n\n##### 问题分析\n\n对应jvm字节码：\n\n```java\n0: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n3: ifnonnull     37\n6: ldc           #3                  // class cn/itcast/n5/Singleton\n8: dup\n9: astore_0\n10: monitorenter\n11: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n14: ifnonnull     27\n17: new           #3                  // class cn/itcast/n5/Singleton\n20: dup\n21: invokespecial #4                  // Method \"\u003cinit\u003e\":()V\n24: putstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n27: aload_0\n28: monitorexit\n29: goto          37\n32: astore_1\n33: aload_0\n34: monitorexit\n35: aload_1\n36: athrow\n37: getstatic     #2                  // Field INSTANCE:Lcn/itcast/n5/Singleton;\n40: areturn\n```\n\n- 17 表示创建对象，将对象引用入栈  // new Singleton\n- 20 表示复制一份对象引用  // 引用地址\n- 21 表示利用一个对象引用，调用构造方法 \n- 24 表示利用一个对象引用，赋值给 static INSTANCE\n也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：\n![[z-oblib/z2-attachments/Pasted image 20220531152646.png]]\n\n\n外层if在[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/synchronized|synchronized]]之外，不受保护，并且对象可能先产生地址再被初始化，导致外层if可能读到未初始化的对象：\n\n关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/monitor|monitor]] 读取INSTANCE 变量的值。\n这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例。\n对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/volatile|volatile]] 才会真正有效。\n\n#### 改进版\n\n通过volatile保证[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/可见性|可见性]]和[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/有序性|有序性]]。\n\n```java\npublic final class Singleton {\n    private Singleton() { }\n    private static volatile Singleton INSTANCE = null;\n    public static Singleton getInstance() {\n        // 实例没创建，才会进入内部的 synchronized代码块\n        if (INSTANCE == null) {            \n            synchronized (Singleton.class) { // t2\n                // 也许有其它线程已经创建实例，所以再判断一次\n                if (INSTANCE == null) { // t1\n                    INSTANCE = new Singleton();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B":{"title":"工作线程","content":"\n# 工作线程\n\n## 定义\n\n让有限的工作[[3-计算机科学/2-计算机组成原理/线程|线程]]（Worker Thread）来轮流[[3-计算机科学/2-计算机组成原理/异步|异步]]处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]，也体现了经典设计模式中的[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/享元模式|享元模式]]。\n\n例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）。\n\n注意，不同任务类型应该使用不同的线程池，这样能够避免[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/工作线程#饥饿|饥饿]]，并能提升效率。\n\n例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。\n\n## 饥饿\n\n**固定大小**线程池会有饥饿现象：\n- 两个工人是同一个线程池中的两个线程\n- 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作\n\t- 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待\n\t- 后厨做菜：没啥说的，做就是了\n- 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好\n- 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿\n\n```java\npublic class TestDeadLock {\n \n    static final List\u003cString\u003e MENU = Arrays.asList(\"地三鲜\", \"宫保鸡丁\", \"辣子鸡丁\", \"烤鸡翅\");\n    static Random RANDOM = new Random();\n    static String cooking() {\n        return MENU.get(RANDOM.nextInt(MENU.size()));\n    }\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n \n        executorService.execute(() -\u003e {\n            log.debug(\"处理点餐...\");\n            Future\u003cString\u003e f = executorService.submit(() -\u003e {\n                log.debug(\"做菜\");\n                return cooking();\n            });\n            try {\n                log.debug(\"上菜: {}\", f.get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        });\n        /*executorService.execute(() -\u003e {\n            log.debug(\"处理点餐...\");\n            Future\u003cString\u003e f = executorService.submit(() -\u003e {\n                log.debug(\"做菜\");\n                return cooking();\n            });\n            try {\n                log.debug(\"上菜: {}\", f.get());\n            } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n            }\n        });*/\n \n    }\n}\n```\n\n上述代码中一个线程池中的线程既要处理点菜上菜，又要处理做菜，导致线程数可能不够造成饥饿。\n\n解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同的任务类型，采用不同的线程池，例如：\n\n```java\npublic class TestDeadLock {\n \n    static final List\u003cString\u003e MENU = Arrays.asList(\"地三鲜\", \"宫保鸡丁\", \"辣子鸡丁\", \"烤鸡翅\");\n    static Random RANDOM = new Random();\n    static String cooking() {\n        return MENU.get(RANDOM.nextInt(MENU.size()));\n    }\n    public static void main(String[] args) {\n\t    // 分别创建两个不同功能的线程池\n\t    // 专门负责上菜点菜\n        ExecutorService waiterPool = Executors.newFixedThreadPool(1);\n        // 专门负责做菜\n        ExecutorService cookPool = Executors.newFixedThreadPool(1);\n \n        waiterPool.execute(() -\u003e {\n            log.debug(\"处理点餐...\");\n            // 做菜交给专门的厨师去做\n            Future\u003cString\u003e f = cookPool.submit(() -\u003e {\n                log.debug(\"做菜\");\n                return cooking();\n            });\n            try {\n                log.debug(\"上菜: {}\", f.get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        });\n        waiterPool.execute(() -\u003e {\n            log.debug(\"处理点餐...\");\n            Future\u003cString\u003e f = cookPool.submit(() -\u003e {\n                log.debug(\"做菜\");\n                return cooking();\n            });\n            try {\n\t            log.debug(\"上菜: {}\", f.get());\n            } catch (InterruptedException | ExecutionException e) {\n                e.printStackTrace();\n            }\n        });\n \n \n    }\n}\n```\n\n## 创建多少线程池合适\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿。\n- 过大会导致更多的线程上下文切换，占用更多内存。\n\n### CPU密集型\n\n通常采用 cpu 核数 **+ 1** 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费。\n\n### IO密集型\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。\n\n经验公式如下\n线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间\n例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式\n\n4 * 100% * (100% / 50%) = 8\n\n例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式\n\n4 * 100% * (100% / 10%) = 40\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F":{"title":"工厂模式","content":"\n# 工厂模式\n\n## 作用\n\n把对象的创建和使用过程分割开来：\n将对象实例化的动作解耦到一个工厂中，后续要修改或添加其它实例，只需要修改工厂方法。\n\n例如：\n\n如果对类A的功能进行修改，衍生出子类B继承自原始类A，则需要在所有实例化A的地方修改实例化代码。\n\n而有工厂方法后，只需要修改工厂中的事件，将原来`return new A()` 改为 `return new B()`即可。\n\n### 普通工厂\n\n```java\ninterface fruit{\n    public abstract void eat();\n} \nclass Apple implements fruit{\n     public void eat(){\n         System.out.println(\"Apple\");\n     }\n} \nclass Orange implements fruit{\n     public void eat(){\n         System.out.println(\"Orange\");\n     }\n}\n//构造工厂类\n//也就是说以后如果我们在添加其他的实例的时候\n//只需要修改工厂类就行了\nclass Factory{\n     public static fruit getInstance(String fruitName){\n         fruit f=null;\n         if(\"Apple\".equals(fruitName)){\n             f=new Apple();\n         }\n         if(\"Orange\".equals(fruitName)){\n             f=new Orange();\n         }\n         return f;\n     }\n}\nclass hello{\n     public static void main(String[] a){\n         fruit f=Factory.getInstance(\"Orange\");\n         f.eat();\n     }\n}\n```\n\n## 缺点\n\n每添加一次子类，就需要修改一次工厂类，如果子类过多，工厂类会十分繁杂，不利于维护。\n\n## 借助JAVA反射优化\n\n\u003e据给出的类名（字符串方式）来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。\n\n通过统一的反射方法生成对象，而不是通过代码写死。使用时只需要传入对应的类路径，反射会帮我们生成对象。\n\n### 结合反射模拟实现Spring的IOC\n\n```java\ninterface fruit{\n    public abstract void eat();\n}\nclass Apple implements fruit{\n    public void eat(){\n        System.out.println(\"Apple\");\n    }\n}\nclass Orange implements fruit{\n    public void eat(){\n        System.out.println(\"Orange\");\n    }\n}\n//操作属性文件类\nclass init{\n    public static Properties getPro() throws Exception{\n        Properties pro=new Properties();\n        File f=new File(\"fruit.properties\");\n        if(f.exists()){\n            pro.load(new FileInputStream(f));\n        }else{\n            pro.setProperty(\"apple\", \"Reflect.Apple\");\n            pro.setProperty(\"orange\", \"Reflect.Orange\");\n            pro.store(new FileOutputStream(f), \"FRUIT CLASS\");\n        }\n        return pro;\n    }\n}\nclass Factory{\n    public static fruit getInstance(String ClassName){\n        fruit f=null;\n        try{\n            f=(fruit)Class.forName(ClassName).newInstance();\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\nclass hello{\n    public static void main(String[] a) throws Exception{\n        Properties pro=init.getPro();\n        fruit f=Factory.getInstance(pro.getProperty(\"apple\"));\n        if(f!=null){\n            f.eat();\n        }\n    }\n}\n```\n\n### 总结\n\n由代码写死 --\u003e 动态改变 （动态是指对象的生成由字符串输入决定，而非代码写死）。\n\n把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F":{"title":"模板模式","content":"\n# 模板模式\n\n在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n\n**意图：** 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n**主要解决：** 一些方法通用，却在每一个子类都重新写了这一方法。\n\n**何时使用：** 有一些通用的方法。\n\n**如何解决：** 将这些通用算法抽象出来。\n\n**关键代码：** 在抽象类实现，其他步骤在子类实现。\n\n**应用实例：** 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n\n**优点：** 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n**缺点：** 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n**使用场景：** 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n\n**注意事项：** 为防止恶意操作，一般模板方法都加上 final 关键词。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85":{"title":"生产者消费者","content":"\n# 生产者消费者\n\n- 与[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/保护性暂停|保护性暂停]]中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应。\n- 消息队列是一种异步的模式，消息生产出来不一定被立刻消费。\n- 消费队列可以用来平衡生产和消费的线程资源。\n- 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据。\n- 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据。\n- JDK 中各种[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/阻塞队列|阻塞队列]]，采用的就是这种模式。\n\n![[z-oblib/z2-attachments/Pasted image 20220529162239.png]]\n\n## 实现\n\n```java\npackage test;  \n  \nimport lombok.extern.slf4j.Slf4j;  \n  \nimport java.util.LinkedList;  \n  \n@Slf4j  \npublic class Test11MessageQueue {  \n    public static void main(String[] args) {  \n        MessageQueue queue = new MessageQueue(2);  \n        for (int i=0; i\u003c99999; i++) {  \n            int id = i;  \n            new Thread(()-\u003e{  \n                queue.put(new Message(id, \"内容\"+id));  \n            }, \"生产者\"+i).start();  \n        }  \n  \n        new Thread(()-\u003e{  \n            try {  \n                Thread.sleep(1000);  \n            } catch (InterruptedException e) {  \n                throw new RuntimeException(e);  \n            }  \n            while (true) {  \n                queue.take();  \n            }  \n        }, \"消费者\").start();  \n    }  \n}  \n  \n@Slf4j  \nclass MessageQueue {  \n    private LinkedList\u003cMessage\u003e list = new LinkedList\u003c\u003e();  \n    private int capacity;  \n  \n    public MessageQueue(int capacity) {  \n        this.capacity = capacity;  \n    }  \n  \n    // 消费  \n    public Message take() {  \n        synchronized (list) {  \n            while(list.isEmpty()){  \n                try {  \n                    log.debug(\"队列空\");  \n                    list.wait();  \n                } catch (InterruptedException e) {  \n                    throw new RuntimeException(e);  \n                }  \n            }  \n            Message message = list.removeFirst();  \n            log.debug(\"已消费{}\", message);  \n            list.notify();  \n            return message;  \n        }  \n    }  \n  \n    // 生产  \n    public void put(Message message) {  \n        synchronized (list) {  \n            while (list.size()==capacity) {  \n                try {  \n                    log.debug(\"队列满\");  \n                    list.wait();  \n                } catch (InterruptedException e) {  \n                    throw new RuntimeException(e);  \n                }  \n            }  \n            list.addLast(message);  \n            log.debug(\"已生产{}\", message);  \n            list.notifyAll();  \n        }  \n    }  \n}  \n  \n@Slf4j  \nfinal class Message {  \n    private int id;  \n    private Object value;  \n  \n    public int getId() {  \n        return id;  \n    }  \n  \n    public Object getValue() {  \n        return value;  \n    }  \n  \n    public Message(int id, Object value) {  \n        this.id = id;  \n        this.value = value;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"Message{\" +  \n                \"id=\" + id +  \n                \", value=\" + value +  \n                '}';  \n    }  \n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F":{"title":"装饰器模式","content":"\n# 装饰器模式\n\n对现有类不改动结构的情况下为类添加新职责和功能的模式。\n\n## 使用场景\n\n- 需要大量的子类为某一个对象进行职责增强的时候，可以使用装饰器模式\n- 希望使用继承对于类进行动态扩展的时候，可以考虑使用装饰器模式\n\n## 动机\n\n一般有两种方式可以实现给一个类或对象增加行为：\n\n- 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n- 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)\n\n装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n## 角色\n\n- **Component**：抽象组件，装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为，可以给这些对象动态添加职责\n- **ConcreteComponent**：具体的组件对象，实现类 ，即被装饰者，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责\n- **Decorator**：所有装饰器的抽象父类，一般是抽象类，实现接口；它的属性必然有个指向 Conponent 抽象组件的对象 ，其实就是持有一个被装饰的对象\n- **ConcreteDecorator**：具体的装饰对象，实现具体要被装饰对象添加的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。\n\n![[z-oblib/z2-attachments/3ec6aa3545c9b5ab14fac788a400a4e9.webp]]\n\n装饰者和被装饰者对象有相同的父类，因为装饰者和被装饰者必须是一样的类型，**这里利用继承是为了达到类型匹配，而不是利用继承获得行为**。\n\n利用继承设计子类，只能在编译时静态决定，并且所有子类都会继承相同的行为；利用组合的做法扩展对象，就可以在运行时动态的进行扩展。装饰者模式遵循开放-关闭原则：类应该对扩展开放，对修改关闭。利用装饰者，我们可以实现新的装饰者增加新的行为而不用修改现有代码，而如果单纯依赖继承，每当需要新行为时，还得修改现有的代码。\n\n## 实例\n\n卖煎饼：\n\n![[z-oblib/z2-attachments/Pasted image 20220610170159.png]]\n\n### 抽象组件\n\n```java\npublic abstract class Pancake {\n\n    String description = \"普通煎饼\";\n\n    public String getDescription(){\n\n        return description;\n\n    }\n\n    public abstract double cost();\n\n}\n```\n\n### 具体组件\n\n定义具体的被装饰者，这里是煎饼果子，当然还可以有鸡蛋灌饼、手抓饼等其他被装饰者：\n\n```java\npublic class Battercake extends Pancake {\n    @Override\n    public double cost() {\n        return 8;\n    }\n\n    public Battercake(){\n        description = \"煎饼果子\";\n    }\n}\n```\n\n### 抽象装饰器\n\n定义一个调料抽象类：\n\n```java\npublic abstract class CondimentDecorator extends Pancake {\n\n    // 持有组件对象\n    protected Pancake pancake;\n    public CondimentDecorator(Pancake pancake){\n        this.pancake = pancake;\n    }\n\n    public abstract String getDescription();\n}\n```\n\n### 具体装饰器\n\n具体的装饰者，我们定义一个鸡蛋装饰器，一个火腿装饰器：\n\n```java\npublic class Egg extends CondimentDecorator {\n    public Egg(Pancake pancake){\n        super(pancake);\n    }\n\n\t// 原有方法做向外扩展，不修改原有方法\n    @Override\n    public String getDescription() {\n        return pancake.getDescription() + \"加鸡蛋\";\n    }\n\n    @Override\n    public double cost() {\n        return pancake.cost() + 1;\n    }\n}\n```\n\n```java\npublic class Sausage extends CondimentDecorator{\n    public Sausage(Pancake pancake){\n        super(pancake);\n    }\n    @Override\n    public String getDescription() {\n        return pancake.getDescription() + \"加火腿\";\n    }\n\n    @Override\n    public double cost() {\n        return pancake.cost() + 2;\n    }\n}\n```\n\n### 测试\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        //买一个普通的煎饼果子\n        Pancake battercake = new Battercake();\n        System.out.println(battercake.getDescription() + \"花费：\"+battercake.cost() + \"元\");\n\n        //买一个加双蛋的煎饼果子\n        Pancake doubleEgg = new Battercake();\n        doubleEgg = new Egg(doubleEgg);\n        doubleEgg = new Egg(doubleEgg);\n        System.out.println(doubleEgg.getDescription() + \"花费\" + doubleEgg.cost() + \"元\");\n\n        //加火腿和鸡蛋\n        Pancake battercakePlus = new Battercake();\n        battercakePlus = new Egg(battercakePlus);\n        battercakePlus = new Sausage(battercakePlus);\n        System.out.println(battercakePlus.getDescription() + \"花费\" + battercakePlus.cost() + \"元\");\n    }\n}\n```\n\n```\n煎饼果子花费：8.0元\n煎饼果子加鸡蛋加鸡蛋花费10.0元\n煎饼果子加鸡蛋加火腿花费11.0元\n```\n\n## 优点\n\n- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。\n- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。\n- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。\n- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/开闭原则|开闭原则]]”\n\n## 缺点\n\n- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。\n- 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93":{"title":"设计模式总结","content":"\n# 设计模式总结\n\n## 模式\n\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/装饰器模式|装饰器模式]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/两阶段终止|两阶段终止]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/模板模式|模板模式]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/单例模式|单例模式]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/工厂模式|工厂模式]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/享元模式|享元模式]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/保护性暂停|保护性暂停]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/生产者消费者|生产者消费者]]\n\n## 工具\n\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/Balking|Balking]]\n- [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/工作线程|工作线程]]\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Balking":{"title":"Balking","content":"\n# Balking\n\nBalking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。\n\n## 实现\n\n### 单线程情况\n\n通过变量记录某个方法是否已经执行过，保证方法只能执行一次。\n例如监控器前程只需要一个，不需要重复start()新的线程。\n\n```java\nclass SystemMonitor {\n\tprivate boolean starting = false;\n\tpublic void start() {\n\t\t// 防止重复启动\n\t\tif(starting) {\n\t\t\treturn;\n\t\t}\n\t\tstarting = true;\n\t\tmonitorThread = new Thread(()-\u003e{...;});\n\t\tmonitorThread.start();\n\t}\n}\n```\n\n### 多线程情况\n\nstarting的判断和赋值分成了两步，所以没有保证原子性，多线程访问会出问题，需要加锁：\n\n```java\nclass SystemMonitor {\n\tprivate boolean starting = false;\n\tpublic void start() {\n\t\t// 加锁防止多线程破坏原子性\n\t\tsynchronized(this) {\n\t\t\tif(starting) {\n\t\t\t\treturn;\n\t\t\t}\n\t\tstarting = true;\n\t\t}\n\t\tmonitorThread = new Thread(()-\u003e{...;});\n\t\tmonitorThread.start();\n\t}\n}\n```\n\n## 应用\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Linux%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%AA%A8%E6%9E%B6":{"title":"收包","content":"\n# 收包\n\n1. 初始化socket\n2. 设置socket参数\n    1. 接收超时时间\n3. 通过网卡名获取网卡index\n4. 通过网卡index将socket与网卡绑定\n5. 设置网卡为混杂模式\n6. 循环接收数据包\n\n# 发包\n\n1. 初始化socket\n2. 设置socket参数\n    1. `SO_DONTROUTE` 让消息直发网卡，不路由\n3. 通过网卡名获取网卡index\n4. 通过网卡index将socket与网卡绑定\n5. 构建待发送数据包\n    1. 数据链路层\n    2. 网络层\n    3. 传输层\n        1. TCP\n        2. UDP\n    4. 应用层\n6. 通过write向raw socket写入\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%9E%84%E5%BB%BARPC/%E6%9E%84%E5%BB%BARPC%E6%80%9D%E8%B7%AF":{"title":"构建RPC思路","content":"\n# 构建RPC思路\n\n## 问题\n\n1. 客户端如何知道服务端地址\n2. 客户端如何知道有哪些服务\n3. 客户端如何向服务端传递参数\n4. 数据如何编解码\n5. 服务端如何验证客户端和请求合法\n6. 服务端如何将执行结果返回给客户端\n\t1. 客户端如何等待结果\n7. 服务端如何同时处理多个请求\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Netty/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81":{"title":"Netty优化与源码","content":"\n# Netty优化与源码\n\n## 1. 优化\n\n### 1.1 扩展序列化算法\n\n序列化，反序列化主要用在消息正文的转换上\n\n* 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，**最终都需要变成 byte[]**）\n* 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\n\n目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\n\n```java\n// 反序列化\nbyte[] body = new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message = (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n// 序列化\nByteArrayOutputStream out = new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes = out.toByteArray();\n```\n\n为了支持更多序列化算法，抽象一个 Serializer 接口\n\n```java\npublic interface Serializer {\n\n    // 反序列化方法\n    \u003cT\u003e T deserialize(Class\u003cT\u003e clazz, byte[] bytes);\n\n    // 序列化方法\n    \u003cT\u003e byte[] serialize(T object);\n\n}\n```\n\n提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\n\n```java\nenum SerializerAlgorithm implements Serializer {\n\t// Java 实现\n    Java {\n        @Override\n        public \u003cT\u003e T deserialize(Class\u003cT\u003e clazz, byte[] bytes) {\n            try {\n                ObjectInputStream in = \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object = in.readObject();\n                return (T) object;\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 反序列化错误\", e);\n            }\n        }\n\n        @Override\n        public \u003cT\u003e byte[] serialize(T object) {\n            try {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            } catch (IOException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 序列化错误\", e);\n            }\n        }\n    }, \n    // Json 实现(引入了 Gson 依赖)\n    Json {\n        @Override\n        public \u003cT\u003e T deserialize(Class\u003cT\u003e clazz, byte[] bytes) {\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);\n        }\n\n        @Override\n        public \u003cT\u003e byte[] serialize(T object) {\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);\n        }\n    };\n\n    // 需要从协议的字节中得到是哪种序列化算法\n    public static SerializerAlgorithm getByInt(int type) {\n        SerializerAlgorithm[] array = SerializerAlgorithm.values();\n        if (type \u003c 0 || type \u003e array.length - 1) {\n            throw new IllegalArgumentException(\"超过 SerializerAlgorithm 范围\");\n        }\n        return array[type];\n    }\n}\n```\n\n增加配置类和配置文件\n\n```java\npublic abstract class Config {\n    static Properties properties;\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n        } catch (IOException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    public static int getServerPort() {\n        String value = properties.getProperty(\"server.port\");\n        if(value == null) {\n            return 8080;\n        } else {\n            return Integer.parseInt(value);\n        }\n    }\n    public static Serializer.Algorithm getSerializerAlgorithm() {\n        String value = properties.getProperty(\"serializer.algorithm\");\n        if(value == null) {\n            return Serializer.Algorithm.Java;\n        } else {\n            return Serializer.Algorithm.valueOf(value);\n        }\n    }\n}\n```\n\n配置文件\n\n```properties\nserializer.algorithm=Json\n```\n\n修改编解码器\n\n```java\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec\u003cByteBuf, Message\u003e {\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List\u003cObject\u003e outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerAlgorithm = in.readByte(); // 0 或 1\n        byte messageType = in.readByte(); // 0,1,2...\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n\n        // 找到反序列化算法\n        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];\n        // 确定具体消息类型\n        Class\u003c? extends Message\u003e messageClass = Message.getMessageClass(messageType);\n        Message message = algorithm.deserialize(messageClass, bytes);\n//        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n//        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n其中确定具体消息类型，可以根据 `消息类型字节` 获取到对应的 `消息 class`\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    /**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     */\n    public static Class\u003c? extends Message\u003e getMessageClass(int messageType) {\n        return messageClasses.get(messageType);\n    }\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage = 0;\n    public static final int LoginResponseMessage = 1;\n    public static final int ChatRequestMessage = 2;\n    public static final int ChatResponseMessage = 3;\n    public static final int GroupCreateRequestMessage = 4;\n    public static final int GroupCreateResponseMessage = 5;\n    public static final int GroupJoinRequestMessage = 6;\n    public static final int GroupJoinResponseMessage = 7;\n    public static final int GroupQuitRequestMessage = 8;\n    public static final int GroupQuitResponseMessage = 9;\n    public static final int GroupChatRequestMessage = 10;\n    public static final int GroupChatResponseMessage = 11;\n    public static final int GroupMembersRequestMessage = 12;\n    public static final int GroupMembersResponseMessage = 13;\n    public static final int PingMessage = 14;\n    public static final int PongMessage = 15;\n    private static final Map\u003cInteger, Class\u003c? extends Message\u003e\u003e messageClasses = new HashMap\u003c\u003e();\n\n    static {\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    }\n}\n```\n\n### 1.2 参数调优\n\n客户端直接调用 Bootstrap().option(xxx)\n服务器端：\nServerBootstrap().option(xxx)是给ServerSocketChannel配置参数\nServerBootstrap().childOption(xxx)是给SocketChannel配置参数\n\n#### 1）CONNECT_TIMEOUT_MILLIS\n\n* 属于 SocketChannal 参数\n* 用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\n\n* SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\n\n```java\n@Slf4j\npublic class TestConnectionTimeout {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    // 配置参数\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future = bootstrap.connect(\"127.0.0.1\", 8080);\n            future.sync().channel().closeFuture().sync(); // 断点1\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.debug(\"timeout\");\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n另外源码部分 `io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect`\n\n```java\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    // Schedule connect timeout.\n    int connectTimeoutMillis = config().getConnectTimeoutMillis();\n    if (connectTimeoutMillis \u003e 0) {\n        connectTimeoutFuture = eventLoop().schedule(new Runnable() {\n            @Override\n            public void run() {                \n                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause =\n                    new ConnectTimeoutException(\"connection timed out: \" + remoteAddress); // 断点2\n                if (connectPromise != null \u0026\u0026 connectPromise.tryFailure(cause)) {\n                    close(voidPromise());\n                }\n            }\n        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\t// ...\n}\n```\n\n#### 2）SO_BACKLOG\n\n* 属于 ServerSocketChannal 参数\n\n三次握手的过程：\n\n```mermaid\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as syns queue\nparticipant aq as accept queue\n\ns -\u003e\u003e s : bind()\ns -\u003e\u003e s : listen()\nc -\u003e\u003e c : connect()\nc -\u003e\u003e s : 1. SYN\nNote left of c : SYN_SEND\ns -\u003e\u003e sq : put\nNote right of s : SYN_RCVD\ns -\u003e\u003e c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc -\u003e\u003e s : 3. ACK\nsq -\u003e\u003e aq : put\nNote right of s : ESTABLISHED\naq --\u003e\u003e s : \ns -\u003e\u003e s : accept()\n```\n\n\u003e sync queue：半连接队列：还未完成三次握手的连接放入\n\u003e accept queue：全连接队列：完成三次握手的连接放入\n\n\u003e 服务器先放入accept queue的原因是：服务器处理accept()的能力有限，如果大量客户端连接可能造成负载过高，所以先放入队列。\n\u003e 三次握手发生在accept()之前。\n\n1. 第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\n2. 第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\n3. 第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\n\n其中\n\n* 在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\n\n* sync queue - 半连接队列\n  * 大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 `syncookies` 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n* accept queue - 全连接队列\n  * 其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取**二者的较小值**\n  * **如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client**\n\n\n\nnetty 中\n\n可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置全连接队列大小\n\n可以通过下面源码查看默认大小\n\n```java\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig {\n\n    private volatile int backlog = NetUtil.SOMAXCONN;\n    // ...\n}\n```\n\n课堂调试关键断点为：`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n\n\noio 中更容易说明，不用 debug 模式\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888, 2);\n        Socket accept = ss.accept();\n        System.out.println(accept);\n        System.in.read();\n    }\n}\n```\n\n客户端启动 4 个\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        try {\n            Socket s = new Socket();\n            System.out.println(new Date()+\" connecting...\");\n            s.connect(new InetSocketAddress(\"localhost\", 8888),1000);\n            System.out.println(new Date()+\" connected...\");\n            s.getOutputStream().write(1);\n            System.in.read();\n        } catch (IOException e) {\n            System.out.println(new Date()+\" connecting timeout...\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\n\n```java\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...\n```\n\n第 4 个客户端连接时\n\n```\nTue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out\n```\n\n#### 3）ulimit -n\n\n* 属于操作系统参数\n\n限制进程能同时打开的文件描述符数量。\n\n\u003e Linux 的普通文件和socket都是用文件描述符来代表。\n\u003e 属于系统的临时调整，建议放在启动脚本。\n\n#### 4）TCP_NODELAY\n\n* 属于 SocketChannal 参数，需要childOption设置。\n\n\u003e 默认值是false，代表开启nagle算法。\n\u003e 设为true关闭nagle算法。\n\n#### 5）SO_SNDBUF \u0026 SO_RCVBUF\n\n* SO_SNDBUF 属于 SocketChannal 参数\n* SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n\n\u003e 不建议调整该参数，操作系统拥塞控制会自动调整。\n\n#### 6）ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 用来分配 ByteBuf， ctx.alloc()\n* 控制分配出来的ByteBuf是池化/非池化，直接内存/堆内存\n\t* 默认是池化 直接内存\n\n\u003e 调用ctx.alloc()拿到的就是该分配器对象。\n\n#### 7）RCVBUF_ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 控制 netty **接收**缓冲区大小\n* 负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），**统一采用 direct 直接内存**，具体池化还是非池化由 allocator 决定\n\n\u003e ALLOCATOR 和 RCVBUF_ALLOCATOR 共同协作完成ByteBuf的初始分配。\n\n### 1.3 RPC 框架\n\n#### 1）准备工作\n\n这些代码可以认为是现成的，无需从头编写练习\n\n为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    // 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;\n\n    static {\n        // ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    }\n\n}\n```\n\n请求消息\n\n```java\n@Getter\n@ToString(callSuper = true)\npublic class RpcRequestMessage extends Message {\n\n    /**\n     * 调用的接口全限定名，服务端根据它找到实现\n     */\n    private String interfaceName;\n    /**\n     * 调用接口中的方法名\n     */\n    private String methodName;\n    /**\n     * 方法返回类型\n     */\n    private Class\u003c?\u003e returnType;\n    /**\n     * 方法参数类型数组\n     */\n    private Class[] parameterTypes;\n    /**\n     * 方法参数值数组\n     */\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class\u003c?\u003e returnType, Class[] parameterTypes, Object[] parameterValue) {\n        super.setSequenceId(sequenceId);\n        this.interfaceName = interfaceName;\n        this.methodName = methodName;\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.parameterValue = parameterValue;\n    }\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_REQUEST;\n    }\n}\n```\n\n响应消息\n\n```java\n@Data\n@ToString(callSuper = true)\npublic class RpcResponseMessage extends Message {\n    /**\n     * 返回值\n     */\n    private Object returnValue;\n    /**\n     * 异常值\n     */\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    }\n}\n```\n\n服务器架子\n\n```java\n@Slf4j\npublic class RpcServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端架子\n\n```java\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的 service 获取\n\n```java\npublic class ServicesFactory {\n\n    static Properties properties;\n    static Map\u003cClass\u003c?\u003e, Object\u003e map = new ConcurrentHashMap\u003c\u003e();\n\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n            Set\u003cString\u003e names = properties.stringPropertyNames();\n            for (String name : names) {\n                if (name.endsWith(\"Service\")) {\n                    Class\u003c?\u003e interfaceClass = Class.forName(name);\n                    Class\u003c?\u003e instanceClass = Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                }\n            }\n        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    public static \u003cT\u003e T getService(Class\u003cT\u003e interfaceClass) {\n        return (T) map.get(interfaceClass);\n    }\n}\n```\n\n相关配置 application.properties\n\n```\nserializer.algorithm=Json\ncn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl\n```\n\n#### 2）服务器 handler\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler\u003cRpcRequestMessage\u003e {\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) {\n        RpcResponseMessage response = new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());\n        try {\n            // 获取真正的实现对象\n            HelloService service = (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            // 获取要调用的方法\n            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            // 调用方法\n            Object invoke = method.invoke(service, message.getParameterValue());\n            // 调用成功\n            response.setReturnValue(invoke);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 调用异常\n            response.setExceptionValue(e);\n        }\n        // 返回结果\n        ctx.writeAndFlush(response);\n    }\n}\n```\n\n#### 3）客户端代码第一版\n\n只发消息\n\n```java\n@Slf4j\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n\n            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    \"cn.itcast.server.service.HelloService\",\n                    \"sayHello\",\n                    String.class,\n                    new Class[]{String.class},\n                    new Object[]{\"张三\"}\n            )).addListener(promise -\u003e {\n                if (!promise.isSuccess()) {\n                    Throwable cause = promise.cause();\n                    log.error(\"error\", cause);\n                }\n            });\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n#### 4）客户端 handler 第一版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler\u003cRpcResponseMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n    }\n}\n```\n\n#### 5）客户端代码 第二版\n\n包括 channel 管理，代理，接收结果\n\n```java\n@Slf4j\npublic class RpcClientManager {\n\n\n    public static void main(String[] args) {\n        HelloService service = getProxyService(HelloService.class);\n        System.out.println(service.sayHello(\"zhangsan\"));\n//        System.out.println(service.sayHello(\"lisi\"));\n//        System.out.println(service.sayHello(\"wangwu\"));\n    }\n\n    // 创建代理类\n    public static \u003cT\u003e T getProxyService(Class\u003cT\u003e serviceClass) {\n        ClassLoader loader = serviceClass.getClassLoader();\n        Class\u003c?\u003e[] interfaces = new Class[]{serviceClass};\n        //                                                            sayHello  \"张三\"\n        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -\u003e {\n            // 1. 将方法调用转换为 消息对象\n            int sequenceId = SequenceIdGenerator.nextId();\n            RpcRequestMessage msg = new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            // 2. 将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程\n            DefaultPromise\u003cObject\u003e promise = new DefaultPromise\u003c\u003e(getChannel().eventLoop());\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n//            promise.addListener(future -\u003e {\n//                // 线程\n//            });\n\n            // 4. 等待 promise 结果\n            promise.await();\n            if(promise.isSuccess()) {\n                // 调用正常\n                return promise.getNow();\n            } else {\n                // 调用失败\n                throw new RuntimeException(promise.cause());\n            }\n        });\n        return (T) o;\n    }\n\n    private static Channel channel = null;\n    private static final Object LOCK = new Object();\n\n    // 获取唯一的 channel 对象\n    public static Channel getChannel() {\n        if (channel != null) {\n            return channel;\n        }\n        synchronized (LOCK) { //  t2\n            if (channel != null) { // t1\n                return channel;\n            }\n            initChannel();\n            return channel;\n        }\n    }\n\n    // 初始化 channel 方法\n    private static void initChannel() {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            }\n        });\n        try {\n            channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().addListener(future -\u003e {\n                group.shutdownGracefully();\n            });\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        }\n    }\n}\n```\n\n#### 6）客户端 handler 第二版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler\u003cRpcResponseMessage\u003e {\n\n    //                       序号      用来接收结果的 promise 对象\n    public static final Map\u003cInteger, Promise\u003cObject\u003e\u003e PROMISES = new ConcurrentHashMap\u003c\u003e();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n        // 拿到空的 promise\n        Promise\u003cObject\u003e promise = PROMISES.remove(msg.getSequenceId());\n        if (promise != null) {\n            Object returnValue = msg.getReturnValue();\n            Exception exceptionValue = msg.getExceptionValue();\n            if(exceptionValue != null) {\n                promise.setFailure(exceptionValue);\n            } else {\n                promise.setSuccess(returnValue);\n            }\n        }\n    }\n}\n```\n\n![[z-oblib/z2-attachments/Pasted image 20220624192123.png]]\n\n## 2. 源码分析\n\n### 2.1 启动剖析\n\n主要步骤：\n1. 打开select\n2. 打开ssc\n3. channel绑定到select上\n4. 通过selectionKey关注accept事件\n\n![[z-oblib/z2-attachments/Pasted image 20220624213014.png]]\n\n我们就来看看 netty 中对下面的代码是怎样进行处理的\n\n```java\n//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector = Selector.open(); \n\n//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment = new NioServerSocketChannel();\n\n//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n//4 启动 nio boss 线程执行接下来的操作\n\n//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);\n\n//6 head -\u003e 初始化器 -\u003e ServerBootstrapAcceptor -\u003e tail，初始化器是一次性的，只为添加 acceptor\n\n//7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n//8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n```\n\n入口 `io.netty.bootstrap.ServerBootstrap#bind`\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind`\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n\t// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) {\n        return regFuture;\n    }\n\n    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    // 2.1 如果已经完成\n    if (regFuture.isDone()) {\n        ChannelPromise promise = channel.newPromise();\n        // 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    } \n    // 2.2 还没有完成\n    else {\n        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n        // 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                Throwable cause = future.cause();\n                if (cause != null) {\n                    // 处理异常...\n                    promise.setFailure(cause);\n                } else {\n                    promise.registered();\n\t\t\t\t\t// 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                }\n            }\n        });\n        return promise;\n    }\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#initAndRegister`\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    try {\n        channel = channelFactory.newChannel();\n        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    } catch (Throwable t) {\n        // 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    }\n\n    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) {\n        // 处理异常...\n    }\n    return regFuture;\n}\n```\n\n关键代码 `io.netty.bootstrap.ServerBootstrap#init`\n\n```java\n// 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception {\n    final Map\u003cChannelOption\u003c?\u003e, Object\u003e options = options0();\n    synchronized (options) {\n        setChannelOptions(channel, options, logger);\n    }\n\n    final Map\u003cAttributeKey\u003c?\u003e, Object\u003e attrs = attrs0();\n    synchronized (attrs) {\n        for (Entry\u003cAttributeKey\u003c?\u003e, Object\u003e e: attrs.entrySet()) {\n            @SuppressWarnings(\"unchecked\")\n            AttributeKey\u003cObject\u003e key = (AttributeKey\u003cObject\u003e) e.getKey();\n            channel.attr(key).set(e.getValue());\n        }\n    }\n\n    ChannelPipeline p = channel.pipeline();\n\n    final EventLoopGroup currentChildGroup = childGroup;\n    final ChannelHandler currentChildHandler = childHandler;\n    final Entry\u003cChannelOption\u003c?\u003e, Object\u003e[] currentChildOptions;\n    final Entry\u003cAttributeKey\u003c?\u003e, Object\u003e[] currentChildAttrs;\n    synchronized (childOptions) {\n        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));\n    }\n    synchronized (childAttrs) {\n        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));\n    }\n\t\n    // 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        public void initChannel(final Channel ch) throws Exception {\n            final ChannelPipeline pipeline = ch.pipeline();\n            ChannelHandler handler = config.handler();\n            if (handler != null) {\n                pipeline.addLast(handler);\n            }\n\n            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() {\n                @Override\n                public void run() {\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                }\n            });\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行\n            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            // 这行代码完成的事实是 main -\u003e nio boss 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\n        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        // 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) {\n            if (firstRegistration) {\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        // Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n关键代码 `io.netty.channel.ChannelInitializer#initChannel`\n\n```java\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n    if (initMap.add(ctx)) { // Guard against re-entrance.\n        try {\n            // 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        } catch (Throwable cause) {\n            exceptionCaught(ctx, cause);\n        } finally {\n            // 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline = ctx.pipeline();\n            if (pipeline.context(this) != null) {\n                pipeline.remove(this);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind0`\n\n```java\n// 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) {\n\n    channel.eventLoop().execute(new Runnable() {\n        @Override\n        public void run() {\n            if (regFuture.isSuccess()) {\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                promise.setFailure(regFuture.cause());\n            }\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#bind`\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) {\n        return;\n    }\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) \u0026\u0026\n        localAddress instanceof InetSocketAddress \u0026\u0026\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() \u0026\u0026\n        !PlatformDependent.isWindows() \u0026\u0026 !PlatformDependent.maybeSuperUser()) {\n        // 记录日志...\n    }\n\n    boolean wasActive = isActive();\n    try {\n        // 3.3 执行端口绑定\n        doBind(localAddress);\n    } catch (Throwable t) {\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    }\n\n    if (!wasActive \u0026\u0026 isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // 3.4 触发 active 事件\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n\n    safeSetSuccess(promise);\n}\n```\n\n3.3 关键代码 `io.netty.channel.socket.nio.NioServerSocketChannel#doBind`\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() \u003e= 7) {\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n```\n\n3.4 关键代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();\n}\n```\n\n关键代码 `io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps \u0026 readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n### 2.2 NioEventLoop 剖析\n\n![[z-oblib/z2-attachments/Pasted image 20220624231611.png]]\n\nNioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\n\n提交任务代码 `io.netty.util.concurrent.SingleThreadEventExecutor#execute`\n\n```java\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException(\"task\");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) {\n        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) {\n            // 如果已经 shutdown，做拒绝逻辑，代码略...\n        }\n    }\n\n    if (!addTaskWakesUp \u0026\u0026 wakesUpForTask(task)) {\n        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    }\n}\n```\n\n唤醒 select 阻塞线程`io.netty.channel.nio.NioEventLoop#wakeup`\n\n```java\n@Override\nprotected void wakeup(boolean inEventLoop) {\n    if (!inEventLoop \u0026\u0026 wakenUp.compareAndSet(false, true)) {\n        selector.wakeup();\n    }\n}\n```\n\n启动 EventLoop 主循环 `io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread`\n\n```java\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            // 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            } finally {\n\t\t\t\t// 清理工作，代码略...\n            }\n        }\n    });\n}\n```\n\n`io.netty.channel.nio.NioEventLoop#run` 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\n\n```java\nprotected void run() {\n    for (;;) {\n        try {\n            try {\n                // calculateStrategy 的逻辑如下：\n                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        // 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp = wakenUp.getAndSet(false);\n                        \n                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        // 下面的 select 方法不会阻塞\n                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        // 才能执行，让 select 方法无谓阻塞\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                }\n            } catch (IOException e) {\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // ioRatio 默认是 50\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // ioRatio 为 100 时，总是运行完所有非 IO 任务\n                    runAllTasks();\n                }\n            } else {                \n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // 记录 io 事件处理耗时\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    // 运行非 IO 任务，一旦超时会退出 runAllTasks\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n#### ⚠️ 注意\n\n\u003e 这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\n\u003e\n\u003e * 由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\n\u003e * 由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\n\n\n\n参考下图\n\n![[z-oblib/z2-attachments/0032.png]]\n\n\n\n`io.netty.channel.nio.NioEventLoop#select`\n\n```java\nprivate void select(boolean oldWakenUp) throws IOException {\n    Selector selector = this.selector;\n    try {\n        int selectCnt = 0;\n        long currentTimeNanos = System.nanoTime();\n        // 计算等待时间\n        // * 没有 scheduledTask，超时时间为 1s\n        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`\n        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) {\n            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;\n            // 如果超时，退出循环\n            if (timeoutMillis \u003c= 0) {\n                if (selectCnt == 0) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                }\n                break;\n            }\n\n            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() \u0026\u0026 wakenUp.compareAndSet(false, true)) {\n                selector.selectNow();\n                selectCnt = 1;\n                break;\n            }\n\n            // select 有限时阻塞\n            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%\n            int selectedKeys = selector.select(timeoutMillis);\n            // 计数加 1\n            selectCnt ++;\n\n            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环\n            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                break;\n            }\n            if (Thread.interrupted()) {\n               \t// 线程被打断，退出循环\n                // 记录日志\n                selectCnt = 1;\n                break;\n            }\n\n            long time = System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) \u003e= currentTimeNanos) {\n                // 如果超时，计数重置为 1，下次循环就会 break\n                selectCnt = 1;\n            } \n            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            // 这是为了解决 nio 空轮询 bug\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD \u003e 0 \u0026\u0026\n                    selectCnt \u003e= SELECTOR_AUTO_REBUILD_THRESHOLD) {\n                // 重建 selector\n                selector = selectRebuildSelector(selectCnt);\n                selectCnt = 1;\n                break;\n            }\n\n            currentTimeNanos = time;\n        }\n\n        if (selectCnt \u003e MIN_PREMATURE_SELECTOR_RETURNS) {\n            // 记录日志\n        }\n    } catch (CancelledKeyException e) {\n        // 记录日志\n    }\n}\n```\n\n处理 keys `io.netty.channel.nio.NioEventLoop#processSelectedKeys`\n\n```java\nprivate void processSelectedKeys() {\n    if (selectedKeys != null) {\n        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();\n    } else {\n        processSelectedKeysPlain(selector.selectedKeys());\n    }\n}\n```\n\n`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n    // 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) {\n        // 无效时处理...\n        return;\n    }\n\n    try {\n        int readyOps = k.readyOps();\n        // 连接事件\n        if ((readyOps \u0026 SelectionKey.OP_CONNECT) != 0) {\n            int ops = k.interestOps();\n            ops \u0026= ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        }\n\n        // 可写事件\n        if ((readyOps \u0026 SelectionKey.OP_WRITE) != 0) {\n            ch.unsafe().forceFlush();\n        }\n\n        // 可读或可接入事件\n        if ((readyOps \u0026 (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();\n        }\n    } catch (CancelledKeyException ignored) {\n        unsafe.close(unsafe.voidPromise());\n    }\n}\n```\n\n### 2.3 accept 剖析\n\nnio 中如下代码，在 netty 中的流程\n\n```java\n//1 阻塞直到事件发生\nselector.select();\n\nIterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) {    \n    //2 拿到一个事件\n    SelectionKey key = iter.next();\n    \n    //3 如果是 accept 事件\n    if (key.isAcceptable()) {\n        \n        //4 执行 accept\n        SocketChannel channel = serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        //5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n    // ...\n}\n```\n\n先来看可接入事件处理（accept）\n\n`io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read`\n\n```java\npublic void read() {\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config = config();\n    final ChannelPipeline pipeline = pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed = false;\n    Throwable exception = null;\n    try {\n        try {\n            do {\n\t\t\t\t// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf\n                // readBuf 是一个 ArrayList 用来缓存消息\n                int localRead = doReadMessages(readBuf);\n                if (localRead == 0) {\n                    break;\n                }\n                if (localRead \u003c 0) {\n                    closed = true;\n                    break;\n                }\n\t\t\t\t// localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            } while (allocHandle.continueReading());\n        } catch (Throwable t) {\n            exception = t;\n        }\n\n        int size = readBuf.size();\n        for (int i = 0; i \u003c size; i ++) {\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        }\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception != null) {\n            closed = closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        }\n\n        if (closed) {\n            inputShutdown = true;\n            if (isOpen()) {\n                close(voidPromise());\n            }\n        }\n    } finally {\n        if (!readPending \u0026\u0026 !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n关键代码 `io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead`\n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // 这时的 msg 是 NioSocketChannel\n    final Channel child = (Channel) msg;\n\n    // NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    // 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry\u003cAttributeKey\u003c?\u003e, Object\u003e e: childAttrs) {\n        child.attr((AttributeKey\u003cObject\u003e) e.getKey()).set(e.getValue());\n    }\n\n    try {\n        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}\n```\n\n又回到了熟悉的 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`  方法\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 这行代码完成的事实是 nio boss -\u003e nio worker 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\t\t\n        // 执行初始化器，执行前 pipeline 中只有 head -\u003e 初始化器 -\u003e tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        // 执行后就是 head -\u003e logging handler -\u003e my handler -\u003e tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) {\n            if (firstRegistration) {\n                // 触发 pipeline 上 active 事件\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n回到了熟悉的代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n}\n```\n\n`io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\t// 这时候 interestOps 是 0\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps \u0026 readInterestOp) == 0) {\n        // 关注 read 事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n### 2.4 read 剖析\n\n再来看可读事件 `io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read`，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\n\n```java\npublic final void read() {\n    final ChannelConfig config = config();\n    if (shouldBreakReadReady(config)) {\n        clearReadPending();\n        return;\n    }\n    final ChannelPipeline pipeline = pipeline();\n    // io.netty.allocator.type 决定 allocator 的实现\n    final ByteBufAllocator allocator = config.getAllocator();\n    // 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            // 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() \u003c= 0) {\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() \u003c 0;\n                if (close) {\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } \n        // 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        // 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        if (!readPending \u0026\u0026 !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n`io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)`\n\n```java\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {\n    return \n           // 一般为 true\n           config.isAutoRead() \u0026\u0026\n           // respectMaybeMoreData 默认为 true\n           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) \u0026\u0026\n           // 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages \u003c maxMessagePerRead \u0026\u0026\n           // 实际读到了数据\n           totalBytesRead \u003e 0;\n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Netty/Netty%E5%85%A5%E9%97%A8":{"title":"Netty入门","content":"\n# Netty入门\n\n## 1. 概述\n\n### 1.1 Netty 是什么？\n\n```\nNetty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers \u0026 clients.\n```\n\nNetty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n\n### 1.2 Netty 的作者\n\n![[z-oblib/z2-attachments/64fc67105d460cb23e0bcc014ba4c21f.png]]\n\n他还是另一个著名网络应用框架 Mina 的重要贡献者\n\n### 1.3 Netty 的地位\n\nNetty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\n\n以下的框架都使用了 Netty，因为它们有网络通信需求！\n\n* Cassandra - nosql 数据库\n* Spark - 大数据分布式计算框架\n* Hadoop - 大数据分布式存储框架\n* RocketMQ - ali 开源的消息队列\n* ElasticSearch - 搜索引擎\n* gRPC - rpc 框架\n* Dubbo - rpc 框架\n* Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\n* Zookeeper - 分布式协调框架\n\n### 1.4 Netty 的优势\n\n* Netty vs NIO，工作量大，bug 多\n  * 需要自己构建协议\n  * 解决 TCP 传输问题，如粘包、半包\n  * epoll 空轮询导致 CPU 100%\n  * 对 API 进行增强，使之更易用，如 FastThreadLocal =\u003e ThreadLocal，ByteBuf =\u003e ByteBuffer\n* Netty vs 其它网络应用框架\n  * Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\n  * 久经考验，16年，Netty 版本\n    * 2.x 2004\n    * 3.x 2008\n    * 4.x 2013\n    * 5.x 已废弃（没有明显的性能提升，维护成本高）\n\n## 2. Hello World\n\n### 2.1 目标\n\n开发一个简单的服务器端和客户端\n\n* 客户端向服务器端发送 hello, world\n* 服务器仅接收，不返回\n\n\n\n加入依赖\n\n```xml\n\u003cdependency\u003e\n    \u003cgroupId\u003eio.netty\u003c/groupId\u003e\n    \u003cartifactId\u003enetty-all\u003c/artifactId\u003e\n    \u003cversion\u003e4.1.39.Final\u003c/version\u003e\n\u003c/dependency\u003e\n```\n\n### 2.2 服务器端\n\n```java\n// 服务器端的启动器，负责组装natty组件，协调工作并启动。\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioServerSocketChannel.class) // 2\n    .childHandler(new ChannelInitializer\u003cNioSocketChannel\u003e() { // 3\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new StringDecoder()); // 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler\u003cString\u003e() { // 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                    System.out.println(msg);  // 打印上一步转换好的字符串\n                }\n            });\n        }\n    })\n    .bind(8080); // 4\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，可以简单理解为 `线程池 + Selector` ，包含[[3-计算机科学/6-应用开发/0-软件语言/Java/NIO/NIO基础#💡 利用多线程优化|NIO]]部分的Boss和Worker两个选择器及对应的线程等。\n\n* 2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\n\n![[z-oblib/z2-attachments/e96dc3fa309784d125c72bc9f1dcbb3f.png]]\n\n* 3 处，添加的处理器都是给 SocketChannel 用的，也就是告诉worker如何去处理网络中的数据（编解码、业务处理...）。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器，这里添加了 5 6两个处理器。\n\n* 4 处，ServerSocketChannel 绑定的监听端口。\n\n* 5 处，SocketChannel 的处理器，解码 ByteBuf =\u003e String。\n\n* 6 处，自定义的SocketChannel 的业务处理器，接受的消息是上一个处理器的处理结果。\n\n### 2.3 客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioSocketChannel.class) // 2\n    .handler(new ChannelInitializer\u003cChannel\u003e() { // 3\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder()); // 8\n        }\n    })\n    .connect(\"127.0.0.1\", 8080) // 4\n    .sync() // 5\n    .channel() // 6\n    .writeAndFlush(new Date() + \": hello world!\"); // 7\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，同 Server\n\n* 2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\n\n![[z-oblib/z2-attachments/10eac7273abe4f354a285f9b498a2825.png]]\n\n* 3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n* 4 处，指定要连接的服务器和端口\n* 5 处，sync是一个同步（阻塞）方法。Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\n* 6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n* 7 处，写入消息并清空缓冲区\n* 8 处，消息会经过通道 handler 处理，这里是将 String =\u003e ByteBuf 发出\n* 数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\n\n### 2.4 流程梳理\n\n![[z-oblib/z2-attachments/adea72dac7ceb3d0f0158cd3d7acdd57.png]]\n\n#### 💡 提示\n\n\u003e 一开始需要树立正确的观念\n\u003e\n\u003e * 把 channel 理解为数据的通道\n\u003e * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\n\u003e * 把 handler 理解为数据的处理工序\n\u003e   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\n\u003e   * handler 分 Inbound 和 Outbound 两类\n\u003e * 把 eventLoop 理解为处理数据的工人\n\u003e   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\n\u003e   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\n\u003e   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\n\n## 3. 组件\n\n### 3.1 EventLoop\n\n\u003e 一个EventLoop只有一个线程。\n\n事件循环对象\n\nEventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\n\n它的继承关系比较复杂（两条线）：\n\n* 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n* 另一条线是继承自 netty 自己的 OrderedEventExecutor，\n  * 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\n  * 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\n\n\n\n事件循环组\n\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来**绑定**其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n\n* 继承自 netty 自己的 EventExecutorGroup\n  * 实现了 Iterable 接口提供遍历 EventLoop 的能力\n  * 另有 next 方法获取集合中下一个 EventLoop\n\n\n\n以一个简单的实现为例：\n\n```java\n// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98\n```\n\n也可以使用 for 循环\n\n```java\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) {\n    System.out.println(eventLoop);\n}\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\n```\n\n#### 💡 优雅关闭\n\n优雅关闭 `shutdownGracefully` 方法。该方法会首先切换 `EventLoopGroup` 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n\n#### 演示 NioEventLoop 处理 io 事件\n\n服务器端两个 nio worker 工人\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    Channel channel = new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception {\n                    System.out.println(\"init...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                }\n            })\n            .channel(NioSocketChannel.class).connect(\"localhost\", 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n```\n\n最后输出\n\n```\n22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         \n```\n\n可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了**绑定**\n\n![[z-oblib/z2-attachments/5481d330648f7aac4452dbfb01920fd3.png]]\n\n\n\n再增加两个非 nio 工人\n\n```java\nDefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n        @Override\n        protected void initChannel(NioSocketChannel ch)  {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(normalWorkers,\"myhandler\",\n              new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n输出\n\n```\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n```\n\n可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\n\n\n\n![[z-oblib/z2-attachments/7de561abc15cda8879ac2cf85700066b.png]]\n\n#### 💡 handler 执行中如何换人？\n\n\u003e pipline中的线程切换。\n\n关键代码 `io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()`\n\n\u003e 对比一下两个handler绑定的是不是同一个线程池，如果是就直接线性调用；如果不是就把接下来的任务包装成Runnable扔给下一个handler对应的线程池。\n\n```java\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {\n    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next);\n    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor = next.executor();\n    \n    // 是，直接调用\n    if (executor.inEventLoop()) {\n        next.invokeChannelRead(m);\n    } \n    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else {\n\t    // executor当前可以看作是一个线程池，是下一个handler\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                next.invokeChannelRead(m);\n            }\n        });\n    }\n}\n```\n\n* 如果两个 handler 绑定的是同一个线程，那么就直接调用\n* 否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\n\n#### 演示 NioEventLoop 处理普通任务\n\nNioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.execute(()-\u003e{\n    log.debug(\"normal task...\");\n});\n```\n\n输出\n\n```\n22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...\n```\n\n\u003e 可以用来执行耗时较长的任务\n\n#### 演示 NioEventLoop 处理定时任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -\u003e {\n    log.debug(\"running...\");\n}, 0, 1, TimeUnit.SECONDS);\n```\n\n输出\n\n```\n22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...\n```\n\n\u003e 可以用来执行定时任务\n\n### 3.2 Channel\n\nchannel 的主要作用\n\n* close() 可以用来关闭 channel\n* closeFuture() 用来处理 channel 的关闭\n  * sync 方法作用是同步等待 channel 关闭\n  * 而 addListener 方法是异步等待 channel 关闭\n* pipeline() 方法添加处理器\n* write() 方法将数据写入\n* writeAndFlush() 方法将数据写入并刷出\n\n#### ChannelFuture\n\n这时刚才的客户端代码\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + \": hello world!\");\n```\n\n现在把它拆开来看\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080); // 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + \": hello world!\");\n```\n\n* 1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\n\n**注意** connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象\n\n实验如下：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\n\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.sync(); // 2\nSystem.out.println(channelFuture.channel()); // 3\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x2e1884dd]`\n* 执行到 2 时，sync 方法是同步等待连接建立完成\n* 执行到 3 时，连接肯定建立了，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`\n\n除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.addListener((ChannelFutureListener) future -\u003e {\n    System.out.println(future.channel()); // 2\n});\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x749124ba]`\n* ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 `[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]`\n\n##### 总结\n\nsync：谁发起调用，谁阻塞式等待结果。\n[[3-计算机科学/2-计算机组成原理/回调|回调]]：执行动作和等待结果都交给其它线程处理，本线程不阻塞等待。\n\n#### CloseFuture\n\n```java\n@Slf4j\npublic class CloseFutureClient {\n    public static void main(String[] args) throws InterruptedException {\n\t\t// group需要提出来，否则后续关闭的时候无法引用到（匿名对象无法引用）\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture = new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n                    @Override // 在连接建立后被调用\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                })\n                .connect(new InetSocketAddress(\"localhost\", 8080));\n        Channel channel = channelFuture.sync().channel();\n        log.debug(\"{}\", channel);\n        new Thread(()-\u003e{\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if (\"q\".equals(line)) {\n                    channel.close(); // close 异步操作 1s 之后\n//                    log.debug(\"处理关闭之后的操作\"); // 不能在这里善后\n                    break;\n                }\n                channel.writeAndFlush(line);\n            }\n        }, \"input\").start();\n\n        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture = channel.closeFuture();\n        /*log.debug(\"waiting close...\");\n        closeFuture.sync();\n        log.debug(\"处理关闭之后的操作\");*/\n        closeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                log.debug(\"处理关闭之后的操作\");\n                // group的线程都要结束，才能完全结束\n                group.shutdownGracefully();\n            }\n        });\n    }\n}\n```\n\n#### 💡 异步提升的是什么\n\n* 有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\n\n* 还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\n\n\n思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：`4 * 8 * 3 = 96`\n\n![[z-oblib/z2-attachments/6a10c9dad3ac38a87f514c18b0324711.png]]\n\n经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\n\n![[z-oblib/z2-attachments/6a10c9dad3ac38a87f514c18b0324711.png]]\n\n因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 `4 * 8 * 12` 效率几乎是原来的四倍\n\n![[z-oblib/z2-attachments/a694740c598213c9bdeba1a223382696.png]]\n\n##### 要点\n\n\u003e 提升的思路类似CPU的流水线设计，将大任务细分，拆给不同人做。（不过CPU重排提升效率的部分原因是一些执行可以并行执行，而这里在线程数量不变的情况下，总处理事件不会缩短）；\n\u003e 降低了单一连接的响应速度（线程切换额外开销），提升了吞吐量（单位时间处理请求的个数）。\n\u003e 单个连接的处理时间还是和原来一样，但是不会因为其它连接占用线程而被阻塞了。\n\u003e 上面的例子如果不异步，例如有的病人需要动手术，耗费大量时间，会导致其它病人没法进来看病。\n\n* 单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\n* 异步并**没有**缩短响应时间，反而有所增加\n* 合理进行任务拆分，也是利用异步的关键\n\n### 3.3 Future \u0026 Promise\n\n在异步处理时，经常用到这两个接口\n\n首先要说明 netty 中的 Future 与 jdk 中的 [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/FutureTask|Future]] 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\n\n* jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\n* netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\n* netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器（单向变双向）\n\n| 功能/名称    | jdk Future                     | netty Future                                                 | Promise      |\n| ------------ | ------------------------------ | ------------------------------------------------------------ | ------------ |\n| cancel       | 取消任务                       | -                                                            | -            |\n| isCanceled   | 任务是否取消                   | -                                                            | -            |\n| isDone       | 任务是否完成，不能区分成功失败 | -                                                            | -            |\n| get          | 获取任务结果，阻塞等待         | -                                                            | -            |\n| getNow       | -                              | 获取任务结果，非阻塞，还未产生结果时返回 null                | -            |\n| await        | -                              | 等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断 | -            |\n| sync         | -                              | 等待任务结束，如果任务失败，抛出异常                         | -            |\n| isSuccess    | -                              | 判断任务是否成功                                             | -            |\n| cause        | -                              | 获取失败信息，非阻塞，如果没有失败，返回null                 | -            |\n| addLinstener | -                              | 添加回调，异步接收结果                                       | -            |\n| setSuccess   | -                              | -                                                            | 设置成功结果 |\n| setFailure   | -                              | -                                                            | 设置失败结果 |\n\n#### 例1\n\n同步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\neventExecutors.execute(()-\u003e{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\",promise.getNow()); // 还没有结果\nlog.debug(\"{}\",promise.get());\n```\n\n输出\n\n```\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10\n```\n\n#### 例2\n\n异步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\n// 设置回调，异步接收结果\npromise.addListener(future -\u003e {\n    // 这里的 future 就是上面的 promise\n    log.debug(\"{}\",future.getNow());\n});\n\n// 等待 1000 后设置成功结果\neventExecutors.execute(()-\u003e{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10\n```\n\n#### 例3\n\n同步处理任务失败 - sync \u0026 get\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\n        DefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\n        eventExecutors.execute(() -\u003e {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            RuntimeException e = new RuntimeException(\"error...\");\n            log.debug(\"set failure, {}\", e.toString());\n            promise.setFailure(e);\n        });\n\n        log.debug(\"start...\");\n        log.debug(\"{}\", promise.getNow());\n        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常\n```\n\n输出\n\n```\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread \"main\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\n#### 例4\n\n同步处理任务失败 - await\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\neventExecutors.execute(() -\u003e {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\", promise.getNow());\npromise.await(); // 与 sync 和 get 区别在于，不会抛异常\nlog.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n```\n\n输出\n\n```\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n#### 例5\n\n异步处理任务失败\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\npromise.addListener(future -\u003e {\n    log.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n});\n\neventExecutors.execute(() -\u003e {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n#### 例6\n\nawait 死锁检查\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise\u003cInteger\u003e promise = new DefaultPromise\u003c\u003e(eventExecutors);\n\neventExecutors.submit(()-\u003e{\n    System.out.println(\"1\");\n    try {\n        promise.await();\n        // 注意不能仅捕获 InterruptedException 异常\n        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    } catch (Exception e) { \n        e.printStackTrace();\n    }\n    System.out.println(\"2\");\n});\neventExecutors.submit(()-\u003e{\n    System.out.println(\"3\");\n    try {\n        promise.await();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"4\");\n});\n```\n\n输出\n\n```\n1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n```\n\n### 3.4 Handler \u0026 Pipeline\n\nChannelHandler 用来处理 Channel 上的各种事件，分为**入**站（客户端侧）、**出**站（服务器侧）两种。所有 ChannelHandler 被连成一串，就是 Pipeline\n\n* 入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\n* 出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\n\n打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\n\n\n\n先搞清楚顺序，服务端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); // 1\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); // 2\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(3);\n                    ctx.channel().write(msg); // 3\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(4);\n                    ctx.write(msg, promise); // 4\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(5);\n                    ctx.write(msg, promise); // 5\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(6);\n                    ctx.write(msg, promise); // 6\n                }\n            });\n        }\n    })\n    .bind(8080);\n```\n\n客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cChannel\u003e() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .addListener((ChannelFutureListener) future -\u003e {\n        future.channel().writeAndFlush(\"hello,world\");\n    });\n```\n\n服务器端打印：\n\n```\n1\n2\n3\n6\n5\n4\n```\n\n可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\n\n![[z-oblib/z2-attachments/9f1815805bdefed71b1f6f5e5c0627ee.png]]\n\n* 入站处理器中，ctx.fireChannelRead(msg) 是 **调用下一个入站处理器**\n  * 如果注释掉 1 处代码，则仅会打印 1\n  * 如果注释掉 2 处代码，则仅会打印 1 2\n* 3 处的 ctx.channel().write(msg) 会 **从尾部开始触发** 后续出站处理器的执行\n  * 如果注释掉 3 处代码，则仅会打印 1 2 3\n* 类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 **触发上一个出站处理器**\n  * 如果注释掉 6 处代码，则仅会打印 1 2 3 6\n* ctx.channel().write(msg) vs ctx.write(msg)\n  * 都是触发出站处理器的执行\n  * ctx.channel().write(msg) 从尾部开始查找出站处理器\n  * ctx.write(msg) 是从**当前**节点找上一个出站处理器\n  * 3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\n  * 6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\n\n\u003e ctx.write是从当前节点找下一个出站处理器\n\u003e channel.write是从尾节点开始找下一个出站处理器\n\n图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\n\n![[z-oblib/z2-attachments/56d3381368d498b7fbe7e6b775fcbdd1.png]]\n\n\u003e 提供从当前节点直接查找的目的是方便将多个读写操作串起来执行。\n\n#### EmbeddedChannel\n\n\u003ehandler测试工具类，不用借助服务器和客户端的实现就能模拟输入输出测试handler。\n\n```java\n@Slf4j  \npublic class TestEmbeddedChannel {  \n    public static void main(String[] args) {  \n        ChannelInboundHandlerAdapter h1 = new ChannelInboundHandlerAdapter(){  \n            @Override  \n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  \n                log.debug(\"1\");  \n                super.channelRead(ctx, msg);  \n            }  \n        };  \n        ChannelInboundHandlerAdapter h2 = new ChannelInboundHandlerAdapter(){  \n            @Override  \n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  \n                log.debug(\"2\");  \n                super.channelRead(ctx, msg);  \n            }  \n        };  \n        ChannelOutboundHandlerAdapter h3 = new ChannelOutboundHandlerAdapter() {  \n            @Override  \n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {  \n                log.debug(\"3\");  \n                super.write(ctx, msg, promise);  \n            }  \n        };  \n        ChannelOutboundHandlerAdapter h4 = new ChannelOutboundHandlerAdapter() {  \n            @Override  \n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {  \n                log.debug(\"4\");  \n                super.write(ctx, msg, promise);  \n            }  \n        };  \n        EmbeddedChannel channel = new EmbeddedChannel(h1, h2, h3, h4);  \n        // 模拟入站  \n        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"Hello\".getBytes()));  \n        // 模拟出站  \n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"World\".getBytes()));  \n    }  \n}\n```\n\n### 3.5 ByteBuf\n\n是对字节数据的封装\n\n\u003e 默认大小256，可动态扩容，而NIO的ByteBuffer不支持动态扩容。\n\n#### 1）创建\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);\n```\n\n\u003e DEFAULT是一个默认方法实现。\n\n上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\n\n输出\n\n```\nread index:0 write index:0 capacity:10\n```\n\n其中 log 方法参考如下\n\n```java\nprivate static void log(ByteBuf buffer) {\n    int length = buffer.readableBytes();\n    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;\n    StringBuilder buf = new StringBuilder(rows * 80 * 2)\n        .append(\"read index:\").append(buffer.readerIndex())\n        .append(\" write index:\").append(buffer.writerIndex())\n        .append(\" capacity:\").append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n}\n```\n\n#### 2）直接内存 vs 堆内存\n\n可以使用下面的代码来创建池化基于堆的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);\n```\n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);\n```\n\n* 直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\n* 直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时**主动**释放\n\n\u003egc可能会对堆内存中的数据进行搬迁、复制等操作。\n\n#### 3）池化 vs 非池化\n\n\u003e [[3-计算机科学/6-应用开发/1-软件方法学/设计模式/享元模式|享元模式]]。\n\n池化的最大意义在于可以重用 ByteBuf，优点有\n\n* 没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\n* 有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n* 高并发时，池化功能更**节约内存**，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n\n```java\n-Dio.netty.allocator.type={unpooled|pooled}\n```\n\n在VM options中配置：\n![[z-oblib/z2-attachments/Pasted image 20220621203238.png]]\n\n* 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n* 4.1 之前，池化功能还不成熟，默认是非池化实现\n\n#### 4）组成\n\nByteBuf 由四部分组成\n\n![[z-oblib/z2-attachments/cba17278034a053c70930947343310aa.png]]\n\n最开始读写指针都在 0 位置\n最大容量默认是Iterator.MAX_VALUE\n\n\u003e和NIO相比，两条指针不用flip进行读写切换了。\n\n#### 5）写入\n\n方法列表，省略一些不重要的方法\n\n| 方法签名                                                     | 含义                   | 备注                                        |\n| ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |\n| writeBoolean(boolean value)                                  | 写入 boolean 值        | 用一字节 01\\|00 代表 true\\|false            |\n| writeByte(int value)                                         | 写入 byte 值           |                                             |\n| writeShort(int value)                                        | 写入 short 值          |                                             |\n| writeInt(int value)                                          | 写入 int 值            | Big Endian，即 0x250，写入后 00 00 02 50    |\n| writeIntLE(int value)                                        | 写入 int 值            | Little Endian，即 0x250，写入后 50 02 00 00 |\n| writeLong(long value)                                        | 写入 long 值           |                                             |\n| writeChar(int value)                                         | 写入 char 值           |                                             |\n| writeFloat(float value)                                      | 写入 float 值          |                                             |\n| writeDouble(double value)                                    | 写入 double 值         |                                             |\n| writeBytes(ByteBuf src)                                      | 写入 netty 的 ByteBuf  |                                             |\n| writeBytes(byte[] src)                                       | 写入 byte[]            |                                             |\n| writeBytes(ByteBuffer src)                                   | 写入 nio 的 ByteBuffer |                                             |\n| int writeCharSequence(CharSequence sequence, Charset charset) | 写入字符串             |                                             |\n\n\u003e 注意\n\u003e\n\u003e这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\n\u003e网络传输，默认习惯是 Big Endian\n\n先写入 4 个字节\n\n```java\nbuffer.writeBytes(new byte[]{1, 2, 3, 4});\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n再写入一个 int 整数，也是 4 个字节\n\n```java\nbuffer.writeInt(5);\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n\n#### 6）扩容\n\n再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\n\n```java\nbuffer.writeInt(6);\nlog(buffer);\n```\n\n扩容规则是\n\n* 如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\n* 如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）\n* 扩容不能超过 max capacity 会报错\n\n结果是\n\n```\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+\n```\n\n#### 7）读取\n\n例如读了 4 次，每次一个字节\n\n```java\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);\n```\n\n读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\n\n```\n1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果需要重复读取 int 整数 5，怎么办？\n\n可以在 read 前先做个**读指针**的标记 mark\n\n```java\nbuffer.markReaderIndex();\nSystem.out.println(buffer.readInt());\nlog(buffer);\n```\n\n结果\n\n```\n5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时要重复读取的话，读指针重置到标记位置 reset\n\n```java\nbuffer.resetReaderIndex();\nlog(buffer);\n```\n\n这时\n\n```\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\n\n#### 8）retain \u0026 release\n\n由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\n* UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\n* UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\n* PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\n\n\u003e 回收内存的源码实现，请关注下面方法的不同实现\n\u003e `protected abstract void deallocate()`\n\nNetty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n* 每个 ByteBuf 对象的初始计数为 1\n* 调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n* 调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n* 当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\n\n谁来负责 release 呢？\n\n不是我们想象的（一般情况下）\n\n```java\nByteBuf buf = ...\ntry {\n    ...\n} finally {\n    buf.release();\n}\n```\n\n请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n\n基本规则是，**谁是最后使用者，谁负责 release**，详细分析如下\n\n* 起点，对于 NIO 实现来讲，在 `io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read` 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n* 入站 ByteBuf 处理原则\n  * 对原始 ByteBuf 不做处理，调用 `ctx.fireChannelRead(msg)` 向后传递，这时无须 release\n  * 将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\n  * **如果不调用 `ctx.fireChannelRead(msg)` 向后传递，那么也必须 release**\n  * 注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n  * 假设消息一直向后传，那么 **TailContext 会负责释放未处理消息**（原始的 ByteBuf）\n* 出站 ByteBuf 处理原则\n  * 出站消息最终都会转为 ByteBuf 输出，一直向前传，由 **HeadContext flush 后 release**\n* 异常处理原则\n  * 有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以**循环调用 release** 直到返回 true\n\nTailContext 释放未处理消息逻辑\n\n```java\n// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) {\n    try {\n        logger.debug(\n            \"Discarded inbound message {} that reached at the tail of the pipeline. \" +\n            \"Please check your pipeline configuration.\", msg);\n    } finally {\n        ReferenceCountUtil.release(msg);\n    }\n}\n```\n\n具体代码\n\n```java\n// io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) {\n    if (msg instanceof ReferenceCounted) {\n        return ((ReferenceCounted) msg).release();\n    }\n    // 不是ByteBuf类型也不用处理\n    return false;\n}\n```\n\n#### 9）slice\n\n**零拷贝**的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并**没有**发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n\n![[z-oblib/z2-attachments/ae0b62ba4b5935c66674cb603da6bbc4.png]]\n\n例，原始 ByteBuf 进行一些初始操作\n\n```java\nByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]{1, 2, 3, 4});\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此**不能**追加 write\n\n```java\nByteBuf slice = origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果原始 ByteBuf 再次读操作（又读了一个字节）\n\n```java\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时的 slice 不受影响，因为它有独立的读写指针\n\n```java\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果 slice 的内容发生了更改\n\n```java\nslice.setByte(2, 5);\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\n\n```\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n#### 10）duplicate\n\n【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是**读写指针**是独立的\n\n![[z-oblib/z2-attachments/dc2294119a7fdc68f77855060844c978.png]]\n\n#### 11）copy\n\n会将底层内存数据进行**深拷贝**，因此无论读写，都与原始 ByteBuf 无关\n\n#### 12）CompositeByteBuf\n\n【零拷贝】的体现之一，可以将多个 ByteBuf **合并**为一个逻辑上的 ByteBuf，避免拷贝\n\n有两个 ByteBuf 如下\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n```\n\n现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\n\n方法1：\n\n```java\nByteBuf buf3 = ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\n\n方法2：\n\n```java\nCompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);\n```\n\n结果是一样的\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\nCompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component **数组**，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体**偏移量**等信息，代表着整体中某一段的数据。\n\n* 优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\n* 缺点，复杂了很多，多次操作会带来性能的损耗\n\n#### 13）Unpooled\n\nUnpooled 是一个工具类，类如其名，提供了**非池化**的 ByteBuf 创建、组合、复制等操作\n\n这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\n\n// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n也可以用来包装普通字节数组，底层也不会有拷贝操作\n\n```java\nByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6});\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));\n```\n\n输出\n\n```\nclass io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+\n```\n\n#### 💡 ByteBuf 优势\n\n* **池化** - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n* **读写指针分离**，不需要像 ByteBuffer 一样切换读写模式\n* 可以**自动扩容**\n* 支持**链式调用**，使用更流畅\n* 很多地方体现**零拷贝**，例如 slice、duplicate、CompositeByteBuf\n\n## 4. 双向通信\n\n### 4.1 练习\n\n实现一个 echo server\n\n编写 server\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response = ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    // 思考：需要释放 buffer 吗\n                    // 思考：需要释放 response 吗\n                }\n            });\n        }\n    }).bind(8080);\n```\n\n编写 client\n\n```java\nNioEventLoopGroup group = new NioEventLoopGroup();\nChannel channel = new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer\u003cNioSocketChannel\u003e() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 思考：需要释放 buffer 吗\n                }\n            });\n        }\n    }).connect(\"127.0.0.1\", 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -\u003e {\n    group.shutdownGracefully();\n});\n\nnew Thread(() -\u003e {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n        String line = scanner.nextLine();\n        if (\"q\".equals(line)) {\n            channel.close();\n            break;\n        }\n        channel.writeAndFlush(line);\n    }\n}).start();\n```\n\n### 💡 读和写的误解\n\n我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在`A 到 B` 和 `B 到 A` 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\n\n例如\n\n```java\npublic class TestServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888);\n        Socket s = ss.accept();\n\n        new Thread(() -\u003e {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -\u003e {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i = 0; i \u003c 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n客户端\n\n```java\npublic class TestClient {\n    public static void main(String[] args) throws IOException {\n        Socket s = new Socket(\"localhost\", 8888);\n\n        new Thread(() -\u003e {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -\u003e {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i = 0; i \u003c 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Netty/Netty%E8%BF%9B%E9%98%B6":{"title":"Netty进阶","content":"\n# Netty进阶\n\n## 1. 粘包与半包\n\n### 1.1 粘包现象\n\n服务端代码\n\n```java\npublic class HelloWorldServer {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"connected {}\", ctx.channel());\n                            super.channelActive(ctx);\n                        }\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"disconnect {}\", ctx.channel());\n                            super.channelInactive(ctx);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = serverBootstrap.bind(8080);\n            log.debug(\"{} binding...\", channelFuture.channel());\n            channelFuture.sync();\n            log.debug(\"{} bound...\", channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(\"stoped\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HelloWorldServer().start();\n    }\n}\n```\n\n客户端代码希望发送 10 个消息，每个消息是 16 字节\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            for (int i = 0; i \u003c 10; i++) {\n                                ByteBuf buffer = ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                                ctx.writeAndFlush(buffer);\n                            }\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"127.0.0.1\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\n\n```\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE\n```\n\n### 1.2 半包现象\n\n客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\n\n```java\nByteBuf buffer = ctx.alloc().buffer();\nfor (int i = 0; i \u003c 10; i++) {\n    buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n}\nctx.writeAndFlush(buffer);\n```\n\n为现象明显，服务端修改一下接收缓冲区，其它代码不变\n\n```java\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);\n```\n\n服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\n\n```\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n```\n\n\u003e **注意**\n\u003e\n\u003e serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\n\n### 💡1.3 现象分析\n\n\u003e总原因：TCP消息没有边界。\n\n#### 粘包\n\n* 现象，发送 abc def，接收 abcdef\n* 原因\n  * **应用层**：接收方 ByteBuf 设置太大（Netty 默认 1024）\n  * **传输层**：TCP：滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\n  * **传输层**：TCP：Nagle 算法：会造成粘包\n\n\u003e Nagle 算法\n\u003e\n\u003e * 糊涂窗口综合征：即使发送1个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes（TCP20+IP20+数据1），非常不经济。因此为了提高网络利用率，tcp 希望**尽可能发送足够大的数据**，这就是 Nagle 算法产生的缘由\n\u003e * 该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送\n\u003e   * 如果 SO_SNDBUF 的数据达到 MSS，则需要发送\n\u003e   * 如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\n\u003e   * 如果 TCP_NODELAY = true，则需要发送\n\u003e   * 已发送的数据都收到 ack 时，则需要发送\n\u003e   * 上述条件不满足，但发生超时（一般为 200ms）则需要发送\n\u003e   * 除上述情况，延迟发送\n\n#### 半包\n\n* 现象，发送 abcdef，接收 abc def\n* 原因\n  * **应用层**：接收方 ByteBuf 小于实际发送数据量\n  * **传输层**：TCP：滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\n  * **数据链路层**：MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\t  * ↑MSS是**传输层**的报文载荷长度（不包含报头），MTU是**数据链路层**最大载荷长度，其中MTU包含了MSS，MTU减去IP头和TCP头（20+20）就是MSS\n\t  * 本机回环地址MTU限制很大，65535，难以测试。\n\n本质是因为 TCP 是流式协议，消息无边界\n\n\u003e 滑动窗口\n\u003e\n\u003e * TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\n\u003e\n\u003e   ![[z-oblib/z2-attachments/0049 1.png]]\n\u003e\n\u003e \n\u003e\n\u003e 为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\n\u003e\n\u003e  ![[z-oblib/z2-attachments/0051.png]]\n\u003e\n\u003e - 窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\n\u003e\n\u003e   * 图中深色的部分即要发送的数据，高亮的部分即窗口\n\u003e   * 窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\n\u003e   * 如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\n\u003e   * 接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\n\u003e\n\n\n\u003e  MSS 限制\n\u003e\n\u003e  * 链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\n\u003e\n\u003e   * 以太网的 MTU 是 1500\n\u003e   * FDDI（光纤分布式数据接口）的 MTU 是 4352\n\u003e   * 本地回环地址的 MTU 是 65535 - 本地测试不走网卡\n\u003e\n\u003e  * MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\n\u003e\n\u003e   * ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\n\u003e   * TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\n\u003e   * MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\n\u003e\n\u003e  ![[z-oblib/z2-attachments/0031.jpg]]\n\n### 1.4 💡解决方案\n\n1. 短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\n2. 每一条消息采用固定长度，缺点浪费空间\n3. 每一条消息采用分隔符，例如 \\n，缺点需要转义\n4. 每一条消息分为 head 和 body，head 中包含 body 的长度\n\n#### 方法1，短链接\n\n以解决粘包为例\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        // 分 10 次发送\n        for (int i = 0; i \u003c 10; i++) {\n            send();\n        }\n    }\n\n    private static void send() {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"conneted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                            ctx.writeAndFlush(buffer);\n                            // 发完即关\n                            ctx.close();\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n输出，略\n\n##### 缺点\n\n半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\n\n#### 方法2，固定长度\n\n让所有数据包长度固定（假设长度为 8 字节），服务器端加入\n\n```java\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));\n```\n\n\u003e frame：帧，网络上一条完整的消息\n\n客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            // 发送内容随机的数据包\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i \u003c 10; i++) {\n                                byte[] bytes = new byte[8];\n                                for (int j = 0; j \u003c r.nextInt(8); j++) {\n                                    bytes[j] = (byte) c;\n                                }\n                                c++;\n                                buffer.writeBytes(bytes);\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE\n```\n\n##### 缺点\n\n数据包的大小不好把握\n\n* 长度定的太大，浪费\n* 长度定的太小，对某些数据包又显得不够\n\n#### 方法3，固定分隔符\n\n服务端加入，默认以 `\\n` 或 `\\r\\n` 作为分隔符，必须指定最大长度，如果超出指定长度仍未出现分隔符，则抛出异常\n\n```java\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n```\n\n客户端在每条消息之后，加入 `\\n` 分隔符\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i \u003c 10; i++) {\n                                for (int j = 1; j \u003c= r.nextInt(16)+1; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                buffer.writeByte(10);\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE\n```\n\n##### 缺点\n\n处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\n\n#### 方法4，约定长度\n\n\u003e 类似http协议的Content-Length。实际上我们就是要设计一个类似http的协议。\n\n在发送消息前，先约定用定长字节表示接下来数据的长度\n\n```java\n// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));\n```\n\n客户端代码\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i \u003c 10; i++) {\n                                byte length = (byte) (r.nextInt(16) + 1);\n                                // 先写入长度\n                                buffer.writeByte(length);\n                                // 再\n                                for (int j = 1; j \u003c= length; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE\n\n```\n\n## 2. 协议设计与解析\n\n### 2.1 为什么需要协议？\n\n\u003e TCP/IP 中消息传输基于**流**的方式，**没有边界**。\n\n协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\n\n例如：在网络上传输\n\n```\n下雨天留客天留我不留\n```\n\n是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\n\n一种解读\n\n```\n下雨天留客，天留，我不留\n```\n\n另一种解读\n\n```\n下雨天，留客天，留我不？留\n```\n\n如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\n\n``` \n定长字节表示内容长度 + 实际内容\n```\n\n例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\n\n```\n0f下雨天留客06天留09我不留\n```\n\n\u003e 小故事\n\u003e\n\u003e 很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\n\u003e\n\u003e 年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\n\u003e\n\u003e 私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\n\u003e\n\u003e 双方唇枪舌战，你来我往，真个是不亦乐乎！\n\u003e\n\u003e 这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\n\n### 2.2 redis 协议举例\n\n```java\nNioEventLoopGroup worker = new NioEventLoopGroup();\nbyte[] LINE = {13, 10};\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                // 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) {\n                    set(ctx);\n                    get(ctx);\n                }\n                private void get(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*2\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"get\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n                private void set(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"set\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"bbb\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    ByteBuf buf = (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                }\n            });\n        }\n    });\n    ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 6379).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"client error\", e);\n} finally {\n    worker.shutdownGracefully();\n}\n```\n\n### 2.3 http 协议举例\n\n```java\nNioEventLoopGroup boss = new NioEventLoopGroup();\nNioEventLoopGroup worker = new NioEventLoopGroup();\ntry {\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer\u003cSocketChannel\u003e() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new SimpleChannelInboundHandler\u003cHttpRequest\u003e() {\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {\n                    // 获取请求\n                    log.debug(msg.uri());\n\n                    // 返回响应\n                    DefaultFullHttpResponse response =\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes = \"\u003ch1\u003eHello, world!\u003c/h1\u003e\".getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                    response.content().writeBytes(bytes);\n\n                    // 写回响应\n                    ctx.writeAndFlush(response);\n                }\n            });\n            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    log.debug(\"{}\", msg.getClass());\n\n                    if (msg instanceof HttpRequest) { // 请求行，请求头\n\n                    } else if (msg instanceof HttpContent) { //请求体\n\n                    }\n                }\n            });*/\n        }\n    });\n    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"server error\", e);\n} finally {\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n}\n```\n\n### 2.4 自定义协议要素\n\n* 魔数，用来在第一时间判定是否是无效数据包\n* 版本号，可以支持协议的升级\n* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk（性能差、非跨平台）\n* 指令类型，是登录、注册、单聊、群聊... 跟业务相关\n* 请求序号，为了双工通信， \n* 正文长度\n* 消息正文\n\n#### 编解码器\n\n根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\n\n```java\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec\u003cMessage\u003e {\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n测试\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n// encode\nLoginRequestMessage message = new LoginRequestMessage(\"zhangsan\", \"123\", \"张三\");\n//        channel.writeOutbound(message);\n// decode\nByteBuf buf = ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 = buf.slice(0, 100);\nByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); // 引用计数 2\nchannel.writeInbound(s1); // release 1\nchannel.writeInbound(s2);\n```\n\n解读\n\n![[z-oblib/z2-attachments/0013.png]]\n\n##### 注意半包\n\n虽然协议指定了数据长度，可以解决粘包问题，但是半包问题还要注意：\n如果半包了，那么handler就不应该继续往下处理，因为此时反序列化会失败（实际长度小于指定长度，越界读）。\n需要先用帧解码器包装包的完整性。 \n\n#### 💡 什么时候可以加 @Sharable\n\n* 当 handler **不保存状态**（成员变量）时，就可以安全地在多线程下被共享（例如LoggingHandler可以共享，LengthFieldBasedFrameDecoder不能共享）。\n* 但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\n\t* netty认为你如果继承了这两个父类，那么你就应该是会保存状态的（不管你实际上是否这么做了）\n* 如果能确保编解码器**不会**保存状态，可以继承 MessageToMessageCodec 父类\n\n\u003e Byte代表raw的数据，可能不完整，Message代表是一条完整的消息了。\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec\u003cByteBuf, Message\u003e {\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List\u003cObject\u003e outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n## 3. 聊天室案例\n\n### 3.1 聊天室业务介绍\n\n```java\n/**\n * 用户管理接口\n */\npublic interface UserService {\n\n    /**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     */\n    boolean login(String username, String password);\n}\n```\n\n```java\n/**\n * 会话管理接口\n */\npublic interface Session {\n\n    /**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     */\n    void bind(Channel channel, String username);\n\n    /**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     */\n    void unbind(Channel channel);\n\n    /**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     */\n    Object getAttribute(Channel channel, String name);\n\n    /**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     */\n    void setAttribute(Channel channel, String name, Object value);\n\n    /**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     */\n    Channel getChannel(String username);\n}\n```\n\n```java\n/**\n * 聊天组会话管理接口\n */\npublic interface GroupSession {\n\n    /**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     */\n    Group createGroup(String name, Set\u003cString\u003e members);\n\n    /**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group joinMember(String name, String member);\n\n    /**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeMember(String name, String member);\n\n    /**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeGroup(String name);\n\n    /**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     */\n    Set\u003cString\u003e getMembers(String name);\n\n    /**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     */\n    List\u003cChannel\u003e getMembersChannel(String name);\n}\n```\n\n### 3.2 聊天室业务-登录\n\n```java\n@Slf4j\npublic class ChatServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler\u003cLoginRequestMessage\u003e() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n                            String username = msg.getUsername();\n                            String password = msg.getPassword();\n                            boolean login = UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) {\n                                message = new LoginResponseMessage(true, \"登录成功\");\n                            } else {\n                                message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n                            }\n                            ctx.writeAndFlush(message);\n                        }\n                    });\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n```java\n@Slf4j\npublic class ChatClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);\n        AtomicBoolean LOGIN = new AtomicBoolean(false);\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer\u003cSocketChannel\u003e() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n//                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(\"client handler\", new ChannelInboundHandlerAdapter() {\n                        // 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                            log.debug(\"msg: {}\", msg);\n                            if ((msg instanceof LoginResponseMessage)) {\n                                LoginResponseMessage response = (LoginResponseMessage) msg;\n                                if (response.isSuccess()) {\n                                    // 如果登录成功\n                                    LOGIN.set(true);\n                                }\n                                // 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            }\n                        }\n\n                        // 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -\u003e {\n                                Scanner scanner = new Scanner(System.in);\n                                System.out.println(\"请输入用户名:\");\n                                String username = scanner.nextLine();\n                                System.out.println(\"请输入密码:\");\n                                String password = scanner.nextLine();\n                                // 构造消息对象\n                                LoginRequestMessage message = new LoginRequestMessage(username, password);\n                                // 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(\"等待后续操作...\");\n                                try {\n                                    WAIT_FOR_LOGIN.await();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                                // 如果登录失败\n                                if (!LOGIN.get()) {\n                                    ctx.channel().close();\n                                    return;\n                                }\n                                while (true) {\n                                    System.out.println(\"==================================\");\n                                    System.out.println(\"send [username] [content]\");\n                                    System.out.println(\"gsend [group name] [content]\");\n                                    System.out.println(\"gcreate [group name] [m1,m2,m3...]\");\n                                    System.out.println(\"gmembers [group name]\");\n                                    System.out.println(\"gjoin [group name]\");\n                                    System.out.println(\"gquit [group name]\");\n                                    System.out.println(\"quit\");\n                                    System.out.println(\"==================================\");\n                                    String command = scanner.nextLine();\n                                    String[] s = command.split(\" \");\n                                    switch (s[0]){\n                                        case \"send\":\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gsend\":\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gcreate\":\n                                            Set\u003cString\u003e set = new HashSet\u003c\u003e(Arrays.asList(s[2].split(\",\")));\n                                            set.add(username); // 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case \"gmembers\":\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case \"gjoin\":\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case \"gquit\":\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case \"quit\":\n                                            ctx.channel().close();\n                                            return;\n                                    }\n                                }\n                            }, \"system in\").start();\n                        }\n                    });\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n### 3.3 聊天室业务-单聊\n\n服务器端将 handler 独立出来\n\n登录 handler\n\n```java\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler\u003cLoginRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n        String username = msg.getUsername();\n        String password = msg.getPassword();\n        boolean login = UserServiceFactory.getUserService().login(username, password);\n        LoginResponseMessage message;\n        if(login) {\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message = new LoginResponseMessage(true, \"登录成功\");\n        } else {\n            message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n        }\n        ctx.writeAndFlush(message);\n    }\n}\n```\n\n单聊 handler\n\n```java\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler\u003cChatRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception {\n        String to = msg.getTo();\n        Channel channel = SessionFactory.getSession().getChannel(to);\n        // 在线\n        if(channel != null) {\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n        // 不在线\n        else {\n            ctx.writeAndFlush(new ChatResponseMessage(false, \"对方用户不存在或者不在线\"));\n        }\n    }\n}\n```\n\n### 3.4 聊天室业务-群聊\n\n创建群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler\u003cGroupCreateRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception {\n        String groupName = msg.getGroupName();\n        Set\u003cString\u003e members = msg.getMembers();\n        // 群管理器\n        GroupSession groupSession = GroupSessionFactory.getGroupSession();\n        Group group = groupSession.createGroup(groupName, members);\n        if (group == null) {\n            // 发生成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + \"创建成功\"));\n            // 发送拉群消息\n            List\u003cChannel\u003e channels = groupSession.getMembersChannel(groupName);\n            for (Channel channel : channels) {\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, \"您已被拉入\" + groupName));\n            }\n        } else {\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + \"已经存在\"));\n        }\n    }\n}\n```\n\n群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler\u003cGroupChatRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception {\n        List\u003cChannel\u003e channels = GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n    }\n}\n```\n\n加入群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler\u003cGroupJoinRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群加入成功\"));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n退出群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler\u003cGroupQuitRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, \"已退出群\" + msg.getGroupName()));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n查看成员\n\n```java\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler\u003cGroupMembersRequestMessage\u003e {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception {\n        Set\u003cString\u003e members = GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    }\n}\n```\n\n### 3.5 聊天室业务-退出\n\n```\n@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter {\n\n    // 当连接断开时触发 inactive 事件\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经断开\", ctx.channel());\n    }\n\n\t// 当出现异常时触发\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经异常断开 异常是{}\", ctx.channel(), cause.getMessage());\n    }\n}\n```\n\n### 3.6 聊天室业务-空闲检测\n\n#### 连接假死\n\n##### 原因\n\n* 网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用**程序没有感知**到，仍然占用着资源。\n* 公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\n* 应用程序线程阻塞，无法进行数据读写\n\n##### 问题\n\n* 假死的连接占用的资源不能自动释放\n* 向假死的连接发送数据，得到的反馈是发送超时\n\n##### 服务器端解决\n\n* 怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了读空闲事件\n        if (event.state() == IdleState.READER_IDLE) {\n            log.debug(\"已经 5s 没有读到数据了\");\n            ctx.channel().close();\n        }\n    }\n});\n```\n\n##### 客户端定时心跳\n\n* 客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了写空闲事件\n        if (event.state() == IdleState.WRITER_IDLE) {\n            //                                log.debug(\"3s 没有写数据了，发送一个心跳包\");\n            ctx.writeAndFlush(new PingMessage());\n        }\n    }\n});\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/SSM/spring":{"title":"spring","content":"\n# spring\n\n## 依赖注入\n\nxml配置中常见形式 `\u003cxxx name=\"abc\", ref=\"abcBean\"\u003e`：\n1. setter注入时意味着：将前述创建的abcBean赋值给**成员**abc。\n2. 构造器注入时意味着：将前述创建的abcBean传递给**形参**abc。 \n\n\u003e ref填的是前述定义的bean的id值。\n\n\u003e 构造器传递会受到构造函数形参的限制，造成配置文件与代码的耦合，虽然提供了部分兼容性的解决方案：指定参数类型、指定参数顺序，但还是不好用，自己开发模块推荐用setter。\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8":{"title":"AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用","content":"\n# AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用\n\n[(33条消息) AbstractDispatcherServletInitializer 的实现类为什么可以在初始化Web容器的时候被调用_Nishkata的博客-CSDN博客](https://blog.csdn.net/Nishkata/article/details/125432352)\n\n[Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析_Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析|Samuel个人博客 (yangshuaibin.com)](https://www.yangshuaibin.com/detail/392696)\n\n## Servlet 做的事\n\nServlet3.0 环境中，容器会在类路径中查找实现 ServletContainerInitializer 接口的类，如果发现的话，就用它来配置 Servlet 容器。  \n\n## SpringMvc 做的事\n\nSpring 提供了这个接口的实现类 SpringServletContainerInitializer , 通过 `@HandlesTypes(WebApplicationInitializer.class)` 设置，这个类反过来会查找实现 WebApplicationInitializer 的类，并将配置的任务交给他们来完成。  \nAbstractAnnotationConfigDispatcherServletInitializer 类扩展了 WebApplicationInitializer 。这样就可以通过实现 AbstractAnnotationConfigDispatcherServletInitializer 来进行配置 Servlet 的上下文了。\n\nDispatcherServletInitializer 配置类能够被加载的核心是 Java 的 [[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/SPI|SPI]] 服务发现机制。\n\n1. 服务接口的定义：Servlet 规范定义了服务接口 `javax-servlet-api-xxx.jar/javax.servlet.ServletContainerInitializer`\n2. 注册服务接口的实现： Spring MVC 注册服务。在 `spring-web-xxx.jar` 包下 有 `META-INF/services/javax.servlet.ServletContainerInitializer` 文件，内容为 `org.springframework.web.SpringServletContainerInitializer`\n3. 服务加载： SpringServletContainerInitializer 中的 onStartup 方法会在 Servlet 容器初始化的时候通过 SPI 机制发现并调用，onStartup 方法里面又会 将所有 WebApplicationInitializer 的实现类的对象的 onStartup 方法全部调用一遍。\n4. AbstractDispatcherServletInitializer 也是 WebApplicationInitializer 接口的实现，所以其 onStartup 方法也会在 Servlet 容器初始化的时候被调用。\n\n![[z-oblib/z2-attachments/Pasted image 20220819234813.png]]\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Spring/spring%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7":{"title":"spring报错分析技巧","content":"# spring报错分析技巧\n\n1. 错误信息**从下往上依次查看**，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面。 \n2. 有时最下一层是spring内部的异常，可以往上看一级。\n\n最下面是核心原因，最上面是整条错误链的串显示。","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Tomcat/Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0":{"title":"Tomcat线程池","content":"\n# Tomcat线程池\n\n\u003e 合理的分工是实现高[[3-计算机科学/2-计算机组成原理/并发|并发]]的保障。\n\n![[z-oblib/z2-attachments/Pasted image 20220608183846.png]]\n\n\u003e 分工的原因就是为了防止[[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/饥饿|饥饿]]，把\n\n- LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore 后面再讲\n- Acceptor 只负责【接收新的 socket 连接】\n- Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】\n- 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor [[3-计算机科学/6-应用开发/0-软件语言/Java/2-并发编程/线程池|线程池]]处理\n- Executor 线程池中的[[3-计算机科学/6-应用开发/1-软件方法学/设计模式/工作线程|工作线程]]最终负责【处理请求】。\n\n## 与JDK线程池差别\n\nTomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同：\n\n- 如果总线程数达到 maximumPoolSize\n\t- 这时不会立刻抛 RejectedExecutionException 异常\n\t- 而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常\n\n```java\npublic void execute(Runnable command, long timeout, TimeUnit unit) {\n    submittedCount.incrementAndGet();\n    try {\n\t    // 先执行原生的execute\n        super.execute(command);\n    // 第一次失败不直接抛异常\n    } catch (RejectedExecutionException rx) {\n\t    // 拿到任务队列\n\t    // TaskQueue是tomcat做过扩展的任务队列\n        if (super.getQueue() instanceof TaskQueue) {\n            final TaskQueue queue = (TaskQueue)super.getQueue();\n            try {\n                if (!queue.force(command, timeout, unit)) {\n                    submittedCount.decrementAndGet();\n                    throw new RejectedExecutionException(\"Queue capacity is full.\");\n                }\n            } catch (InterruptedException x) {\n                submittedCount.decrementAndGet();\n                Thread.interrupted();\n                throw new RejectedExecutionException(x);\n            }\n            } else {\n            submittedCount.decrementAndGet();\n            throw rx;\n        }\n \n    }\n}\n```\n\nConnector 配置：\n\n```java\npublic boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {\n    if ( parent.isShutdown() ) \n        throw new RejectedExecutionException(\n            \"Executor not running, can't force a command into the queue\"\n        );\n    // 还是调用的offer\n    return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task \nis rejected\n}\n```\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Tomcat/tomcat%E5%8E%9F%E7%90%86":{"title":"tomcat原理","content":"# tomcat原理\n\n![[z-oblib/z2-attachments/Pasted image 20220815211547.png]]\n\n## 右边 -- 请求处理\n\n![[z-oblib/z2-attachments/Pasted image 20220815210239.png]]\n\nwrapper的作用是给具体的servlet实现进行分类，每个servlet实现对应一个wrapper，存储多个运行时产生的实例。\n\n\u003e作用的防止混乱。\n\nvalve本身是一个责任链的模式，例如可以自定义valve来记录日志。\n请求到达对应层次的时候，tomcat就会将请求传递给valve链处理，最终从StandardEngineValve将请求转交给下一层。\n\nWrapper中最后一个valve（StandardWrapperValve）会调用具体的业务servlet实例对象上的方法，统一调用service方法（servlet父类方法）， service根据http头的动作字符串（GET/POST。。）调用对应的方法。\n\n\n## 左边 -- 请求产生\n\n","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/6-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/dao":{"title":"dao","content":"# dao\n\nDAO（Data Access Object）是**用于访问数据的对象**，实际上是一个映射关系，将java中访问对象的操作映射的具体数据库的操作，例如Mybatis的设计中，MapperScannerConfigurer会扫描所有dao，得到domain数据对象操作和数据库语句的映射关系，通过[[3-计算机科学/6-应用开发/0-软件语言/Java/1-高级特性/动态代理|动态代理]]的方式拦截所有对domain的操作，转到对数据库的操作。","lastmodified":"2023-01-23T15:37:51.774680734Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%AD%97%E8%8A%82":{"title":"逆向中的双字节","content":"\n# 逆向中的双字节\n\n- 数据储存类型分为 byte, word, dword\n    - 区别在于占用几个字节(byte)\n- byte 不受大小端的影响, 因为其只有一位\n- word, 和 dword 受大小端的影响\n- 一般的计算机使用的是小端序\n- 一个2位16进制是1字节\n\n## 技巧\n\n- IDA 中看到 word\n    - 16 进制显示时, 两两一组(4位16进制数)从右向左\n- IDA 中看到 dword\n    - 16 进制显示时, 四个一组(8位16进制数)从右向左\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3":{"title":"逆向wp-游戏过关","content":"# 逆向wp-游戏过关\n\nbugku 逆向第三题.\n\nhttp://gokoucat.ys168.com/\n\n## 定位关键函数\n\n通过对字符串 `done!!! the flag is` 进行交叉引用的定位, 找到关键函数的位置.\n\n```c\n...\n    if ( byte_532E28[0] == 1\n      \u0026\u0026 byte_532E28[1] == 1\n      \u0026\u0026 byte_532E28[2] == 1\n      \u0026\u0026 byte_532E28[3] == 1\n      \u0026\u0026 byte_532E28[4] == 1\n      \u0026\u0026 byte_532E28[5] == 1\n      \u0026\u0026 byte_532E28[6] == 1\n      \u0026\u0026 byte_532E28[7] == 1 )\n    {\n      sub_457AB4();  //关键函数\n    }\n```\n\n## 分析函数\n\n函数内部是对已有的数据进行处理并输出\n\n## 控制程序流程\n\n一种方法是, 利用 OD 调试, 然后控制跳转到 flag 处理函数, 直接输出:\n1. 打开od, 加载程序\n1. 在读取输入的地方设置断点:\n    ```c\n     while ( 1 )\n    {\n      s_print((int)\"input n,n(1-8)\\n\", v19);\n      sub_459418();\n      s_print((int)\"n=\", v16);\n      sub_4596D4(\"%d\", (unsigned int)\u0026v21);    //在这个位置设置断点\n      s_print((int)\"\\n\", v17);\n      if ( v21 \u003e= 0 \u0026\u0026 v21 \u003c= 8 )\n        break;\n      s_print((int)\"sorry,n error,try again\\n\", v19);\n    }\n    ```\n1.双击修改 `call` 的地址到 flag 处理函数\n1. 按 F8 执行修改过的指令\n1. 返回控制台窗口, 查看输出\n\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe":{"title":"逆向wp-Easy-CrackMe","content":"# 逆向wp-Easy-CrackMe\n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 黑盒测试\n\n- windows 窗体程序\n- 没什么输入限制\n- 错误返回字符串 `Incorrect Password`\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214007.png]]\n\n## 反编译\n\n程序是 32 位的.\n\n### 定位关键函数\n\n通过字符串 `Incorrect Password` 定位关键函数, F5 分析 C 代码.\n\n### 关键函数分析\n\n\u003e 变量名根据用途重命名过.\n\n```c\nint __cdecl sub_401080(HWND hDlg)\n{\n  int result; // eax@5\n  CHAR c1; // [sp+4h] [bp-64h]@1\n  char c2; // [sp+5h] [bp-63h]@1\n  char c3; // [sp+6h] [bp-62h]@2\n  char c4; // [sp+8h] [bp-60h]@3\n  __int16 v6; // [sp+65h] [bp-3h]@1\n  char v7; // [sp+67h] [bp-1h]@1\n\n  c1 = 0;\n  memset(\u0026c2, 0, 0x60u);\n  v6 = 0;\n  v7 = 0;\n  GetDlgItemTextA(hDlg, 1000, \u0026c1, 100);\n  if ( c2 == 'a' \u0026\u0026 !strncmp(\u0026c3, a5y, 2u) \u0026\u0026 !strcmp(\u0026c4, aR3versing) \u0026\u0026 c1 == 'E' )\n  {\n    MessageBoxA(hDlg, str_success, str_title1, 0x40u);\n    result = EndDialog(hDlg, 0);\n  }\n  else\n  {\n    result = MessageBoxA(hDlg, aIncorrectPassw, str_title1, 0x10u);\n  }\n  return result;\n}\n```\n\n发现 `if ( c2 == 'a' \u0026\u0026 !strncmp(\u0026c3, a5y, 2u) \u0026\u0026 !strcmp(\u0026c4, aR3versing) \u0026\u0026 c1 == 'E' )` 是关键.  \n\n条件真则密码通过, 密码为 `'E' + 'a' + \"5y\" + \"R3versing\"`\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214032.png]]","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen":{"title":"逆向wp-Easy-Keygen","content":"# 逆向wp-Easy-Keygen\n\n基础的异或加密题.\n\nhttp://gokoucat.ys168.com/\n\n## 题目要求\n\nFind the Name when the Serial is 5B134977135E7D13\n\n## 黑盒测试\n\n简单运行一下程序, 发现是 Windows 下的命令行程序, 要求输入 name 和 serial, 程序判断是否正确, 错误直接跳出.  \n\n## 反编译\n\n直接放 IDA 里反编译.\n\n### 定位函数\n\n通过搜索字符串 `Input Name:` 或`Input Serial:`, 查找交叉应用来定位主函数.\n\n### 分析函数\n\n这里没有什么坑, 找到主函数直接 F5 看 C 代码:  \n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signed int v3; // ebp@1\n  signed int i; // esi@1\n  int result; // eax@6\n  char v6; // [sp+Ch] [bp-130h]@1\n  char v7; // [sp+Dh] [bp-12Fh]@1\n  char v8; // [sp+Eh] [bp-12Eh]@1\n  char v9; // [sp+10h] [bp-12Ch]@1\n  char v10; // [sp+11h] [bp-12Bh]@1\n  __int16 v11; // [sp+71h] [bp-CBh]@1\n  char v12; // [sp+73h] [bp-C9h]@1\n  char v13; // [sp+74h] [bp-C8h]@1\n  char v14; // [sp+75h] [bp-C7h]@1\n  __int16 v15; // [sp+139h] [bp-3h]@1\n  char v16; // [sp+13Bh] [bp-1h]@1\n\n  v9 = 0;\n  v13 = 0;\n  memset(\u0026v10, 0, 0x60u);\n  v11 = 0;\n  v12 = 0;\n  memset(\u0026v14, 0, 0xC4u);\n  v15 = 0;\n  v16 = 0;\n  v6 = 16;\n  v7 = 32;\n  v8 = 48;\n  sub_4011B9(aInputName);\n  scanf(aS, \u0026v9);\n  v3 = 0;\n  for ( i = 0; v3 \u003c (signed int)strlen(\u0026v9); ++i )\n  {\n    if ( i \u003e= 3 )\n      i = 0;\n    sprintf(\u0026v13, aS02x, \u0026v13, *(\u0026v9 + v3++) ^ *(\u0026v6 + i));\n  }\n  memset(\u0026v9, 0, 0x64u);\n  sub_4011B9(aInputSerial);\n  scanf(aS, \u0026v9);\n  if ( !strcmp(\u0026v9, \u0026v13) )\n  {\n    sub_4011B9(aCorrect);\n    result = 0;\n  }\n  else\n  {\n    sub_4011B9(aWrong);\n    result = 0;\n  }\n  return result;\n}\n```\n\n#### 函数流程\n\n1. 初始化字符串变量\n1. 读入第一次输入\n1. 循环遍历输入的每一个字符\n    1. 将字符的 ASCII 数值与16, 32, 48 中的一个异或, key 的使用为 3 次一循环\n    1. 结果储存为 16 进制, 不足 2 位则加入前导 0\n1. 通过 `sprintf` 函数增量写入变量 v13 中\n1. 读入第二次输入\n1. 将 v13 的结果与输入比较, 一致则通过\n\n#### 加密算法分析\n\n函数通过一次 for 循环, 来遍历输入字符串的每一个字符, 通过 sprintf 格式化输入, 将按位异或的结果增量存入 v13 变量中.  \n这里我们分析一下 `sprintf` 函数:  \n\n\u003e [参考文章](https://zh.cppreference.com/w/c/io/fprintf)  \n\n```c\nsprintf(\u0026v13, aS02x, \u0026v13, *(\u0026v9 + v3++) ^ *(\u0026v6 + i))\n```\n\n- 其中 aS02x 字符串的内容是 `%s%02x`, 指定格式化为字符串和 带前导 0 的 16 进制 2 位数\n- `%s` 存入当前(也就是上一次异或结果) v13 变量的内容, 第二个\n- `%02x` 存入 当前遍历字符与对应 KEY 异或的结果\n\n```c\nif ( i \u003e= 3 )\n      i = 0;\n```\n\n代表循环使用 3 个 KEY, 分别是16, 32, 48 (10进制表示).  \n\n#### 破解算法\n\n本题实际只是通过异或加密, 而异或运算的一个重要特点就是, 对一个数用同样的 KEY 异或 2 次, 会得到这个数本身.  \n破解的方法就变得简单了, 只要再写一遍异或算法就行, 这里用 python 来写:  \n\n```python\nserial = \"5B134977135E7D13\"  ## 要解密的注册码\nkey = [16, 32, 48]           ## 异或用到的 key\nname = \"\"                    ## 初始化\n\nfor i in range(len(serial) // 2):   \n    each_2char = serial[i*2:i*2+2]  ## 将注册码两两分组\n    name += chr(int(each_2char, 16) ^ key[i%3])  ## 异或运算\nprint(name)\n```\n\n注意, 加密算法保存的字符串格式为带前导 0 的 16 进制 2 位数, 所以反过来对注册码异或运算时, 要两两分组, 循环次数也要相应减半.  \n`key[i%3]` 中的 `i%3` 则是使 3 个 key 循环使用.  ","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re":{"title":"逆向wp-Easy-Re","content":"# 逆向wp-Easy-Re\n\nbugku 逆向第二题.\n\n## 定位关键函数\n\n通过 ida 反编译, 很容易定位关键函数, 本题结构十分简单:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  __int128 v5; // [esp+0h] [ebp-44h]\n  __int64 v6; // [esp+10h] [ebp-34h]\n  int v7; // [esp+18h] [ebp-2Ch]\n  __int16 v8; // [esp+1Ch] [ebp-28h]\n  char v9; // [esp+20h] [ebp-24h]\n\n  _mm_storeu_si128((__m128i *)\u0026v5, _mm_loadu_si128((const __m128i *)\u0026xmmword_413E34));  // \u0026xmmword_413E34 即被比较数据 flag\n  v7 = 0;\n  v6 = qword_413E44;\n  v8 = 0;\n  printf(\"欢迎来到DUTCTF呦\\n\");\n  printf(\"这是一道很可爱很简单的逆向题呦\\n\");\n  printf(\"输入flag吧:\");\n  scanf(\"%s\", \u0026v9);\n  v3 = strcmp((const char *)\u0026v5, \u0026v9);  // 将输入与已有数据进行比较, \n  if ( v3 )\n    v3 = -(v3 \u003c 0) | 1;\n  if ( v3 )\n    printf(aFlag_0);\n  else\n    printf((const char *)\u0026unk_413E90);\n  system(\"pause\");\n  return 0;\n}\n```\n\n## 解析字符串\n\n对 `\u0026xmmword_413E34` 位置的数据进行分析, 发现此处就是 flag 的逆序存储, 直接右键显示为 字符, 然后手工反向输入即可.\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214345.png]]\n\n## 借助 python 解码\n\n\u003e python 3\n\n将数据复制出来, 放到python 3 里解码:\n\n```py\nimport binascii\n\na = '7D465443545544'    ## 逆序所以后一段在前\nb = binascii.a2b_hex(a)    ## 16 进制转为字符串\nc = '3074656D30633165577B465443545544'\nb += binascii.a2b_hex(c)    ## 16 进制转为字符串\nstr_list = list(b)    ## 将字符串转为数组\nstr_list.reverse()    ## 对数组逆序\n\nfor i in str_list:     ## 遍历输出数组, 以 chr 格式\n    print(chr(i), end=\"\")\n```","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe":{"title":"逆向wp-Easy-UnpackMe","content":"\n# 逆向wp-Easy-UnpackMe\n\n脱壳入门题, 找程序 EOP (入口点).\n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 题目要求\n\nFind the OEP, ex) 00401000\n\n## 黑盒测试\n\n双击打开, 是一个空白的 Windows 窗体程序, 没什么特别的.\n\n## OD 调试\n\n通过使用 OD 动态调试, 寻找程序的 EOP, 使用的方法是单步跟踪.\n\n### 单步跟踪\n\n\u003e [参考视频](https://www.bilibili.com/video/av19570153)\n\n- 程序载入 OD 后即开始单步步过 (F8) 调试\n- 遇到向下跳转的一律执行\n- 遇到向上跳转的一律不执行\n    - 选中下一条指令\n    - 按 F4 执行到选中位置\n    - 或者在下一条指令处下断点, 再继续程序, 到达断点后删除断点 (不常用)\n\n- 直到遇到地址跳跃幅度很大的地址\n\n找到这样的地址, 基本就是程序的 OEP 了, 注意在 OD 中, 红色的线代表跳转已经实现, 绿色的线代表跳转未实现.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214517.png]]\n\n图中 jmp 本身的地址是 `0040A1FB`, 而目标地址是 `00401150`, 地址跨度较大, 可以判定 `00401150` 就是 EOP 地址.  \n\n后续则是脱壳步骤, 本题不涉及脱壳操作, 只用找 EOP 地址, 到此结束\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100":{"title":"逆向wp-Reverse-100","content":"# 逆向wp-Reverse-100\n\n[杭电 CTF 平台逆向第四题.](http://sec.hdu.edu.cn/question/reverse/5789?sort=default)\n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 定位关键函数\n\n老套路, string 查找, 不多 BB.\n\n## 解析函数\n\n这个函数比较简单, key 和 判断流程在一个简单的函数中直接展示:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signed int i; // edi\n  char s_input; // [esp+10h] [ebp-104h]\n  char Dst; // [esp+11h] [ebp-103h]\n\n  s_input = 0;\n  memset(\u0026Dst, 0, 0xFFu);\n  printf(\"please input ns-ctf password: \");\n  scanf_s(\"%s\", \u0026s_input);\n  for ( i = 1; strncmp(\"nsF0cuS!x01\", \u0026s_input, 0xBu); ++i )\n  {\n    printf(\"try again!\\n\");\n    memset(\u0026s_input, 0, 0x100u);\n    printf(\"please input ns-ctf password: \");\n    scanf_s(\"%s\", \u0026s_input);\n  }\n  dword_403368 = 1;\n  if ( \u0026s_input + strlen(\u0026s_input) + 1 != \u0026Dst )\n  {\n    if ( i \u003e 3 )\n    {\n      sub_401000();\n      return 0;\n    }\n    printf(\"flag:{NSCTF_md5065ca\u003e01??ab7e0f4\u003e\u003ea701c\u003ecd17340}\");\n  }\n  return 0;\n}\n```\n\n- 函数利用 for 里的语句循环读入字符串\n- 字符串与 `nsF0cuS!x01` 比较, 相同则通过\n- 如果 `i \u003c= 3`, 返回的 flag 是未经处理的错误答案\n\n## 作答\n\n对策十分简单, 故意错误输入3次, 第四次输入 `nsF0cuS!x01` 即可\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215255.png]]\n\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2":{"title":"逆向wp-WannaLOL2","content":"\n# 逆向wp-WannaLOL2\n\n逆向入门题.\n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 黑盒测试\n\n拿到题目第一步, 就是运行软件进行测试\n- 判断软件平台\n- 观察输入限制\n- 观察输出信息\n\n本题是一道 Windows 平台下的窗体程序, 任意输入内容进行测试:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215724.png]]\n\n随意输入后, 发现程序对输入的内容和长度没有做限制, 输入不通过时返回字符串 `error !`  \n返回错的的字符串就是定位关键函数的一个突破点.  \n\n## 反编译\n\n使用 IDA 软件对程序进行反编译.  \n\n```\n无法确认程序位数时, 统一先用 X86 的 IDA 打开, 观察是否报错来确定是多少位的程序.\n```\n\n### IDA 视图配置\n\n- 打开机器码显示\n- 打开 16 进制视图 (Hex-View)\n- 打开字符串视图 (Strings windows)\n\n### 定位关键函数\n\n通过输出字符串 `error !` 定位程序的关键函数.\n\n#### 搜索字符串定位\n\n1. 在 strings windows 中按 ctrl + F 搜索字符串 `error !`\n1. 双击结果中匹配的内容, 跳转到对应的数据位置\n\n#### 定位字符串引用位置\n\n光标放在字符串的变量名处, 按 x 调出交叉应用窗口, 双击条目跳转到对应函数  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215738.png]]\n\n引用位置:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215748.png]]\n\n### 花指令\n\n#### 识别花指令\n\n在关键函数处按 F5 发现无法转换成 C 代码, 判断函数中存在花指令.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215712.png]]\n\n这里是一种最基本的花指令类型, 文章 [代码混淆／程序保护（对抗反汇编）原理与实践](https://blog.csdn.net/pianogirl123/article/details/53871397) 介绍了基础的代码混淆知识, 可以扩展阅读.  \n\n仔细分析本题的花指令:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215802.png]]\n\n第一和第二条的 `jz` 和 `jnz` 都跳转到了同一个地址, 那么代表程序真正执行起来, 无论如何都会跳转到指向的 `loc_401262+1` 位置.  \n再观察 `loc_401262` 附近, 机器码是 `E8 66 B8 08 00`, 查询机器码对应的汇编指令, `E8` 值 `CALL`, 这样, IDA 错误的认为此处有 `CALL` 指令, 且后续的偏移量是一个无效的地址. 而程序执行时, 实际跳过了 `E8`.  \n\n#### 处理花指令\n\n本题的花指令有两种方法去除, 本质是让 IDA 不识别到 `E8` ([[3-计算机科学/3-操作系统/Linux/call|CALL]]).  \n\n##### 替换指令为 `90`\n\n`90` 机器码代表不执行任何动作, 将 `E8` 替换为 `90` 即可让 IDA 正确识别函数.  \n\n光标定位到 `E8` 位置, 切换到 16 进制视图, 按 F2 开启编辑模式, 将 `E8` 改为 `90`, 再按 F2 保存更改.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/flower3.gif]]\n\n##### 将花指令标记为 db\n\n光标定位到 `E8` 位置, 按 U (undefine), 选中下一个机器码 `66`, 按 C (code).  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/flower4.gif]]\n\n#### 让 IDA 重新识别函数\n\n将整个函数选中, 按 P 重新识别, 此时可以按 F5 转换为 C 代码了.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/flower5.gif]]\n\n### 主函数分析\n\nIDA 生成的 C 代码如下:  \n\n```c\nint sub_4011F4()\n{\n  double v0; // st7@8\n  double v1; // st6@8\n  const CHAR *v3; // [sp-Ch] [bp-28h]@12\n  const CHAR *v4; // [sp-8h] [bp-24h]@11\n  CHAR String; // [sp+0h] [bp-1Ch]@1\n  char v6; // [sp+1h] [bp-1Bh]@3\n  char v7; // [sp+2h] [bp-1Ah]@4\n  char v8; // [sp+3h] [bp-19h]@5\n  int v9; // [sp+18h] [bp-4h]@8\n\n  GetDlgItemTextA(hDlg, 1001, \u0026String, 21);\n  Sleep(0x1F4u);\n  if ( strlen(\u0026String) != 4 || String == 48 || v6 == 48 || v7 == 48 || v8 == 48 || String != 49 || v6 != 53 )\n  {\n    v4 = Caption;\nLABEL_14:\n    v3 = Text;\n    return MessageBoxA(hWnd, v3, v4, 0);\n  }\n  v9 = v7 - 48;\n  v0 = (double)v9;\n  v9 = String - 48;\n  v1 = (double)v9;\n  v9 = v8 - 48;\n  *(float *)\u0026v9 = (v0 - v1 / (double)5) * (double)v9 * 16.0;\n  if ( v8 != 48 \u0026\u0026 v8 == 48 )\n    JUMPOUT(unk_4012AA);\n  v4 = aCrackme2017Ctf;\n  if ( *(float *)\u0026v9 != 384.0 )\n    goto LABEL_14;\n  v3 = aRegistrationSu;\n  return MessageBoxA(hWnd, v3, v4, 0);\n}\n```\n\n#### 流程分析\n\n分析代码, 可知程序通过对字符串数组 String, 也就是输入的内容进行条件比较, 再输出结果.  \n其中 `Caption` 和 `aCrackme2017Ctf` 的内容是输出窗体的标题, `Test` 的内容为返回的 error 字符串, `aRegistrationSu` 的内容为输入内容正确回显的字符串.  \n程序经过两次 if 判断, 来决定回显 error 还是 success:  \n\n```c\nif ( strlen(\u0026String) != 4 || String == 48 || v6 == 48 || v7 == 48 || v8 == 48 || String != 49 || v6 != 53 )\n```\n\n为假, 且\n\n```c\nif ( v8 != 48 \u0026\u0026 v8 == 48 )\n```\n\n为真, 则返回 success.\n\n#### 优化变量名\n\n在用 IDA 分析代码时, 自动生成的变量名往往不能很好的表达变量的含义, 此时就需要手动重命名变量, 光标定位到对应变量后按 N 即可.  \n对于部分数据, 可以右键转化为不同的显示方式, 如 48 重新显示为 字符 '0'.  \n重新定义过变量名后的代码如下:  \n\n其中 c1-c4 是输入字符串的 4 位字符\n\n```c\nint sub_4011F4()\n{\n  double v0; // st7@8\n  double v1; // st6@8\n  const CHAR *v3; // [sp-Ch] [bp-28h]@12\n  const CHAR *v4; // [sp-8h] [bp-24h]@11\n  CHAR c1; // [sp+0h] [bp-1Ch]@1\n  char c2; // [sp+1h] [bp-1Bh]@3\n  char c3; // [sp+2h] [bp-1Ah]@4\n  char c4; // [sp+3h] [bp-19h]@5\n  int temp; // [sp+18h] [bp-4h]@8\n\n  GetDlgItemTextA(hDlg, 1001, \u0026c1, 21);\n  Sleep(0x1F4u);\n  if ( strlen(\u0026c1) != 4 || c1 == '0' || c2 == '0' || c3 == '0' || c4 == '0' || c1 != '1' || c2 != '5' )\n  {\n    v4 = str_title1;\nLABEL_14:\n    v3 = str_error;\n    return MessageBoxA(hWnd, v3, v4, 0);\n  }\n  temp = c3 - '0';\n  v0 = (double)temp;\n  temp = c1 - '0';\n  v1 = (double)temp;\n  temp = c4 - '0';\n  *(float *)\u0026temp = (v0 - v1 / (double)5) * (double)temp * 16.0;\n  if ( c4 != '0' \u0026\u0026 c4 == '0' )\n    JUMPOUT(unk_4012AA);\n  v4 = str_title2;\n  if ( *(float *)\u0026temp != 384.0 )\n    goto LABEL_14;\n  v3 = str_success;\n  return MessageBoxA(hWnd, v3, v4, 0);\n}\n```\n\n#### 主要语句分析\n\n##### 第一处 if\n\n```c\nif ( strlen(\u0026c1) != 4 || c1 == '0' || c2 == '0' || c3 == '0' || c4 == '0' || c1 != '1' || c2 != '5' )\n```\n\n解释一下:  \n\n```\n如果 (字符长度不等于4 或 第一个字符是0 或 第二个字符是0 或 第三个字符是0 或 第四个字符是0 或第一个字符不是1 或 第二个字符不是 5)\n{\n    返回 error\n}\n```\n\n换句话说, 输入的字符串要为 4 个字符长度, 各字符不能是 '0', 第一个字符是 '1', 第二个字符是 '5'.\n\n##### 第二处 if\n\n此时, 我们知道:  \n\n```c\nc1 = '1'\nc2 = '5'\n```\n\n还需要解出 c3 和 c4 的值, 即可. 分析第二处 if 前后的内容:  \n\n```c\ntemp = c3 - '0';\n  v0 = (double)temp;  // v0 = (double)c3\n  temp = c1 - '0';\n  v1 = (double)temp;  // v1 = 1\n  temp = c4 - '0';   // temp = (int)c4\n  *(float *)\u0026temp = (v0 - v1 / (double)5) * (double)temp * 16.0;\n  if ( *(float *)\u0026temp != 384.0 )\n    goto LABEL_14;\n```\n\n可知, `(v0 - v1 / (double)5) * (double)temp * 16.0` 的值等于 384 时, 可以返回 success. 其中 `v0` 是 `c3` 字符内容的浮点表示, `v1` 值是 1, `temp` 是 `c4` 内容的整数表示, 分别用 x 和 y 代替, 得到二元一次方程:  \n\n$$(x - 1 / 5) \\times y \\times 16 = 384$$\n\n化简一下后:  \n\n$$(x - 1 / 5) \\times y = 24$$\n\n#### 解方程\n\n用 python 或其他方式, 对二元一次方程求解:  \n\n```python\nfor x in range(10):\n    for y in range(10):\n        if (x - 1 / 5) * y == 24:\n            print(x,y)\n```\n\n解得 x 和 y 均为 5.  整个输入的字符串为1555.  输入求证:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917220053.png]]\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice":{"title":"逆向wp-ebCTF-Teaser-BIN100-Dice","content":"\n# 逆向wp-ebCTF-Teaser-BIN100-Dice\n\n[杭电 CTF 平台逆向第一题.](http://sec.hdu.edu.cn/question/reverse/5780?sort=default)\n\nhttp://gokoucat.ys168.com/\n\n## 定位关键函数\n\n- 使用 IDA 字符串搜索\n- 定位回显字符串被交叉引用的位置\n\n得到关键函数中的重要片段如下: \n\n```c++\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n\n  ......\n  \n  v9 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n         (int)\u0026std::cout,\n         \"[*] You will first need to throw a three, press enter to throw a dice!\");\n  std::ostream::operator\u003c\u003c(v9, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e);\n  std::getline\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e(\u0026std::cin, \u0026v83);\n  v80 = time(0);  // 获取系统时间\n  rand();    // 产生随机数\n  v82 = 3;\n\n......\n\n  if ( v82 == 3 )     // 第一个为 3\n  {\n    fctx.call_site = 1;\n    v10 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((int)\u0026std::cout, \"[*] You rolled a three! Good!\");\n   \n......\n\n    v17 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n            (int)\u0026std::cout,\n            \"[*] Next you will need to throw a one, press enter to throw a dice!\");\n\n    v80 = time(0);\n    rand();\n  \n......\n\n    if ( v82 == 1 )    // 第二个是1\n    {\n      fctx.call_site = 1;\n      v18 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((int)\u0026std::cout, \"[*] You rolled a one! Very nice!\");\n      \n......\n\n      v25 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n              (int)\u0026std::cout,\n              \"[*] Next you will need to throw another three, press enter to throw a dice!\");\n\n      v80 = time(0);\n      rand();\n      \n......\n\n      if ( v82 == 3 )  // 第三个是3\n      {\n        fctx.call_site = 1;\n        v26 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((int)\u0026std::cout, \"[*] You rolled a three! Awesome!\");\n       \n......\n\n        v33 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n                (int)\u0026std::cout,\n                \"[*] Throw another three for me now, press enter to throw a dice!\");\n\n        v80 = time(0);\n        rand();\n        \n......\n\n        if ( v82 == 3 )  // 第四个是3\n        {\n\n......\n\n          v42 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n                  (int)\u0026std::cout,\n                  \"[*] The last character you need to roll is a seven....  (o_O)  Press enter to throw a dice!\");\n\n          v80 = time(0);\n          \n......\n\n          if ( v82 == 7 )   //第五个是7\n          {\n            fctx.call_site = 1;\n            v43 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n                    (int)\u0026std::cout,\n                    \"[*] You rolled a seven, with a six sided dice! How awesome are you?!\");\n\n......\n\n            fctx.call_site = 1;\n            if ( std::string::find((std::string *)\u0026v84, \"ebCTF\", 0) == -1 )\n            {\n              fctx.call_site = 1;\n              v59 = std::ostream::operator\u003c\u003c(\u0026std::cout, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e);\n              v60 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n                      v59,\n                      \"[!] It seems you did something wrong :( No flag for you.\");\n              \n......\n\n            }\n            else\n            {\n              v55 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\n                      (int)\u0026std::cout,\n                      \"[*] You rolled 3-1-3-3-7, what does that make you? ELEET! \\\\o/\");    //这里也可以得知过关顺序\n              std::ostream::operator\u003c\u003c(v55, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e);\n              v56 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((int)\u0026std::cout, \"[*] Nice job, here is the flag: \");\n              \n......\n\n            }\n          }\n         \n......\n\n}\n```\n\n## 分析函数\n\n- 函数通过 rand() 函数产生随机数\n- 通过随机数投掷骰子\n- 骰子的顺序为 3-1-3-3-7 则过关返回 flag\n\n## 调试程序\n\n使用 OD 调试程序, 这里复习一下 OD 的使用:\n- 键入 bp xxx 则在 xxx位置下断点\n- F9 为继续运行到断点处\n- F8 为单步步过\n- F7 为单步步入\n- F4 为运行到光标处\n- F2 为在光标位置切换断点\n- 双击汇编指令或按空格可修改指令\n- 双击寄存器可修改寄存器数据\n- 双击栈后空格可修改栈中数据\n\n### 修改寄存器尝试过关\n\n因为每次都是随机产生数字, 而且将处理完的数据保存在 `EAX` 寄存器用于投掷骰子, 那么可以修改 `EAX` 内容来实现精准投掷.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220918204747.png]]\n\n- 将 EAX 的数字分别修改为 3, 1, 3, 3, 操作重复 4 次即可\n- 此时发现, 第五个 7 不是通过寄存器来取值的, 而是通过栈取值\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220918204801.png]]\n\n- 观察后续代码, 发现有大量对栈 [ebp-0x5c] 位置的 cmp (比较) 操作\n- 可以大胆猜测程序用 7 对 [ebp-0x5c] 比较, 真则投掷出 7 点\n- 此时的 ebp 为 `0028FEC8`\n- [ebp-0x5c] 则为 `0028FE6C`\n- 修改此处栈值为 7\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220918204815.png]]\n\n继续执行程序, 确实投掷出了 7 点, 但是程序似乎还有一个检测机制, 阻止了我们获取 flag.  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220918204839.png]]\n\n### 利用 IDA 修改程序\n\n#### 思路\n\n- 回想程序的代码, 调用的 `time()` 函数\n- 大胆猜测, 程序应该是利用各处 `time()` 获取的系统时间, 来检测程序是不是在被调试.\n- 因此, 可用 IDA 修改程序指令, 来让程序一次通过.\n\n在 OD 调试的时候, 记录下 5 次投掷的位置:\n\n```\n00401830  --\u003e 3\n00401B6E  --\u003e 1\n00401EAA  --\u003e 3\n004021DA  --\u003e 3\n0040254E  --\u003e 7\n```\n\nIDA 中的操作:\n- 按 G 可打开地址跳转窗口\n- 修改: Edit -- Patch program -- Change byte...\n- 应用修改到文件: Edit -- Patch program -- Apply patches to input file...\n- 主要要用 90 (nop) 来填充剩余空间 (00也可以)\n\n#### 操作细节\n\n- 这里我们将取值部分的操作修改为直接为 eax 赋目标数值, 同时对 ecx 赋值 [目标数值 - 1] 的值\n- 第五次则是对 [ebp-0x5c] 处赋值 7\n\n可以利用网络或其他工具, 或者是 OD (OD 可以直接编辑汇编代码, 然后观察对应机器码即可), 得到目标机器码:  \n\n```\nmov ecx, [num]   --\u003e   B9 [num] 00 00 00\nmov eax, [num]   --\u003e   B8 [num] 00 00 00\n例如: mov ecx, 2 --\u003e  B9 02 00 00 00\n\nmov [ebp+var_5C], 7  --\u003e  C7 45 A4 07 00 00 00\n```\n\n前 4 次修改前:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214627.png]]\n\n前 4 次修改后:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214643.png]]\n\n第 5 次修改前:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214657.png]]\n\n第 5 次修改后:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214710.png]]\n\nApply patches to input file 后即大功告成.\n\n## 执行结果\n\n值得注意的是, 程序最后运行结束会直接关闭, 所以我们要先打开 cmd, 再用 cmd 打开程序:\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214722.png]]\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead":{"title":"逆向wp-keylead","content":"# 逆向wp-keylead\n\n[杭电 CTF 平台逆向第二题.](http://sec.hdu.edu.cn/question/reverse/5783?sort=default)\n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 文件分析\n\n通过在 lunux 环境下, 使用 `file keylead` 发现是一个压缩文件, 解压后得到可执行文件.\n\n```shell\nfile keylead\n\nkeylead: XZ compressed data\n```\n\n## 函数分析\n\n通过字符串定位的方法, 找到主函数.\n\n### 主函数\n\n```c\nsigned __int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  unsigned int v3; // eax\n  unsigned int i_rand_n1; // ST14_4\n  signed __int64 result; // rax\n  unsigned int i_rand_n5; // [rsp+4h] [rbp-1Ch]\n  unsigned int i_rand_n4; // [rsp+8h] [rbp-18h]\n  unsigned int i_rand_n3; // [rsp+Ch] [rbp-14h]\n  unsigned int i_rand_n2; // [rsp+10h] [rbp-10h]\n  int start_time; // [rsp+18h] [rbp-8h]\n\n  puts(\"hi all ----------------------\");\n  puts(\"Welcome to dice game!\");\n  puts(\"You have to roll 5 dices and get 3, 1, 3, 3, 7 in order.\");\n  puts(\"Press enter to roll.\");\n  getchar();\n  v3 = time(0LL);\n  srand(v3);\n  start_time = time(0LL);                       // 获取基准时间\n  i_rand_n1 = rand() % 6 + 1;\n  i_rand_n2 = rand() % 6 + 1;\n  i_rand_n3 = rand() % 6 + 1;\n  i_rand_n4 = rand() % 6 + 1;\n  i_rand_n5 = rand() % 6 + 1;\n  printf(\"You rolled %d, %d, %d, %d, %d.\\n\", i_rand_n1, i_rand_n2, i_rand_n3, i_rand_n4, i_rand_n5);\n  if ( i_rand_n1 != 3 )\n    goto LABEL_20;\n  if ( time(0LL) - start_time \u003e 2 )             // 超时则失败, 估计时防调试的手段\n  {\n    puts(\"No cheat!\");\n    return 0xFFFFFFFFLL;\n  }\n  if ( i_rand_n2 != 1 )\n    goto LABEL_20;\n  if ( time(0LL) - start_time \u003e 2 )\n  {\n    puts(\"No cheat!\");\n    return 0xFFFFFFFFLL;\n  }\n  if ( i_rand_n3 != 3 )\n    goto LABEL_20;\n  if ( time(0LL) - start_time \u003e 2 )\n  {\n    puts(\"No cheat!\");\n    return 0xFFFFFFFFLL;\n  }\n  if ( i_rand_n4 != 3 )\n    goto LABEL_20;\n  if ( time(0LL) - start_time \u003e 2 )\n  {\n    puts(\"No cheat!\");\n    return 0xFFFFFFFFLL;\n  }\n  if ( i_rand_n5 != 7 )\n  {\nLABEL_20:\n    puts(\"You DID NOT roll as I said!\");\n    puts(\"Bye bye~\");\n    result = 0xFFFFFFFFLL;\n  }\n  else if ( time(0LL) - start_time \u003c= 2 )\n  {\n    puts(\"You rolled as I said! I'll give you the flag.\");\n    f_cal_flag();                               // 计算并返回flag的函数\n    result = 0LL;\n  }\n  else\n  {\n    puts(\"No cheat!\");\n    result = 0xFFFFFFFFLL;\n  }\n  return result;\n}\n```\n\n- 函数通过 `rand()`, 随机生成 5 个数字用于投掷骰子\n- 有防调试修改的手段\n- 结果为 31337 则调用 flag 生成的函数 `f_cal_flag()`\n\n### flag 生成函数\n\n尝试通过对 flag 生成函数进行还原, 得到flag, 复制代码后修改执行:\n\n```c\n#include\u003cstdio.h\u003e\n\nint main(void)\n{\n  int v0; // ST0C_4\n  int v1; // ST08_4\n  int v2; // ST0C_4\n  int v3; // ST0C_4\n  int v4; // ST08_4\n  int v5; // ST0C_4\n  int v6; // ST08_4\n  int v7; // [rsp+8h] [rbp-8h]\n  int v8; // [rsp+8h] [rbp-8h]\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+8h] [rbp-8h]\n  int v11; // [rsp+Ch] [rbp-4h]\n  int v12; // [rsp+Ch] [rbp-4h]\n  int v13; // [rsp+Ch] [rbp-4h]\n  int v14; // [rsp+Ch] [rbp-4h]\n  int v15; // [rsp+Ch] [rbp-4h]\n  int v16; // [rsp+Ch] [rbp-4h]\n\n  v11 = 0;\n  v7 = 0;\n  \nchar flag[] = \n{0x41,0x00,0x61,0x00,0x63,0x00,\n 0x62,0x00,0x65,0x00,0x66,0x00,\n 0x49,0x00,0x33,0x00,0x31,0x00,\n 0x30,0x00,0x53,0x00,0x32,0x00,\n 0x37,0x00,0x36,0x00,0x39,0x00,\n 0x38,0x00,0x7b,0x00,0x7d,0x00,};\n  \n  while ( v11 != 1 )\n  {\n    putchar(flag[14 * v11++]);\n    do\n    {\n      while ( v7 \u003c= 1 )\n        putchar(flag[20 * v11 - 8 * v7++]);\n      v1 = v7 + 1;\n      v2 = 3 * v11;\n      putchar(flag[2 * v2 + 11 + v1]);\n      v2 *= 5;\n      v8 = v1 - 1;\n      putchar(flag[2 * v2 + v8]);\n      v12 = v2 / 3;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\nLABEL_12:\n          if ( !v8 )\n          {\n            putchar(flag[2 * v12]);\n            v15 = v12 ^ 2;\n            while ( 2 )\n            {\n              for ( i = 1; i \u003c= 9; ++i )\n                putchar(flag[10 * (i % 2) + 3 + v15]);\n              v13 = v15 + 1;\nLABEL_44:\n              putchar(flag[v13 / 3]);\n              if ( i == 10 )\n              {\n                v13 += 2 * v13 + 13;\n                i = 19;\n                goto LABEL_33;\n              }\n              if ( i == 2 )\n              {\n                i = v13-- + 2;\n                goto LABEL_4;\n              }\n              if ( (unsigned int)(i - 22) \u003c= 0xA )\n              {\n                v14 = v13 - 3;\n                for ( j = i - v14; ; j = 8 )\n                {\nLABEL_58:\n                  putchar(flag[v14 + 1]);\n                  v16 = v14 + 1;\n                  if ( j == 11 )\n                  {\n                    v13 = (v16 + 14) / 2;\n                    i = 11 * (v13 / 6);\n                    goto LABEL_44;\n                  }\n                  if ( j != 13 )\n                    break;\n                  v12 = v16 + 8;\n                  v8 = 2;\nLABEL_51:\n                  while ( 2 )\n                  {\n                    putchar(flag[v12 - 10]);\n                    if ( v8 == v12 )\n                    {\n                      v4 = v8 + 2;\n                      v5 = v12 + 2;\n                      putchar(flag[v5 / 2 + v4 / 5]);\n                      i = v4 / 2;\n                      putchar(flag[i / 5 + v5]);\n                      v13 = v5 + i - 1 + v5;\n                      while ( 1 )\n                      {\nLABEL_33:\n                        putchar(flag[v13 - 19]);\n                        if ( i == 2 )\n                        {\n                          v3 = v13 + 1;\n                          putchar(flag[v3 / 2 - 3]);\n                          v13 = v3 / 5 + 2;\n                          i = 2;\n                          goto LABEL_44;\n                        }\n                        if ( i \u003c= 2 )\n                          break;\n                        if ( i == 10 )\n                        {\n                          v12 = v13 - 31;\n                          v8 = 9;\n                          goto LABEL_51;\n                        }\n                        if ( i != 19 )\n                          goto LABEL_44;\n                        i = 2;\n                      }\n                      if ( i == 1 )\n                      {\n                        v8 = 17;\n                        v12 = v13 % 5 - 17 + v13;\nLABEL_20:\n                        putchar(flag[v12 - v8 + 9]);\n                        v12 += ~v8++;\n                        continue;\n                      }\n                      goto LABEL_44;\n                    }\n                    break;\n                  }\n                  if ( v8 != 9 )\n                  {\n                    if ( v8 != 2 )\n                      goto LABEL_12;\n                    j = 2;\n                    v16 = v12 - 18;\nLABEL_64:\n                    v6 = 9 * j;\n                    putchar(flag[v16 / 2 + v6 + v6 % 10]);\n                    v11 = v16 + 1;\n                    v7 = v6 % 10;\n                    goto LABEL_21;\n                  }\n                  putchar(flag[v12 - 16]);\n                  v14 = v12 / 2;\n                }\n                if ( j == 8 )\n                {\n                  v15 = v16 + 1;\n                  i = 7;\n                  continue;\n                }\n                goto LABEL_64;\n              }\n              goto LABEL_4;\n            }\n          }\n          if ( v8 == 2 )\n            break;\n          if ( v12 == 7 )\n          {\n            putchar(flag[21 - v8]);\n            v13 = 49;\n            i = v8 / 3;\n            goto LABEL_33;\n          }\n          if ( v8 != 3 )\n            goto LABEL_20;\n          putchar(flag[2 * (v12 / 3)]);\n          v13 = v12 / 3;\n          i = 9;\n          do\n          {\n            while ( 1 )\n            {\n              if ( v13 == 10 )\n              {\n                putchar(flag[i + 8]);\n                v14 = 9;\n                j = i + 1;\n                goto LABEL_58;\n              }\n              if ( v13 == 11 )\n              {\n                putchar(flag[i / 7]);\n                v13 = i-- - 11;\n              }\nLABEL_4:\n              if ( i != 9 )\n                break;\n              putchar(flag[v13 * v13 + 7]);\n              v13 = v13 * v13 + 1;\n              i = 10;\n            }\n          }\n          while ( i != 13 );\n          putchar(flag[2 * v13 + 12]);\n          v8 = 3;\n          v12 = 3 * v13;\n        }\n        putchar(flag[3 * v12 + 1]);\n        v0 = v12 * v12;\n        putchar(flag[v0 - 15]);\n        v11 = v0 - 15;\n        v7 = 4;\n        putchar(flag[4]);\nLABEL_21:\n        if ( v7 != 4 )\n          break;\n        putchar(flag[v11 + 6]);\n        v12 = v11 - 3;\n        v8 = 3;\n      }\n    }\n    while ( v7 != 8 );\n    putchar(flag[2 * v11 + 32]);\n  }\n  \n  return 0;\n}\n```\n\n执行返回的结果为:  \n\n```\nASIS{1fc1089e328eaf737373737c882ca0b10fcfe6}\n```\n\n看似正确, 但实际上有错误, 对比答案并调试后发现, 59 行处多次循环, 导致 flag 中 7373 处多了.  \n这个问题暂时没有想明白.\n\n## 方法分析\n\n利用程序开始的调用逻辑, 直接执行 flag 生成函数.\n\n### 定位程序起始位置\n\n在左侧函数表双击定位到 start\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215125.png]]\n\n```\n参考1 [main() 函数在 Linux 上的启动过程分析 ](http://gokoucat.cn/2018/10/01/security/reverse/learning/main-function-startup-process-on-linux/)  \n参考2 [x86-64 框架下的参数传递](http://gokoucat.cn/2018/10/01/security/reverse/learning/64-calling-convention/)  \n```\n\n通过修改 `mov     rdi, offset main ; main` 指令的目标位置, 即可控制程序跳转到 flag 生成函数.\n\n### 函数位置记录\n\n- `mov     rdi, offset main` 在 `0x4005dd`\n- `f_cal_flag` 在 `0x4006b6`\n\n因此只要将 `mov     rdi, offset main` 修改为 `mov     rdi, 0x4006b6` 即可.  \n\n## 调试\n\n### gdb 操作复习\n\n- 开始调试 `gdb xxx`\n- 设置断点 `b *0x111111`\n- 查看断点: `i b`\n- 删除断点: `d xx`\n- 运行: `r`\n- 继续执行到断点: `c`\n- 查看寄存器: `i r` 或 `i registers`\n- 修改寄存器值: `set $REGISTER=VALUE`\n\n### 开始调试\n\n```sh\ngdb keylead            ## 进入调试环境\nb *0x4005dd            #设置断点\nr                      #运行程序\ni r                   #查看寄存器的值\nn                     #单步运行\ni r                   #查看寄存器的值\nset $rdi=0x4006b6    #设置 rdi寄存器的值\nc                    #继续运行程序\n```\n\n返回flag: `ASIS{1fc1089e328eaf737c882ca0b10fcfe6}`","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02":{"title":"逆向wp-reverse02","content":"# 逆向wp-reverse02\n\n[杭电 CTF 平台逆向第三题.](http://sec.hdu.edu.cn/question/reverse/5786?sort=default)  \n\n题目在网络对应目录中: http://gokoucat.ys168.com/\n\n## 定位函数\n程序时一个 win32 的窗口程序, 按钮是灰色的.  \n老套路, 根据字符串来定位函数.  \n\n这题可以找到一个内容是 `flag:{NSCTF_md57e0cad17016b0\u003e?45?f7c\u003e0\u003e4a\u003e1c3a0}` 的字符串, 直接提交错误, 看来没这么简单.  \n\n### 交叉引用\n\n对该字符串的交叉引用有两处, 分别分析发现其中一个应该为主要的函数:\n\n```c\nint __thiscall sub_401070(_BYTE *this)\n{\n  int v1; // edx\n  int v2; // esi\n  int result; // eax\n\n  if ( ((unsigned __int8)byte_403028 ^ 7) != *this\n    || ((unsigned __int8)byte_403027 ^ 7) != this[1]\n    || ((unsigned __int8)byte_403026 ^ 7) != this[2]\n    || ((unsigned __int8)byte_403025 ^ 7) != this[3]\n    || ((unsigned __int8)byte_403024 ^ 7) != this[4]\n    || ((unsigned __int8)byte_403023 ^ 7) != this[5]\n    || ((unsigned __int8)byte_403022 ^ 7) != this[6] )\n  {\n    v1 = dword_403380;\n    v2 = dword_403018;\n  }\n  else\n  {\n    v1 = dword_403380 + 2;\n    v2 = dword_403018 - 1;\n    dword_403380 += 2;\n    --dword_403018;\n  }\n  if ( ((unsigned __int8)byte_403021 ^ 0x33) == this[7]\n    \u0026\u0026 ((unsigned __int8)byte_403020 ^ 0x33) == this[8]\n    \u0026\u0026 ((unsigned __int8)byte_40301F ^ 0x33) == this[9]\n    \u0026\u0026 ((unsigned __int8)byte_40301E ^ 0x33) == this[10]\n    \u0026\u0026 ((unsigned __int8)byte_40301D ^ 0x33) == this[11]\n    \u0026\u0026 ((unsigned __int8)byte_40301C ^ 0x33) == this[12] )\n  {\n    --v1;\n    v2 += 2;\n    dword_403380 = v1;\n    dword_403018 = v2;\n  }\n  if ( v2 + v1 == 3 )\n    result = sub_401000();\n  else\n    result = MessageBoxA(0, \"flag:{NSCTF_md57e0cad17016b0\u003e?45?f7c\u003e0\u003e4a\u003e1c3a0}\", \"Flag\", 0);\n  dword_403018 = 1;\n  dword_403380 = 0;\n  return result;\n}\n```\n\n看来程序是对一串字符串做异或, 然后判断和输入的内容是否一致, 一致则返回处理过后的真正的 flag.\n\n## 解密\n\n众所周知, 重复两次异或, 就是原结果, 将上述代码中的内置字符拷贝出来, 再仿照其异或的过程进行解密:\n\n```python\nkey1 = [0x4e, 0x62, 0x57, 0x47, 0x39, 0x3b, 0x32]\nkey2 = [0x6a, 0x58, 0x6a, 0x46, 0x50, 0x4a]\nfor i in key1:\n    print(chr(i ^ 0x7), end=\"\")\nfor j in key2:\n    print(chr(j ^ 0x33), end=\"\")\n\n```\n\n输出结果为: `IeP@\u003e\u003c5YkYucy`\n\n## 灰色按钮\n\n程序的按钮是灰色的不可点击, 用灰色按钮克星等程序, 破解按钮.\n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215523.png]]\n\n具体的实现过程有待研究...  \n\n## 输出答案\n\n输入之前解密的 key `IeP@\u003e\u003c5YkYucy` 即可:  \n\n![[3-计算机科学/7-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215533.png]]","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/%E5%AE%89%E8%A3%85qemu":{"title":"安装qemu","content":"\n# 安装qemu\n\n```sh\nsudo apt-get install qemu \n#user mode,包含qemu-mips-static，qemu-mipsel-static,qemu-arm-static等\nsudo apt-get install qemu-user-static\n#system mode，包含qemu-system-mips，qemu-system-mipsel,qemu-system-arm等\nsudo apt-get install qemu-system\n```\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/busybox":{"title":"busybox","content":"\n# busybox\n\n一个集成了一百多个最常用linux命令和工具的软件。\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/firmadyne":{"title":"firmadyne","content":"\n# firmadyne\n\nFirmadyne是一款自动化和可裁剪的嵌入式Linux系统固件分析框架。它支持系统固件逆向QEMU嵌入式系统模拟执行。使用它模拟路由器固件执行路由器，然后可以基于模拟环境进行路由器漏洞挖掘、渗透攻防。\n\n## 组件\n\n- 修改过的便于防火墙程序执行的kernels (MIPS: [v2.6.32](https://github.com/firmadyne/kernel-v2.6.32),     ARM: [v4.1](https://github.com/firmadyne/kernel-v4.1), [v3.10](https://github.com/firmadyne/kernel-v3.10));  \n- 一个用户空间的 [NVRAM library](https://github.com/firmadyne/libnvram)，用于模拟NVRAM硬件;  \n- 一个固件提取器（[extractor](https://github.com/firmadyne/extractor)）， 用于提取嵌入式firmware固件的filesystem 和kernel;  \n- 一个小[console](https://github.com/firmadyne/console)应用，用于另启一个shell进行调试;  \n- 一个 [scraper](https://github.com/firmadyne/scraper)，用于下载 firmware固件（从 42+ 不同供应商）\n\n## 参考\n\n[(1条消息) 自动化固件逆向框架firmadyne使用详细教程_子曰小玖的博客-CSDN博客_firmadyne安装](https://blog.csdn.net/wxh0000mm/article/details/108443293)\n[firmadyne/firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware (github.com)](https://github.com/firmadyne/firmadyne)\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu%E8%BF%90%E8%A1%8Cmips%E7%A8%8B%E5%BA%8F":{"title":"qemu运行mips程序","content":"\n# qemu运行mips程序\n\n1. [[3-计算机科学/7-网络安全/二进制安全/IoT安全/安装qemu|安装qemu]]\n2. 拷贝[[3-计算机科学/7-网络安全/二进制安全/IoT安全/qemu-user-static|qemu-user-static]]到目标目录下：`cp /usr/bin/qemu-mips-static ./`。\n3. 运行mips程序(其中./bin/busybox为要执行的busybox)：`sudo chroot . ./qemu-mips-static ./bin/busybox`。\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu-user-static":{"title":"qemu-user-static","content":"\n# qemu-user-static\n\n一个用于利用当前操作系统来运行其它架构的一个仿真器。\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/squashfs":{"title":"squashfs","content":"\n# squashfs\n\nsquashfs 是一个高度压缩的只读文件系统，它可以将高达 2-3GB 的数据压缩到一个只有 700M 的文件中。当一个 Live CD 启动时，它将加载整个 Linux 系统环境。Live CD 所使用的正是这种高度压缩的只读 squashfs 文件系统，其中的 root 文件系统就被压缩存放在这个文件系统之中。\n\n\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/ubuntu2004%E4%B8%8B%E5%AE%89%E8%A3%85%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8C%85":{"title":"ubuntu2004下安装物联网固件分析工具包","content":"\n# ubuntu2004下安装物联网固件分析工具包\n\n## 基础环境\n\n系统：ubuntu2004 64位。\n代理工具：proxychains4。\n宿主机网络加速软件开放端口用于给虚拟机代理。\n\n## 安装流程\n\n1. 安装代理工具：`sudo apt install proxychains4`。\n2. 配置代理：`sudo vim /etc/proxychains4.conf`，将最后的代理服务器地址换成`socks5 宿主机Ip 代理端口`\n3. 克隆自动化分析工具包脚本项目：`git clone --recursive https://github.com/attify/firmware-analysis-toolkit.git`。\n4. 手动安装binwalk。\n5. 手动[[3-计算机科学/7-网络安全/二进制安全/IoT安全/安装qemu|安装qemu]]。\n6. 手动安装[[3-计算机科学/7-网络安全/二进制安全/IoT安全/firmadyne|firmadyne]]。\n7. 安装firmware-analysis-toolkit剩余部分。\n\n## 参考\n\n[路由器固件模拟环境搭建(超详细)_Tig3rHu的博客-CSDN博客_路由器环境搭建](https://blog.csdn.net/wuyou1995/article/details/105545581?spm=1001.2014.3001.5502)\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB":{"title":"栈迁移","content":"# 栈迁移\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB":{"title":"针对延迟绑定的攻击","content":"\n# 针对延迟绑定的攻击\n\n\u003e  2015 年的论文 “How the [[3-计算机科学/3-操作系统/Linux/ELF|ELF]] Ruined Christmas” 中提出的。\n\n强迫动态装载器解析请求的函数。\n\n![[z-oblib/z2-attachments/Pasted image 20220911020331.png]]\n![[z-oblib/z2-attachments/Pasted image 20220911020936.png]]\n\n\n- 图a中，因为动态转载器是从 `.dynamic` 段的 `DT_STRTAB` 条目中获得 `.dynstr` 段的地址的，而 `DT_STRTAB` 条目的位置已知，默认情况下也可写。所以攻击者能够改写 `DT_STRTAB` 条目的内容，欺骗动态装载器，让它以为 `.dynstr` 段在 `.bss` 段中，并在那里伪造一个假的[[3-计算机科学/3-操作系统/Linux/字符串表|字符串表]]。当它尝试解析 printf 时会使用不同的[[3-计算机科学/3-操作系统/Linux/基地址|基地址]]来寻找函数名，最终执行的是 execve。这种方式非常简单，但仅当二进制程序的 `.dynamic` 段可写时有效。\n- 图b中，我们已经知道 [[3-计算机科学/3-操作系统/Linux/_dl_runtime_resolve|_dl_runtime_resolve]] 的第二个参数是 Elf_Rel 条目在 `.rel.plt` 段中的偏移，动态装载器将这个值加上 `.rel.plt` 的基址来得到目标结构体的绝对位置。然后当传递给 `_dl_runtime_resolve` 的参数 `reloc_index` 超出了 `.rel.plt` 段，并最终落在 `.bss` 段中时，攻击者可以在该位置伪造了一个 `Elf_Rel` 结构，并填写 `r_offset` 的值为一个可写的内存地址来将解析后的函数地址写在那里，同理 `r_info` 也会是一个将动态装载器导向到攻击者控制内存的下标。这个下标就指向一个位于它后面的 `Elf_Sym` 结构，而 `Elf_Sym` 结构中的 `st_name` 同样超出了 `.dynsym` 段。这样这个符号就会包含一个相对于 `.dynstr` 地址足够大的偏移使其能够达到这个符号之后的一段内存，而那段内存里保存着这个将要调用的函数的名称。\n- 还记得我们前面说过的 GOT[1]，它是一个 link_map 类型的指针，其 `l_info` 域中有一个包含 `.dynmic` 段中所有条目构成的数组。动态链接器就是利用这些指针来定位[[3-计算机科学/3-操作系统/Linux/符号解析|符号解析]]过程中使用的对象的。通过覆盖这个 link_map 的一部分，就能够将 `l_info` 域中的 `DT_STRTAB` 条目指向一个特意制造的动态条目，那里则指向一个假的动态字符串表。\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE":{"title":"ubuntu环境配置","content":"\n# ubuntu环境配置\n\n```sh\n# apt换源\nsudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak\nsudo sed -i \"s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g\" /etc/apt/sources.list  \nsudo sed -i \"s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g\" /etc/apt/sources.list\nsudo apt update\n\n# pip 换源\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n\nsudo apt-get install git\n# git启用宿主机代理\ngit config --global https.proxy socks5://192.168.204.1:1080\ngit config --global https.proxy socks5://192.168.204.1:1080\n#git config --global --unset http.proxy\n#git config --global --unset https.proxy\n\nsudo apt-get update\n# sudo apt-get install python2.7-dev python-pip -y\npip install pwntools\n# echo 'export PATH=/usr/local/mongodb/bin:$PATH \u003e\u003e ~/.bashrc'\nsudo apt-get install libcapstone-dev -y\n\n# wpndbg 适合pwn\ncd ~/\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\ncd ~/\ngit clone https://github.com/scwuaptx/Pwngdb.git\ncp ~/Pwngdb/.gdbinit ~/\n\n# peda 适合逆向\ngit clone https://github.com/longld/peda.git ~/peda\necho \"source ~/peda/peda.py\" \u003e\u003e ~/.gdbinit\n\n# if not install pwndbg \u0026 pwngdb ? use howdays gdb\n# wget http://howdays.kr/public/gdb/setupdbg.sh\n# chmod 777 setupdbg.sh\n# ./setupdbg.sh\n\n# zsh\nsudo apt-get install zsh -y\nsudo chsh -s /usr/bin/zsh\nsudo sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\ngit clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n# ADD ~/.zshrc -\u003e (zsh-autosuggestions)\nsource ~/.zshrc\n\nsudo apt install ruby-full -y\ngem install one_gadget\n\nsudo pip install ropgadget -y\n\n# pwn端口转发本地部署工具\nsudo apt-get install socat\n\n# 32位环境\nsudo apt-get update  \nsudo apt-get purge libc6-dev  \nsudo apt-get install libc6-dev  \nsudo apt-get install libc6-dev-i386\n\n# sudo dpkg --add-architecture i386\n# sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 -y\n\n# z3\nsudo apt-get install z3\ngit clone https://github.com/Z3Prover/z3.git\ncd z3\ncd build\nmake\nsudo make install\n```\n\n## gdb插件切换\n\n```sh\n# 切换脚本\ntouch ~/.local/bin/gdbplugin\ncat \u003e ~/.local/bin/gdbplugin \u003c\u003c \\EOF\n#!/bin/bash\nfunction Mode_change {\n    name=$1\n    gdbinitfile=~/.gdbinit    #这个路径按照你的实际情况修改\n    peda=\"source ~/peda/peda.py\"   #这个路径按照你的实际情况修改\n    gef=\"source ~/.gdbinit-gef.py\"  #这个路径按照你的实际情况修改\n    pwndbg=\"source ~/Downloads/pwndbg/gdbinit.py\"\n\n    sign=$(cat $gdbinitfile | grep -n \"#this place is controled by user's shell\")\n           #此处上面的查找内容要和你自己的保持一致\n\n    pattern=\":#this place is controled by user's shell\"\n    number=${sign%$pattern}\n    location=$[number+2]\n\n    parameter_add=${location}i\n    parameter_del=${location}d\n\n    message=\"TEST\"\n\n    if [ $name -eq \"1\" ];then\n        sed -i \"$parameter_del\" $gdbinitfile\n        sed -i \"$parameter_add $peda\" $gdbinitfile\n        echo -e \"Please enjoy the peda!\\n\"\n    elif [ $name -eq \"2\" ];then\n        echo -e \"Please enjoy the gef!\\n\"\n        else\n        sed -i \"$parameter_del\" $gdbinitfile\n        sed -i \"$parameter_add $pwndbg\" $gdbinitfile\n        echo -e \"Please enjoy the pwndbg!\\n\"\n    fi\n\n}\n\necho -e \"Please choose one mode of GDB?\\n1.peda    2.gef    3.pwndbg\"\n\nread -p \"Input your choice:\" num\n\nif [ $num -eq \"1\" ];then\n    Mode_change $num\nelif [ $num -eq \"2\" ];then\n    Mode_change $num\nelif [ $num -eq \"3\" ];then\n    Mode_change $num\nelse\n    echo -e \"Error!\\nPleasse input right number!\"\nfi\n\ngdb $1 $2 $3 $4 $5 $6 $7 $8 $9\n\nEOF\n\nsudo chmod +x ~/.local/bin/gdbplugin\n```\n","lastmodified":"2023-01-23T15:37:51.77868077Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/suricata/%E5%85%A8%E5%B1%80%E5%91%8A%E8%AD%A6%E9%98%88%E5%80%BC":{"title":"全局告警阈值","content":"\n# 全局告警阈值\n\n## threshold\n\n覆盖规则警报频率。\n\n### 语法\n\n```sh\nthreshold gen_id \u003cgid\u003e, sig_id \u003csid\u003e, type \u003cthreshold|limit|both\u003e, track \u003cby_src|by_dst|by_rule|by_both\u003e, count \u003cN\u003e, seconds \u003cT\u003e\n```\n\n- threshold：规则将在匹配第n次时开始动作。\n- limit：在事件周期内最多发出n次警报。\n- both：设定的count和seconds同时应用于上面两个设置。\n\n## rate_filter\n\n过滤器在规则匹配时改变对应规则操作。\n\n### 语法\n\n```\nrate_filter: rate_filter gen_id \u003cgid\u003e, sig_id \u003csid\u003e, track \u003ctracker\u003e, count \u003cc\u003e, seconds \u003cs\u003e, new_action \u003caction\u003e, timeout \u003ctimeout\u003e\n```\n\n- gen_id：默认值1，如果rule中通过gen关键字设置过了，则应该为对应值。\n- sig_id：规则id，rule中用sid关键词设置。\n- track：\n    - `by_src` 和 `by_dst` 是否达到阈值按照ip地址分开计算。\n    - `by_rule` 是否达到阈值全局计算。\n- count：rate_filter启动前目标rule被匹配的次数。\n- seconds：count的统计周期，在seconds设定的周期内计数值达到count字段设置值，则启动rate_filter。\n- new_action：rate_filter被触发时应用的动作。\n    - alert\n    - drop\n    - pass\n    - reject\n- timeout：rate_filter每一次的活动秒数。\n\n### 用例\n\n对ssh端口的连接告警，某一ip在1分钟内连接超过10次，则在接下来5分钟内动作alert改为drop丢弃数据包。\n\nRule:\n\n```\nalert tcp any any -\u003e $MY_SSH_SERVER 22 (msg:\"Connection to SSH server\"; flow:to_server; flags:S,12; sid:888;)\n```\n\nRate filter:\n\n```\nrate_filter gen_id 1, sig_id 888, track by_src, count 10, seconds 60,  new_action drop, timeout 300\n```\n\n## suppress\n\n抑制器在规则匹配时，抑制针对规则或者网络的告警产生，但flowbit等动作仍然会执行。\n\n### 语法\n\n```\nsuppress gen_id \u003cgid\u003e, sig_id \u003csid\u003e\nsuppress gen_id \u003cgid\u003e, sig_id \u003csid\u003e, track \u003cby_src|by_dst|by_either\u003e, ip \u003cip|subnet|addressvar\u003e\n```\n\n### 用例\n\n规则2002087不再对209.132.180.67起反应\n\n```sh\nsuppress gen_id 1, sig_id 2002087, track by_src, ip 209.132.180.67\n```\n\n```sh\nsuppress gen_id 1, sig_id 2003614, track by_src, ip 217.110.97.128/25\nsuppress gen_id 1, sig_id 2003614, track by_src, ip [192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\nsuppress gen_id 1, sig_id 2003614, track by_src, ip $HOME_NET\nsuppress gen_id 1, sig_id 2003614, track by_either, ip 217.110.97.128/25\n```\n\n最后一条表示源地址或目的地址匹配217.110.97.128/25就抑制。\n\n## rule阈值和全局阈值\n\n### rule\n\n```sh\nalert tcp any any -\u003e any 25 (msg:\"ET POLICY Inbound Frequent Emails - Possible Spambot Inbound\"; \\\n     flow:established; content:\"mail from|3a|\"; nocase;                                          \\\n     threshold: type threshold, track by_src, count 10, seconds 60;                              \\\n     reference:url,doc.emergingthreats.net/2002087; classtype:misc-activity; sid:2002087; rev:10;)\n```\n\n60秒内匹配10次才会触发alert动作。\n\n### 全局\n\nsuppress可以应用于带有threshold/detection_filters的规则。\n\n```sh\nsuppress gen_id 1, sig_id 2002087, track by_src, ip 209.132.180.67\nsuppress gen_id 0, sig_id 0, track by_src, ip 209.132.180.67\nsuppress gen_id 1, sig_id 0, track by_src, ip 209.132.180.67\n```\n\n下面这句话会覆盖上面的规则，使得长期不会触发alert动作：\n\n```sh\nsuppress gen_id 1, sig_id 2002087\n```\n\n### ### Threshold/event_filter\n\n全局设置的thresholds and event_filters会覆盖掉rule上的设置，常用于默认规则不适用当前环境时对该规避进行重新设置。\n\n```sh\nthreshold gen_id 1, sig_id 2002087, type both, track by_src, count 3, seconds 5\nthreshold gen_id 1, sig_id 2002087, type threshold, track by_src, count 10, seconds 60\nthreshold gen_id 1, sig_id 2002087, type limit, track by_src, count 1, seconds 15\n```\n\n上述每一条都会用新的threshold值替代2002087 rule上的设置。\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/suricata/%E5%91%8A%E8%AD%A6%E9%98%88%E5%80%BC":{"title":"告警阈值","content":"\n# 告警阈值\n\n## threshold\n\n```shell\nthreshold: type \u003cthreshold|limit|both\u003e, track \u003cby_src|by_dst|by_rule|by_both\u003e, count \u003cN\u003e, seconds \u003cT\u003e\n```\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/suricata/suricata%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6":{"title":"suricata配置文件","content":"\n# suricata配置文件\n\n","lastmodified":"2023-01-23T15:37:51.806681024Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/7-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%AF%94%E8%B5%9Bwp/2023%E5%86%ACHWS":{"title":"2023冬HWS","content":"\n# 2023冬HWS\n\n## babyre\n\napk拖入jeb分析，入口点找到check()函数，一个简单加密+base64但是无法解出正确的答案。\n\n![[3-计算机科学/7-网络安全/比赛wp/z-attachments/Pasted image 20230109025910.png]]\n\n发现类b中有动态注入，分析代码发现会读取Assets的enc文件，异或后生成classes.dex文件:\n\n![[3-计算机科学/7-网络安全/比赛wp/z-attachments/Pasted image 20230109025921.png]]\n\n替换check()函数，按照流程提取出文件后逆向：\n\n![[3-计算机科学/7-网络安全/比赛wp/z-attachments/Pasted image 20230109025933.png]]\n\n是一个AES加密，再base64加密，逆向运算就能得到结果。\n\n### 代码\n\n```java\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\npublic class Test1 {\n    static void getFile() {\n        File inFile = new File(\"enc\");\n        File outFile = new File(\"classes.dex\");\n        byte[] encBytes;\n        try (InputStream inputStream = new FileInputStream(inFile)) {\n            encBytes = new byte[inputStream.available()];\n            inputStream.read(encBytes);\n            for (int i=0; i\u003cencBytes.length; ++i) {\n                encBytes[i] = (byte)(encBytes[i] ^ 52);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        try (FileOutputStream fileOutputStream = new FileOutputStream(outFile)) {\n            fileOutputStream.write(encBytes);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static String encode(String input) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(\"FV8aOaQiak6txP09\".getBytes(StandardCharsets.UTF_8), \"AES\"), new IvParameterSpec(\"2Aq7SR5268ZzbouE\".getBytes()));\n        return Base64.getEncoder().encodeToString(cipher.doFinal(input.getBytes()));\n    }\n\n    static String decode(String input) throws Exception {\n        byte[] base64decodedBytes = Base64.getDecoder().decode(input);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(\"FV8aOaQiak6txP09\".getBytes(StandardCharsets.UTF_8), \"AES\"), new IvParameterSpec(\"2Aq7SR5268ZzbouE\".getBytes()));\n        byte[] resultBytes = cipher.doFinal(base64decodedBytes);\n        return new String(resultBytes);\n    }\n\n    public static void main(String[] args) throws Exception {\n        getFile();\n        System.out.println(decode(\"9Kz3YlSdD3lB9KoxeKxXQT4YOEqJTVIuNU+IjW4iFQzjpU+NikF/UqCOsL+1g4eA\"));\n    }\n}\n```\n\n## Numbers Game\n\npython的随机bytes超过32位实际上是多次调用`random.getrandbits(32)`，例如题目中的`random.getrandbits(128)`则是调用4次`random.getrandbits(32)`。\n\n题目给了624组32bytes的随机数结果，正好是python采用的随机算法MT19937的空间大小，通过已经产生624组随机数预测之后产生的随机数。\n\n但是题目挖空的是前12组32位随机数，需要通过逆向twist过程来由后面的state推导前面的state。\n\n则首先计算后面的state，再通过逆向的twist算法来得到前12个state值，再设置到random上，恢复现场后重新调用随机数生成即可。\n\n参考文章：[浅析MT19937伪随机数生成算法-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/205861#h2-5)\n\n### 代码\n\n```py\nimport hashlib  \nimport random  \nfrom random import Random  \nfrom randcrack import RandCrack  \n  \n  \ndef test_random():  \n    r = random.getrandbits(128)  \n    print(r)  \n    hr = hex(r)[2:].zfill(32)  \n    print(hr)  \n    print(int(hr, 16))  \n  \n  \ndef invert_right(m, l, val=''):  \n    length = 32  \n    mx = 0xffffffff  \n    if val == '':  \n        val = mx  \n    i, res = 0, 0  \n    while i * l \u003c length:  \n        mask = (mx \u003c\u003c (length - l) \u0026 mx) \u003e\u003e i * l  \n        tmp = m \u0026 mask  \n        m = m ^ tmp \u003e\u003e l \u0026 val  \n        res += tmp  \n        i += 1  \n    return res  \n  \n  \ndef invert_left(m, l, val):  \n    length = 32  \n    mx = 0xffffffff  \n    i, res = 0, 0  \n    while i * l \u003c length:  \n        mask = (mx \u003e\u003e (length - l) \u0026 mx) \u003c\u003c i * l  \n        tmp = m \u0026 mask  \n        m ^= tmp \u003c\u003c l \u0026 val  \n        res |= tmp  \n        i += 1  \n    return res  \n  \n  \ndef invert_temper(m):  \n    m = invert_right(m, 18)  \n    m = invert_left(m, 15, 4022730752)  \n    m = invert_left(m, 7, 2636928640)  \n    m = invert_right(m, 11)  \n    return m  \n  \n  \ndef recover_state(record):  \n    state = [invert_temper(i) for i in record]  \n    state = reverse_twist([0] * 12 + state)  \n    return state[0:624]  \n  \n  \ndef clone_mt(record):  \n    state = recover_state(record)[0:624]  \n    gen = Random()  \n    gen.setstate((3, tuple(state + [0]), None))  \n    return gen  \n  \n  \ndef to_hex32(dec):  \n    return hex(dec)[2:].zfill(32)  \n  \n  \ndef to_hex64(dec):  \n    return hex(dec)[2:].zfill(64)  \n  \n  \ndef reverse_twist(cur):  \n    high = 0x80000000  \n    low = 0x7fffffff  \n    mask = 0x9908b0df  \n    state = cur  \n    for i in range(11, -1, -1):  \n        tmp = state[i + 624] ^ state[i + 397]  \n        # recover Y,tmp = Y  \n        if tmp \u0026 high == high:  \n            tmp ^= mask  \n            tmp \u003c\u003c= 1  \n            tmp |= 1  \n        else:  \n            tmp \u003c\u003c= 1  \n        # recover highest bit  \n        res = tmp \u0026 high  \n        # recover other 31 bits,when i =0,it just use the method again it so beautiful!!!!  \n        tmp = state[i - 1 + 624] ^ state[i + 396]  \n        # recover Y,tmp = Y  \n        if tmp \u0026 high == high:  \n            tmp ^= mask  \n            tmp \u003c\u003c= 1  \n            tmp |= 1  \n        else:  \n            tmp \u003c\u003c= 1  \n        res |= (tmp) \u0026 low  \n        state[i] = res  \n    return state  \n  \n  \ndef solve():  \n    rs128s = ['d5d97afad7ef619b4badd8d2da10ee24', '67f4660a8335fb9f4152a9fbc44c9c77',  \n              '8cd43c85ebe9cc7036a37f47ccd1d1e4', 'ee3e8c62e8b0100027589d6de82677ef',  \n              '463bb2f3731ad0e786302bf78da08330', 'e245b1852a3b92734e46eb3421bd76c9',  \n              '0b74736786b4ab94651e3b706a548e55', '79cb596b28c2b4e02738f93b5bfbe0d3',  \n              '5a9c46837952952045564b5b395acad1', 'd3c2d90a05d1a059fbeba4a05a608798',  \n              '4da0306c8ab58097d2fef9114e6fcb6d', '9707fabbd3c96de66917f15998ac9201',  \n              '9dd3e46fc930abfb523fe31e8ee8a658', '3716a8fd05f7388e7151d09431e61ee1',  \n              '9acf027679a6d7a674a43dee4f5bea35', '78702a2b125a940519337b1bf50aff8a',  \n              '262cf3b8c8072a602048a24756c83fcf', '092f8d227ec583c4734a6f449de521a3',  \n              '712aa300302b57fed458553426348fce', '834d4a0ea451cc04b469636b18c56435',  \n              '754b5284b14402c61e3b1e56cb2d41e9', '51d742ca6a341032afcb5dc645f54bfa',  \n              'c1a33d104f47e33d6932905b483a2018', '3def7c2a14cff6b2864a2100956df07f',  \n              '7e3606e4ec1c99fe5a8593ae44f25a70', '404c6139570883dbab8e5a299d7a5017',  \n              'f07597079e1b68ebb4e2d16b83b7b484', '0723daf5c65f8ba6cd6e43fcdf9d18dc',  \n              '4c54db12829f165837384b66978e8438', 'cd056e64e1f31461cab2e66ece9d3278',  \n              '2f6ae16fab122cbce240e32464a1ab57', 'f86e0e9ee23498340f62d8617f6f5218',  \n              'af4ebe2535885c783c89f8d8c4815076', 'c8eae5b5c7aca2c5fdb4f284e2cf65c5',  \n              'bec0d8ecabedd9811a8ecb6052b21d8c', '731bd3421b6517aa101357fe1c49caf3',  \n              '344f4a26cdaf1a782d9b32208e1a3e92', '892b1741d304878461dd0774a335ea3d',  \n              '56e2a484ca40f43e059bf5f0bd822bdc', 'd7c0762df71b31c14654147fb9a0595c',  \n              '57016a179ba5509f6b04a161ac628b34', 'e49a2d573522c1ee3e8348ceca0295a4',  \n              '4b0f49c7e6469e82832e9cc90b9e17c0', 'eadc9d0c8b75127fe0a7f71881de1ea7',  \n              'db9fe5537768207bd8cdf770bcd42dfa', 'ba2f57578752628d1ecac419b3a8bc36',  \n              '3752e70b5d2b578a8d412d84aab43705', '54e97795df8781c776cbb1ce4f5f31fc',  \n              '32794880abc9f68102c24e92ad9c7cd5',  \n              'b5eb7e651ca298f6873694c47d1cd3da', 'a188934777d2c67e3d59692135005497',  \n              '34c308fa1644b387169ea88c1b575490']  \n    rs256s = ['2eebed894580fb900c3615d4866150e68322ff4d48e7509f85ff4543969b0cf6',  \n              '017aefd63b4ce14eb376161902d92894a15f680e7b055ce25c3b02c6b49db0a6',  \n              'e12d945904032887c967ae03a48c8b096abc79dc64134d872693599d4f6c91cc',  \n              '0f8957f365f53a7209baa852905c5da5dba54ddb403ab17a4c9b3a051540d49c',  \n              '091e3e41815cd32f482f2cf54ac3338fc918c2a657896af1aa1b23ea528664f4',  \n              '5916cd18e8c48c545232112f2179aa7a722350a8a0ced4f1363cc61bc9d83630',  \n              '37702710d47a1c17278743253123f6eac85b16d9393432ec65100143bc8657e8',  \n              'c3a7006293c48957cba5c010f945483cfdc47650a79d0e8a8a9a52c174244a10',  \n              'e1a90a475dd21da64d64ea1dd50a82a622061d08e9d4b3016982c4a0b42f1251',  \n              '2f40ff85024765e58ed175927c53e0a279cda96ce755b602f89bfc171108ba3d',  \n              'f4f8337dd7267d02638a9cc531c8a02fe0316dd5ff6f8c8aec898c060c6fb217',  \n              '0df2f3fe1eb976944a2de5729fca4a12b83c8329b4f514869856ebb94b7d7bf9',  \n              'abb2f1277b1cb5ad07254b7f7ed346bcdb73282b306123ce0b5befe42a9e796d',  \n              '6ef31ed6a2a465bcd146c2438bf391bfd9f3187cf54afae512220a7a94714bf3',  \n              '6981f99ba288923a5cd68908ecc8795bf301f1e7d081ac6580a63902fd52da01',  \n              'b6b07975697de1c0342e3711b59165b849125794ef2541c6c60dcf40e689df7b',  \n              '20e3af3a2bcedfd15199975cc9edcde14cb13fdff3ea0607a4747601e500aede',  \n              '606aa1daf188b9dd5fd6141312f1828846f92baa519e70e5c6923a352421fe2f',  \n              '1dc6a60112e99c5b884c0bb5430a7a54eba8aef34fada9cb96bce79a22456cf2',  \n              'fd81e36f576119a19185cd12e87544b42f9fcc3dcb5e7ba282b1a128d73d63c5',  \n              '7a01e947ca012a5c9a8dd20e693a7788cd6157a5c3fce5fa7c7e09014ea3266e',  \n              'ccd162b182c773062514ffc3551ed47f32293700083782d902efc55b1e9795c6',  \n              'dbb6115aefd2638eebf44d3be6e9525e09ff036269d954469a0f925b496327a7',  \n              'ac08696fe64bb5e58cd3e558463213ca08ab7805e33f45459ae14b35fc5858c6',  \n              '6e1594596ad1c656635af29d14b22a5ed10e545442eea5f4e056e20d11aa33b3',  \n              '4afd17e64562603c66ce0ca42d544ca48511c3d560f9180c231a9ccb28a0e55e',  \n              '06b2d2b24ca626e18fdcb3196e989e3b05150500815511f48200ddea9aacda48',  \n              '947a11e8258fd161d02b0eb1b2e8fcd9ff1684a7c75f7c506ddee91f08316f56',  \n              'a0e58b15736cab055be1d03860dedb6b8136f6739308c2e0ef6a7490c6b4a1f1',  \n              '31476f64f96d72a398e7eb789068b8cfd61ed9cac95d76824a2bbf5b682ea72d',  \n              '974259198846a4849d318afd325d860a6e40dfd39e1ed8c7b6d87c990e35efcf',  \n              'e93d02ba7079c488c30e377794b4fcc62eeafb6c3f02197f1ebc059e3e5f7f07',  \n              'ded96eec0d25c05a54671a001bcd99f5c6d3991d2fdf80afb8f0861a44f3fd64',  \n              '86f34c1da65f07634de7c302a6df306dd545806022411a318900bd33b0aff9bd',  \n              '59baf4cf3d3b85fcdefd1a9b60c3d78926ff73650ac375c616b30fe9063b377d',  \n              '02f2ee251ecc19fa52dd42c0e0b609bc2e7a8ae11ce6ca35396a4bc74d12ac63',  \n              '597d09b4c43012b1b4b040d8c62d5fb02d1c4249de4eea06e1447000ba53f50c',  \n              'bb87bd8e1903db2df41c349914e9f3591bb032400be6e86ed10e7d292243a374',  \n              'cec38960069fdc8090cfbdd166e15ec8a77ce5b4d6b350805a63d2b54cbf0187',  \n              '1439d35a9c0caa9cacabe8e6179a02d51ebb9fb51125d5eeaba47ff6b8abcc97',  \n              '820d72d49e0fd86ef47b022a3091b326be8b0d2a42f87cbc918737b9972ea62f',  \n              'e625e82100031fa4a4410700034859cd4b35c086f5ac2870c6909c16a6831bfc',  \n              'f0e22f5167d29331351e1718c17b5420f6a29d84357273e1bfb24c2ff34fa675',  \n              'a5a7991f0c5c6a44f68c5c18661611057dbabeff7847623315ce784095645f75',  \n              '07cd3f5c5c690214af5feda27b3aec257543a8f96bc509805028a0e95c5d98c6',  \n              '6e5dd4405c1b446b9530e4d9356c05b71d1bfcf8a79778588143c3b6fec3fded',  \n              'a33f821d277e6f73c09a5ecd14cef80bac29ffe2b917225c27725d2447ac0489',  \n              'c18a4a02dd1f7ee65bf5596c53549c286a754afb0e3b90b2369cdd1e43c0b986',  \n              '6b8df66aa27b40ca275bc133958b5d543167edf919e7e623a496c9afbf7594d6',  \n              'c48124eeef995c7bb705bd240a26dbf6bdbe42ba29addf7ac78fa28dbed3debe',  \n              '040eef11dc6e0f3bb3e58e12d2a57ee274071a9c6224f27db70e19a8aa7d4df2',  \n              '4ecd0a955e52657fab8dfdac2df4d805f1d08b031df8bce22ac01fe20ca72c5b']  \n    record = []  \n    for i in range(52):  \n        rs128 = rs128s[i]  \n        rs128 = int(rs128, 16)  \n        record.append(rs128 \u0026 (2 ** 32 - 1))  \n        record.append((rs128 \u0026 (2 ** 64 - 1)) \u003e\u003e 32)  \n        record.append((rs128 \u0026 (2 ** 96 - 1)) \u003e\u003e 64)  \n        record.append(rs128 \u003e\u003e 96)  \n  \n        rs256 = rs256s[i]  \n        rs256 = int(rs256, 16)  \n        record.append(rs256 \u0026 (2 ** 32 - 1))  \n        record.append((rs256 \u0026 (2 ** 64 - 1)) \u003e\u003e 32)  \n        record.append((rs256 \u0026 (2 ** 96 - 1)) \u003e\u003e 64)  \n        record.append((rs256 \u0026 (2 ** 128 - 1)) \u003e\u003e 96)  \n        record.append((rs256 \u0026 (2 ** 160 - 1)) \u003e\u003e 128)  \n        record.append((rs256 \u0026 (2 ** 192 - 1)) \u003e\u003e 160)  \n        record.append((rs256 \u0026 (2 ** 224 - 1)) \u003e\u003e 192)  \n        record.append(rs256 \u003e\u003e 224)  \n  \n    g = clone_mt(record[:624])  \n    # for i in range(624):  \n    #     g.getrandbits(32) #产生前624个随机数，让state状态到生成flag前  \n  \n    flag = hashlib.md5((to_hex32(g.getrandbits(128)) + to_hex64(g.getrandbits(256))).encode()).hexdigest()  \n    print('flag{%s}' % flag)  \n  \n  \ndef test():  \n    for i in range(624):  \n        print(random.getrandbits(32))  \n    print(random.getrandbits(32))  \n  \n  \nif __name__ == '__main__':  \n    solve()\n```\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E6%A2%AF%E5%AD%90/v2ray-multi%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98":{"title":"v2ray-multi最新版服务无法启动问题","content":"\n# v2ray-multi最新版服务无法启动问题\n\n/etc/systemd/system/v2ray.service这个文件，ExecStart=/usr/bin/v2ray/v2ray -config /etc/v2ray/config.json，在-config前面加个run，然后systemctl daemon-reload，然后重启v2ray就行了。因为新版修改了启动命令，启动时需要加上run\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/%E6%AF%9B%E7%BA%BF%E5%89%AA%E8%97%8F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6":{"title":"路径配置","content":"\n# 路径配置\n\n```\n0_0-收集/0_0_0-mxwc/0_0_0_0-默认分类\n```\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F":{"title":"hugo启用最后修改日期","content":"# hugo启用最后修改日期\n\n## 读取笔记yaml信息\n\n修改模板：\n```yaml\nupdated: 填入日期\n```\n\n设置配置文件：\n如果是yaml文件：\n```yaml\nfrontmatter:\n  lastmod: [\":lastmod\", \"updated\"]\n```\n如果是toml文件：\n```toml\n[frontmatter]\n  lastmod = [\":lastmod\", \"updated\"]\n```\n\n配置文件中第二个字段与yaml中定义的字段一致即可。\n\n## 读取笔记文件修改信息\n\n设置配置文件：\n如果是yaml文件：\n```yaml\nfrontmatter:\n  lastmod: [\":fileModTime\", \"lastmod\"]\n```\n如果是toml文件：\n```toml\n[frontmatter]\n  lastmod = [\":fileModTime\", \"lastmod\"]\n```","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8":{"title":"Obsidian配置webdav远程同步服务器","content":"# Obsidian配置webdav远程同步服务器\n\n## 准备\n\n1. obsidian软件\n2. obsidian remotely save插件\n3. vps服务器 （ubuntu2004）\n\n## 安装并配置nginx服务器\n\n### 安装nginx及webdav插件\n```shell\nsudo apt\nsudo apt -y install nginx nginx-extras libnginx-mod-http-dav-ext libnginx-mod-http-auth-pam\n```\n\n### 创建nginx配置文件\n```shell\nvim /etc/nginx/conf.d/webdav.conf\n```\n\n文件内容：\n```nginx\nserver {\n    listen 设置一个端口;\n    listen [::]:设置一个端口;\n    server_name 如果有域名就配在这里;\n    # 设置使用utf-8编码,防止中文文件名乱码\n    charset utf-8;\n    # 默认存放文件的路径\n    root /webdav;\n    auth_basic              realm_name;\n    # 用户密码文件存放位置\n    auth_basic_user_file    /etc/nginx/.passwords.list;\n    # dav 允许的操作\n    dav_methods     PUT DELETE MKCOL COPY MOVE;\n    dav_ext_methods PROPFIND OPTIONS;\n    # 创建文件的默认权限\n    dav_access      user:rw group:rw all:r;\n    # 临时文件位置\n    client_body_temp_path   /tmp;\n    # 最大上传文件限制, 0表示无限制\n    client_max_body_size    0;\n    # 允许自动创建文件夹(如果有需要的话)\n    create_full_put_path    on;\n    autoindex on;\n    autoindex_exact_size on;\n\t# 注意这里必须要用location块包起来，否则add_header会报错\n    location / {\n        if ($request_method = OPTIONS ) {\n            add_header Content-Length 0;\n            add_header Content-Type text/plain;\n            add_header DAV 1,2;\n            add_header Allow 'OPTIONS,HEAD,GET,PROPFIND,DELETE,COPY,MOVE,PROPPATCH,LOCK,UNLOCK';\n            add_header Access-Control-Allow-Origin '$http_origin' always;\n            add_header Access-Control-Allow-Credentials 'true' always;\n            add_header Access-Control-Allow-Methods 'OPTIONS,HEAD,GET,POST,PUT,PROPFIND,DELETE,COPY,MOVE,PROPPATCH,LOCK,UNLOCK' always;\n            add_header Access-Control-Allow-Headers '*' always;\n            return 200;\n        }\n\n        add_header Access-Control-Allow-Origin '$http_origin' always;\n        add_header Access-Control-Allow-Credentials 'true' always;\n        add_header Access-Control-Allow-Methods 'OPTIONS,HEAD,GET,POST,PUT,PROPFIND,DELETE,COPY,MOVE,PROPPATCH,LOCK,UNLOCK' always;\n        add_header Access-Control-Allow-Headers 'Origin,X-Requested-With,Content-Type,Accept,Authorization,Depth' always;\n    }\n}\n```\n\n测试连通性：\n直接用浏览器访问地址：端口看是否能映射出目录。\n\n注意：\n- 必须要用location块把add_header部分包起来，否则add_header会报错，因为add_header不能用在server块下的if块中。\n\n### 创建文件夹并配置权限\n```shell\nmkdir /webdav\nsudo chown -R www-data:www-data /webdav\nsudo chmod 755 /webdav\n```\n\n### 创建用户并生成密码\n```shell\n# 设置用户名\necho -n '设置一个用户名:' | sudo tee /etc/nginx/.passwords.list\n# 生成密码并写入密文\nopenssl passwd -apr1 | sudo tee -a /etc/nginx/.passwords.list\n# 确认输入两次密码\n```\n\n注意：\n- 用户名后面要有冒号\n- 文件此时保存的是所设置密码的密文\n\n### 配置防火墙并启动服务\n\n```shell\nsudo ufw allow 你设置的端口\nsudo systemctl start nginx\nsudo systemctl enable nginx\n```\n\n## 设置插件\n\n按照插件字段提示设置即可，有几个地方要注意：\n- 服务器地址前也要加`http://`。\n- 不建议开加密，可能文件名会超过linux255字符的限制导致同步失败。","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E8%99%9A%E6%8B%9F%E6%9C%BA/docker/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C":{"title":"docker常用操作","content":"\n# docker常用操作\n\n## 查询正在运行容器并进入\n\n```shell\nsudo docker ps  \nsudo docker exec -it 775c7c9ee1e1 /bin/bash\n```\n\n## 启动容器\n\n```bash\ndocker run -itd -p [外部端口]:[内部端口] -v [外部绝对路径]:[内部绝对路径] -w [工作路径] --name [自定义名称] [镜像名]:[版本号] /bin/bash\n```\n\n例子\n\n```bash\ndocker run -itd -p 4222:22 -v /root/mfjshared:/root/shared -v /root/jys:/root/jys -w /root --name edge-dev-env-49-mfj edge-dev-env:v4.9 /bin/bash\n```\n\n## 打包容器成镜像\n\n```bash\ndocker commit -a \"[作者名称]\" -m \"[描述]\" [容器id] [镜像名称]:[版本号]\n```\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Git/git%E4%B8%ADfork%E7%9A%84%E4%BB%93%E5%BA%93%E8%A7%A3%E5%86%B3merge%E5%86%B2%E7%AA%81":{"title":"git中fork的仓库解决merge冲突","content":"\n# git中fork的仓库解决merge冲突\n\n假设我们从远程主仓库repoA fork 了自己的repoB，我们开发并提交代码的时候，主仓库同时有其它人提交代码，不幸的是你们都修改了同一个文件的同一行，产生冲突。\n\n## 1. 添加主仓库为upstream到本地git\n\n[Git Upstreams and Forks: A Complete How-To | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/git-forks-and-upstreams)\n\n1. 检查是否设置upstream仓库：\n\n```bash\n   git remote -v\n   origin   git@bitbucket.org:my-user/some-project.git (fetch)\n   origin  git@bitbucket.org:my-user/some-project.git (push)\n```\n\n如果如上述结果则说明没有设置upstream仓库，需要添加。\n\n2. 设置upstream仓库\n\n```bash\ngit remote add upstream git@bitbucket.org:some-gatekeeper-maintainer/some-project.git\n```\n\n添加后重新检查结果如下：\n\n```bash\ngit remote -v\n    origin    git@bitbucket.org:my-user/some-project.git (fetch)\n    origin    git@bitbucket.org:my-user/some-project.git (push) upstream  git@bitbucket.org:some-gatekeeper-maintainer/some-project.git (fetch)\n    upstream  git@bitbucket.org:some-gatekeeper-maintainer/some-project.git (push)\n```\n\n3. 创建分支或者使用dev分支，准备处理到来的冲突\n\nfetch的最新代码，如果和本地提交修改了同一行，就会发生冲突，此时git的自动merge无法继续执行，需要手动处理冲突，为此创建一个分支而不是使用master分支来处理冲突。\n\n```bash\ngit checkout -b dev\n#some work and some commits happen\n#some time passes\n```\n\n4. 从upstream fetch最新的代码\n\n在不知不觉中，主仓库的其它开发人员会提交代码，你自己fork的代码可能就会落后，这时候需要fetch获取最新的代码到本地，保持代码的新鲜：\n\n```bash\ngit fetch upstream\n```\n\n5. 合并本地仓库的head与主仓库的head\n\n假如我们使用的是vscode来开发，有git图形界面。\nfetch到最新的主仓库代码后，主仓库产生的变动会分成两种：\n1. 没有冲突的代码更新，会直接被存放在staged changes中，代表这些变动无需处理冲突，可以直接在repoB上commit。\n2. 存在冲突的更新，会存放在merge changes中，代表这些变动需要手动处理冲突，此时在vscode上通过图形界面手动审核代码处理冲突，完成处理后会移动到staged changes中。\n\n6. push代码到克隆的远程仓库repoB\n\n直接push就行。\n\n```bash\ngit push\n```\n\n7. 向主仓库提交PR\n\n此时在repoB上提交的commit是经过fetch最新代码并处理了合并冲突的，向主仓库提交合并请求不会再产生合并冲突问题。\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null},"/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/8-%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Git/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C":{"title":"git多人协作","content":"\n# git多人协作\n\n## 创建分支\n\n分支的作用是为了区别开不同的开发流程，方便做并行处理以及快速切换，例如一个dev分支用于主开发流程，而突然需要针对某个场景做兼容性开发，则创建一个dev2分支并切换过去。\n\n[Git - 分支的新建与合并 (git-scm.com)](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)\n","lastmodified":"2023-01-23T15:37:51.81068106Z","tags":null}}