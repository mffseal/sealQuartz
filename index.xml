<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🦭海豹湾 on</title><link>https://harbor.mffseal.top/</link><description>Recent content in 🦭海豹湾 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://harbor.mffseal.top/index.xml" rel="self" type="application/rss+xml"/><item><title>_dl_runtime_resolve</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/_dl_runtime_resolve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/_dl_runtime_resolve/</guid><description>_dl_runtime_resolve 首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址 .rel.plt+参数relic_index，求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&amp;gt;r_info &amp;raquo; 8 作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&amp;gt;st_name得出符号名 字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&amp;gt;r_offset，即GOT表 最后调用这个函数 ![[z-oblib/z2-attachments/Pasted image 20220911014856.png]]
方法过程 6.</description></item><item><title>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</guid><description>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用 (33条消息) AbstractDispatcherServletInitializer 的实现类为什么可以在初始化Web容器的时候被调用_Nishkata的博客-CSDN博客
Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析_Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析|Samuel个人博客 (yangshuaibin.com)
Servlet 做的事 Servlet3.0 环境中，容器会在类路径中查找实现 ServletContainerInitializer 接口的类，如果发现的话，就用它来配置 Servlet 容器。</description></item><item><title>AQS</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/</guid><description>AQS 全称是 AbstractQueuedSynchronizer，是阻塞式锁（类似[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]）和相关的同步器工具的框架。
特点 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - cas 机制设置 state 状态 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet 子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</description></item><item><title>B+树</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B+%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B+%E6%A0%91/</guid><description>B+树</description></item><item><title>Balking</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Balking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Balking/</guid><description>Balking Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。
实现 单线程情况 通过变量记录某个方法是否已经执行过，保证方法只能执行一次。 例如监控器前程只需要一个，不需要重复start()新的线程。
1 2 3 4 5 6 7 8 9 10 11 12 class SystemMonitor { private boolean starting = false; public void start() { // 防止重复启动 if(starting) { return; } starting = true; monitorThread = new Thread(()-&amp;gt;{.</description></item><item><title>busybox</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/busybox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/busybox/</guid><description>busybox 一个集成了一百多个最常用linux命令和工具的软件。</description></item><item><title>call</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/call/</guid><description>call push eip+4 mov eip, func</description></item><item><title>Callable</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Callable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Callable/</guid><description>Callable 带返回值的call，并且可以抛出异常。
1 2 public interface Callable&amp;lt;V&amp;gt; { V call() throws Exception;</description></item><item><title>CAS</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS/</guid><description>CAS 原理 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。
在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。
CAS应用 java中：与volatile配合实现乐观锁。
CAS为什么能保证原子操作呐？ 这个就关系到了CAS底层所用到的Unsafe类，Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</description></item><item><title>CAS与volatile</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E4%B8%8Evolatile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E4%B8%8Evolatile/</guid><description>CAS与volatile 用例 AtomicInteger 的解决方法，内部并没有用锁来保护共享[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]。那么它是如何实现的呢？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void withdraw(Integer amount) { while(true) { // 需要不断尝试，直到成功为止 while (true) { // 比如拿到了旧值 1000 int prev = balance.</description></item><item><title>CAS实现原子操作的三大问题</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</guid><description>CAS实现原子操作的三大问题 ABA问题 所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]是检查不出变化的，但实际上却被更新了两次。
ABA问题的解决思路是在变量前面追加上版本号或者时间戳。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。
这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。
1 2 3 4 5 6 7 8 9 10 11 12 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.</description></item><item><title>CAS锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E9%94%81/</guid><description>CAS锁 利用原子类配合cas操作组成标志位，来模拟锁：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 不要用于实践！！！ public class LockCas { private AtomicInteger state = new AtomicInteger(0); public void lock() { while (true) { if (state.</description></item><item><title>CMOS</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/CMOS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/CMOS/</guid><description>CMOS CMOS是Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）的缩写。</description></item><item><title>cmpxchg</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cmpxchg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cmpxchg/</guid><description>cmpxchg https://zhuanlan.zhihu.com/p/34556594
底层实现 linux_x86的实现：
![[z-oblib/z2-attachments/v2-918101df747ba9d03815cefff3955d74_1440w.jpg]]
windows_x86的实现：
![[z-oblib/z2-attachments/v2-cd24129a2b8f106ec3179083d3e8cfd1_1440w.jpg]]
mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。
如果当前系统是多处理器，该函数返回1。 否则，返回0。 LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。
如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。 否则，不加lock前缀。 这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。</description></item><item><title>ConcurrentHashMap</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap/</guid><description>ConcurrentHashMap 用例 分布式计算字符串数量：
生成测试数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static final String ALPHA = &amp;#34;abcedfghijklmnopqrstuvwxyz&amp;#34;; public static void main(String[] args) { int length = ALPHA.</description></item><item><title>ConcurrentLinkedQueue</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentLinkedQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentLinkedQueue/</guid><description>ConcurrentLinkedQueue</description></item><item><title>CountdownLatch</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CountdownLatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CountdownLatch/</guid><description>CountdownLatch 用来进行[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]][[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一
使用 基本流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static void main(String[] args) throws InterruptedException { CountDownLatch latch = new CountDownLatch(3); new Thread(() -&amp;gt; { log.</description></item><item><title>CPU缓存</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%BC%93%E5%AD%98/</guid><description>CPU缓存 ![[z-oblib/z2-attachments/Pasted image 20220602143516.png]]
从 cpu 到 大约需要的时钟周期 寄存器 1 cycle (4GHz 的 CPU 约为0.</description></item><item><title>CyclicBarrier</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier/</guid><description>CyclicBarrier [ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。
与CountdownLatch不同，CyclicBarrier可以重复使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行 new Thread(()-&amp;gt;{ System.</description></item><item><title>dao</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/dao/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/dao/</guid><description>dao DAO（Data Access Object）是用于访问数据的对象，实际上是一个映射关系，将java中访问对象的操作映射的具体数据库的操作，例如Mybatis的设计中，MapperScannerConfigurer会扫描所有dao，得到domain数据对象操作和数据库语句的映射关系，通过[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/动态代理|动态代理]]的方式拦截所有对domain的操作，转到对数据库的操作。</description></item><item><title>DES</title><link>https://harbor.mffseal.top/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/DES/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/DES/</guid><description>DES</description></item><item><title>ELF</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ELF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ELF/</guid><description>ELF 文件格式 目标文件既会参与程序链接又会参与程序执行。出于方便性和效率考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下： ![[z-oblib/z2-attachments/Pasted image 20220912001910.png]]</description></item><item><title>epoll</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/epoll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/epoll/</guid><description>epoll 特性 触发模式 水平触发 水平触发为Level Triggered，简称LT。
水平触发关心的是缓冲区的状态，当缓冲区可读的时候，就会发出通知，也就是当缓冲区中只要有数据就会发出通知。
边缘触发 边缘触发为Edge Triggered，简称ET。
边缘触发关心的是缓冲区状态的变化，当缓冲区状态发生变化的时候才会发出通知，比如缓冲区中来了新的数据。
区别 设想这样一个场景，当一次read()读取没有读取完缓冲区中的数据时，LT和ET的区别：
1、LT，此时缓冲区中还有数据，会继续发通知
2、ET，此时缓冲区状态并没有发生变化，并没有来新的数据，就不会发通知，在新数据到来之前，之前剩余的数据就无法取出。
所以在ET模式下，当读取数据的时候，一定要循环读取数据，直到缓冲区中的数据全部读取完成，一次性将数据取出。
原理流程 类似java [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/ReentrantLock|ReentrantLock]] 的实现，或者像[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|Monitor]]管程的设计。线程访问资源就到等待室中等待；准备好了的资源会放入红黑树便于检索；有资源好了操作系统就会唤醒等待室中的线程。</description></item><item><title>final</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/final/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/final/</guid><description>final final是可被继承的，这点和static不同。
修饰类 不可继承
当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
修饰方法 不可重写
使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。 &amp;ndash;摘自《Java编程思想》第四版第143页
如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。 类的private方法会隐式地被指定为final方法。 修饰变量 不可变</description></item><item><title>firmadyne</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/firmadyne/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/firmadyne/</guid><description>firmadyne Firmadyne是一款自动化和可裁剪的嵌入式Linux系统固件分析框架。它支持系统固件逆向QEMU嵌入式系统模拟执行。使用它模拟路由器固件执行路由器，然后可以基于模拟环境进行路由器漏洞挖掘、渗透攻防。
组件 修改过的便于防火墙程序执行的kernels (MIPS: v2.6.32, ARM: v4.1, v3.10); 一个用户空间的 NVRAM library，用于模拟NVRAM硬件; 一个固件提取器（ extractor）， 用于提取嵌入式firmware固件的filesystem 和kernel; 一个小 console应用，用于另启一个shell进行调试; 一个 scraper，用于下载 firmware固件（从 42+ 不同供应商） 参考 (1条消息) 自动化固件逆向框架firmadyne使用详细教程_子曰小玖的博客-CSDN博客_firmadyne安装 firmadyne/firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware (github.</description></item><item><title>fork&amp;join</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/forkjoin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/forkjoin/</guid><description>fork&amp;amp;join 概念 Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解 Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 Fork/Join 默认会创建与 cpu 核心数大小相同的线程池 使用 提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务：</description></item><item><title>FutureTask</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/FutureTask/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/FutureTask/</guid><description>FutureTask FutureTask 能够接收 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Callable|Callable]] 类型的参数，用来处理有返回结果的情况。
1 2 FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; // Future.get()用来返回任务的返回值</description></item><item><title>GOT表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/GOT%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/GOT%E8%A1%A8/</guid><description>GOT表 深入理解GOT表和PLT表 - 知乎 (zhihu.com)
GOT(Global Offset Table)全局偏移表，链接器为外部符号填充的实际偏移地址表。
位于数据段，内容可修改。
结构 GOT[1]：一个指向内部数据结构的指针，类型是 link_map，在动态装载器内部使用，包含了进行[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/符号解析|符号解析]]需要的当前 ELF 对象的信息。在它的 l_info 域中保存了 .</description></item><item><title>happens-before</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/happens-before/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/happens-before/</guid><description>happens-before 什么是happens-before 如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。
一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。
JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。
而对于程序员，JMM提供了happens-before规则（JSR-133规范），满足了程序员的需求——简单易懂，并且提供了足够强的内存可见性保证。换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。
JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。
happens-before关系的定义如下：
概念：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 实际是结果为导向：两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。 happens-before关系本质上和as-if-serial语义是一回事。 as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。
满足的几种情况 synchronized 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见：</description></item><item><title>HashMap</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/HashMap/</guid><description>HashMap 并发问题 JDK7并发死链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public static void main(String[] args) { // 测试 java 7 中哪些数字的 hash 结果相等 System.</description></item><item><title>hugo启用最后修改日期</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</guid><description>hugo启用最后修改日期 读取笔记yaml信息 修改模板：
1 updated:填入日期 设置配置文件： 如果是yaml文件：
1 2 frontmatter:lastmod:[&amp;#34;:lastmod&amp;#34;,&amp;#34;updated&amp;#34;] 如果是toml文件：
1 2 [frontmatter] lastmod = [&amp;#34;:lastmod&amp;#34;, &amp;#34;updated&amp;#34;] 配置文件中第二个字段与yaml中定义的字段一致即可。</description></item><item><title>interrupt</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/interrupt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/interrupt/</guid><description>interrupt 打断 sleep, wait, join 的线程 interrupt强行打断线程：
线程会记录本身是否被打断过，但是sleep, wait, join 以异常的方式响应interrupt后会清除异常标记，isInterrupted() == false。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-&amp;gt;{ log.</description></item><item><title>Java内存模型</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>Java内存模型 运行时内存的划分 ![[z-oblib/z2-attachments/Java运行时数据区.png]] 对于每一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]来说，栈都是私有的，而堆是公有的。
也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量，内存的可见性针对的是共享变量。
既然堆是共享的，为什么在堆中会有内存不可见? 这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。
线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。
Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM#JMM的抽象示意图|JMM的抽象示意图]]。
一个例子 https://www.bilibili.com/video/BV16J411h7Rd?p=21&amp;t=575.8
![[z-oblib/z2-attachments/Pasted image 20220526104910.png]]
初始化时会将类加载到方法区。 jvm启动main方法作为主线程。 main线程栈中包含： 程序计数器：指向下一句要执行的代码地址。 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/栈帧|栈帧]]：每次调用其它函数都会生成一个运行时栈帧。 每次调用一个方法，就会在main线程栈中创建一个目标方法的栈帧。 局部变量可以指向堆空间的数组或者是对象。</description></item><item><title>java守护线程</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</guid><description>java守护线程 主线程结束时不管守护线程还有没有其它任务，都会强制结束守护线程。
主要用在：
垃圾回收器线程。 Tomcat中的Accetor和Poller线程。（结束tomcat后不会等待当前请求处理完成而是会直接结束运行）。</description></item><item><title>Java实现的CAS</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%AE%9E%E7%8E%B0%E7%9A%84CAS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%AE%9E%E7%8E%B0%E7%9A%84CAS/</guid><description>Java实现的CAS 前面提到，CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。
在Java中，有一个Unsafe类，它在sun.misc包中。它里面是一些native方法，其中就有几个关于CAS的：
1 2 3 boolean compareAndSwapObject(Object o, long offset,Object expected, Object x); boolean compareAndSwapInt(Object o, long offset,int expected,int x); boolean compareAndSwapLong(Object o, long offset,long expected,long x); 当然，他们都是public native的。</description></item><item><title>java线程上下文切换（Thread Context Switch）</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</guid><description>java线程上下文切换（Thread Context Switch） 因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：
线程的 cpu 时间片用完
垃圾回收
有更高优先级的线程需要运行
线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</description></item><item><title>java线程状态</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid><description>java线程状态 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程状态|线程状态]]
根据Java API Thread.State枚举，有6种状态：
![[z-oblib/z2-attachments/Pasted image 20220526174139.png]]
BLOCKED是指线程正在等待获取锁；WAITING是指线程正在等待其他线程发来的通知（notify），收到通知后，可能会顺序向后执行（RUNNABLE），也可能会再次获取锁，进而被阻塞住（BLOCKED）。
状态转换 1. NEW &amp;ndash;&amp;gt; RUNNABLE NEW [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]刚被创建，但是还没有调用 start() 方法，还未与操作系统线程相关联。 当调用 t.</description></item><item><title>Java调试技巧</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/Java%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/Java%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid><description>Java调试技巧 找某个值的默认参数 推理某个变量值在哪个方法里用到 maven中下载对应包的source 全局搜索该方法 find usages找到方法调用处 找到上层方法中对应该该变量的参数 逐级往上寻找，遇到接口跳转到对应模块下的实现 找到最终的源头 总结 巧用find usages，找到调用处。 选中变量，在右侧滚动条中会用粉红色标题赋值位置。
利用debug堆栈回溯</description></item><item><title>java避免临界区竞态条件</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E9%81%BF%E5%85%8D%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E9%81%BF%E5%85%8D%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/</guid><description>java避免临界区竞态条件 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/竞态条件|竞态条件]]
阻塞式解决方案 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] Lock 非阻塞式解决方案 原子变量</description></item><item><title>JMM</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JMM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JMM/</guid><description>JMM 简介 JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。 JMM 体现在以下几个方面：
原子性 - 保证指令不会受到线程上下文切换的影响 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 JMM的抽象示意图 !</description></item><item><title>join</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/join/</guid><description>join join()方法是Thread类的一个实例方法。让当前线程陷入等待，等待某个其它[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]运行结束，谁调用就等待谁，join起到了[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]的作用。
join()底层就是wait()。
有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。
如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。
示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Join { static class ThreadA implements Runnable { @Override public void run() { try { System.</description></item><item><title>kmp</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp/</guid><description>kmp</description></item><item><title>lambda</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/lambda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/lambda/</guid><description>lambda</description></item><item><title>leave</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/leave/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/leave/</guid><description>leave mov esp, ebp 清空当前函数栈以还原栈空间（直接移动栈顶指针 esp 到当前函数的栈底 ebp ）； pop ebp 还原栈底（将此时 esp 所指的上层函数栈底 old ebp 弹入 ebp 寄存器内）；</description></item><item><title>LinkedBlockingQueue</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LinkedBlockingQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LinkedBlockingQueue/</guid><description>LinkedBlockingQueue 入队出队 类似[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/AQS|AQS]]中的等待队列:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LinkedBlockingQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt; implements BlockingQueue&amp;lt;E&amp;gt;, java.</description></item><item><title>LongAdder</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LongAdder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LongAdder/</guid><description>LongAdder 原理 LongAdder 类有几个关键域：
1 2 3 4 5 6 7 8 // 累加单元数组, 懒惰初始化 transient volatile Cell[] cells; // 基础值, 如果没有竞争, 则用 cas 累加这个域 transient volatile long base; // 在 cells 创建或扩容时, 置为 1, 表示加锁 transient volatile int cellsBusy; cellsBusy用到了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS锁|CAS锁]]的方法。</description></item><item><title>Mark Word</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Mark-Word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Mark-Word/</guid><description>Mark Word 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]持有的锁、偏向线程ID、偏向时间戳等等。
Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。我们打开 openjdk的源码包，对应路径/openjdk/hotspot/src/share/vm/oops，Mark Word对应到C++的代码markOop.hpp，可以从注释中看到它们的组成，本文所有代码是基于Jdk1.8。
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
![[z-oblib/z2-attachments/1162587-20200918154115022-312986152.png]]
在64位JVM中是这么存的：
![[z-oblib/z2-attachments/1162587-20200918154125385-1537793659.png]]
虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。
注意上述结构不是每一行都同时存在，而是根据锁标志位来决定当前行的状态。 例如在重量级锁状态下，当对象获取到Mointer的时，会先复制并暂存无锁态对应的信息，将信息覆写为Mointer地址。当释放锁后，会恢复无锁态对应数据。
锁标志位（lock）：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。 biased_lock：是否[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/偏向锁|偏向锁]]，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。 分代年龄（age）：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。 对象的hashcode（hash）：运行期间调用System.</description></item><item><title>MESI</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/MESI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/MESI/</guid><description>MESI M：代表已修改（Modified）：Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面；
E：代表独占（Exclusive）：Cache Block 里面的数据和主内存里面的数据是一致的；
S：代表共享（Shared）：Cache Block 里面的数据和主内存里面的数据是一致的；
I：代表已失效（Invalidated）：Cache Block 里面的数据已经失效了，不可以相信这个 Cache Block 里面的数据；
![[z-oblib/z2-attachments/24483793-3cef70653d60cdf9.webp]]
问题 CPU操作分为两种：load（读）、store（写），加入缓存的目的是提前缓存内存的数据，提高load的效率，但是store的速度降低了，因为CPU将数据store到内存多了写缓存的步骤，并且需要同步所有CPU的私有缓存。这样store操作会严重阻塞后续的load操作，这样加缓存的意义完全就没有了，不仅没能提高load的效率，反而阻塞了load。为了解决load被阻塞的问题，在CPU中加入了新的组件store buffer（写队列）；</description></item><item><title>monitor</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/monitor/</guid><description>monitor 监视器/管程。
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 给对象上锁（重量级）之后，该[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/对象头|对象头]]的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 中就被设置指向 Monitor 对象的指针。
Monitor 结构： ![[z-oblib/z2-attachments/Pasted image 20220527172014.png]]
Monitor 中 Owner 初始为 null。 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner。 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行synchronized(obj)，就会进入 EntryList BLOCKED。 Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的。 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。 注意： synchronized 必须是进入同一个对象的 monitor 才有上述的效果， 不加 synchronized 的对象不会关联监视器，不遵从以上规则。</description></item><item><title>Netty优化与源码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</guid><description>Netty优化与源码 1. 优化 1.1 扩展序列化算法 序列化，反序列化主要用在消息正文的转换上
序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]） 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理 目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</description></item><item><title>Netty入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E5%85%A5%E9%97%A8/</guid><description>Netty入门 1. 概述 1.1 Netty 是什么？ 1 2 Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.</description></item><item><title>Netty进阶</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E8%BF%9B%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E8%BF%9B%E9%98%B6/</guid><description>Netty进阶 1. 粘包与半包 1.1 粘包现象 服务端代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class HelloWorldServer { static final Logger log = LoggerFactory.</description></item><item><title>Obsidian配置webdav远程同步服务器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>Obsidian配置webdav远程同步服务器 准备 obsidian软件 obsidian remotely save插件 vps服务器 （ubuntu2004） 安装并配置nginx服务器 安装nginx及webdav插件 1 2 sudo apt sudo apt -y install nginx nginx-extras libnginx-mod-http-dav-ext libnginx-mod-http-auth-pam 创建nginx配置文件 1 vim /etc/nginx/conf.</description></item><item><title>OJ常用代码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>OJ常用代码 进制转换 任意进制转 10 进制 对于一个 p 进制的 n 位数 y 来说, 其每一位$a_n$的关系是 $$ y = a_1 \times p^{n-1} + n_2 \times p^{n-2} + &amp;hellip; + a_{n-1} \times p^1 + a_n \times p^0 $$</description></item><item><title>park&amp;unpark</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/parkunpark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/parkunpark/</guid><description>park&amp;amp;unpark 特点 与 wait&amp;amp;notify相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp;amp; unpark 是以线程为单位来阻塞/唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精准。 park &amp;amp; unpark 可以先 unpark，而 wait &amp;amp; notify 不能先 notify。 原理 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻：</description></item><item><title>PLT表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/PLT%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/PLT%E8%A1%A8/</guid><description>PLT表 深入理解GOT表和PLT表 - 知乎 (zhihu.com)
PLT（Procedure Linkage Table）过程链接表，位于代码段，内容不可修改。 PLT表通过引用GOT表中的函数的绝对地址，来把控制转移到实际的函数。 在实际的可执行程序或者共享目标文件中，PLT表在名称为.plt的section中。
结构 PLT[0]：保存一段操作，操作内容：push目标函数编号，跳转到GOT[2]
来源 GOT表和PLT表知识详解_77458的博客-CSDN博客_got表
这个函数是编译系统自己加的，大家可以通过disas gets看看里面的代码，如下图：</description></item><item><title>PUF</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/mcu/PUF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/mcu/PUF/</guid><description>PUF 特点 唯一性：每一个芯片都是随机分布的、唯一的。 防克隆性：芯片本身就是在芯片制造过程中由于不确定因素提取出来的，无法重新复制相同的PUF值。误差本就是不可控因素，因此不能逆向去生成指定的“误差”。 不可预测性：由于芯片在制造出来之前，没有办法来预测。 防篡改性：芯片本身PUF值无法定位修改。 无需存储：每次芯片启动只需要在电路结构中提取，无需存储器件来存储。 实现分类 ![[z-oblib/z2-attachments/Pasted image 20220904144719.png]]
SRAM PUF SRAM PUF利用[[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/SRAM|SRAM]] Cell，首尾相接的反相器，在制造过程中，虽然电路架构完全一样，但是电路驱动能力有强弱之分，导致SRAM在上电时的Cell上0,1的分布是随机分布的，因此，利用这个特征可以提取出PUF 仲裁PUF 仲裁PUF，同一个信号从起点到终点所用的时间（延迟），在制造过程中会存在误差。 RO PUF（环形振荡器） 环形振荡器PUF，利用环形振荡器电路，在不同芯片制造出来之后，频率产生也会存在误差 VIA PUF 实际设计中，VIA存在设计规则，利用设计规则，设计从小到大的孔洞，根据工艺的特性，来提取出VIA PUF SRAM实现 工作原理 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/锁存器|锁存器]]在初始无输入情况下，输出会因生成工业的不可控误差产生不同的初始输出值。</description></item><item><title>Python中16进制与字符串转换</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid><description>Python中16进制与字符串转换 python3 中的字符串和编码 在最新的 Python 3 版本中，字符串是以 Unicode 编码的 Python 的字符串类型是str 在内存中以Unicode表示，一个字符对应若干个字节 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的 bytes 1 注意区分`&amp;#39;ABC&amp;#39;`和`b&amp;#39;ABC&amp;#39;`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。 hex() hex() 函数用于将10进制整数转换成16进制，以字符串形式表示 1 注意!</description></item><item><title>Python引用传递和值传递</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/</guid><description>Python引用传递和值传递 解释器会查看对象引用（内存地址）指示的那个值的类型，如果变量指示一个可变的值，就会按引用调用语义。如果所指示的数据的类型是不可变的，则会应用按值调用语义。
列表 字典 集合
总是会按引用传入函数，函数代码组中对变量数据结构的任何改变都会反映到调用代码中。
字符串 整数 元组
总是会按值传入函数，函数中对变量的任何修改是这个函数私有的，不会反映到调用代码中。</description></item><item><title>Python网络爬虫入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</guid><description>Python网络爬虫入门 爬虫简介 合法性 抓取数据时现实生活中真实数据则合法 抓取数据为原创数据则受版权保护 背景调研 检查 robots.txt 检查 robots.txt 可以最小化爬虫被封禁的可能 发现和网络结构相关的线索 查看方法 通过访问 http://example.webscraping.com/robots.txt, 得到内容:</description></item><item><title>Python装饰器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>Python装饰器 简述 装饰器是闭包的语法糖 装饰器就是在目标函数&amp;quot;周围&amp;quot;加上附加的代码 一般如插入日志、性能测试、事务处理、缓存、权限校验等场景 装饰器是面向切面编程的设计思想 简单装饰器 目标函数 1 2 def foo(): print(&amp;#39;i am foo&amp;#39;) 额外代码 打印log:</description></item><item><title>qemu-user-static</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu-user-static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu-user-static/</guid><description>qemu-user-static 一个用于利用当前操作系统来运行其它架构的一个仿真器。</description></item><item><title>qemu运行mips程序</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu%E8%BF%90%E8%A1%8Cmips%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu%E8%BF%90%E8%A1%8Cmips%E7%A8%8B%E5%BA%8F/</guid><description>qemu运行mips程序 [[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/IoT安全/安装qemu|安装qemu]] 拷贝[[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/IoT安全/qemu-user-static|qemu-user-static]]到目标目录下：cp /usr/bin/qemu-mips-static ./。 运行mips程序(其中./bin/busybox为要执行的busybox)：sudo chroot . ./qemu-mips-static ./bin/busybox。</description></item><item><title>ReentrantLock</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock/</guid><description>ReentrantLock 相当于是一个java层面实现的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]。
特点 相对于 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 它具备如下特点：
可中断（放弃争抢锁） 可以设置超时时间 可以设置为公平锁 先到先得，而不是随机争抢 解决线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]]问题 支持多个条件变量 条件变量相当于synchronized中的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|waitSet]]，不满足条件的可以在wait_set等待 支持多个条件变量意味着有多个waitSet，可以根据不同条件进入不同set等待 与 synchronized 一样，都支持可重入 state标识资源是否为锁定状态。</description></item><item><title>ReentrantReadWriteLock</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantReadWriteLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantReadWriteLock/</guid><description>ReentrantReadWriteLock 当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select &amp;hellip;from &amp;hellip; lock in share mode 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</description></item><item><title>ret</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ret/</guid><description>ret pop eip 还原执行流（将此时 esp 所指的上层函数调用foo时的地址弹入 eip 寄存器内）；</description></item><item><title>RS锁存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/RS%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/RS%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>RS锁存器 RS锁存器是一两输入、两输出的电路，其电路如下图a，其有两个互相交叉反馈相连的两个与非门构成，其两个输出为两个相反的输出（或称为互补输出）。
![[z-oblib/z2-attachments/Pasted image 20220904151011.png]]</description></item><item><title>Runnable</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Runnable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Runnable/</guid><description>Runnable 用来承载供Thread对象执行的任务，将任务从Thread中抽出来可以更加灵活。
1 2 Runnable runnable = () -&amp;gt; log.debug(&amp;#34;runnable&amp;#34;); // lambda Thread t2 = new Thread(runnable); 因为Runnable是一个@FunctionalInterface接口，所以可以通过[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/lambda|lambda]]的形式实现。 通过把方法包装成Runnable更加灵活，并且Runnable对[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]等高级API更加友好。这种思想也就是[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/组合优于继承|组合优于继承]]。</description></item><item><title>safepoint</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/safepoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/safepoint/</guid><description>safepoint 什么是safepoint safepoint可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。
从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。
什么地方可以放safepoint 下面以Hotspot为例，简单的说明一下什么地方会放置safepoint
理论上，在解释器的每条字节码的边界都可以放一个safepoint，不过挂在safepoint的调试符号信息要占用内存空间，如果每条机器码后面都加safepoint的话，需要保存大量的运行时数据，所以要尽量少放置safepoint，在safepoint会生成polling代码询问VM是否要“进入safepoint”，polling操作也是有开销的，polling操作会在后续解释。
通过JIT编译的代码里，会在所有方法的返回之前，以及所有非counted loop的循环（无界循环）回跳之前放置一个safepoint，为了防止发生GC需要STW时，该线程一直不能暂停。另外，JIT编译器在生成机器码的同时会为每个safepoint生成一些“调试符号信息”，为GC生成的符号信息是OopMap，指出栈上和寄存器里哪里有GC管理的指针。</description></item><item><title>Semaphore</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Semaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Semaphore/</guid><description>Semaphore [ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]上限。
应用 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） 用 Semaphore 实现简单连接池，对比『[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]]』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的 简化连接池 一种享元模式应用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Pool { // 1.</description></item><item><title>sleep</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep/</guid><description>sleep sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间，睡眠是指让线程放弃当前CPU的时间片，但是并不会释放锁，抱着锁睡觉。它有这样两个方法：
Thread.sleep(long) Thread.sleep(long, int) 同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。
作用 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException。 睡眠结束后的线程未必会立刻得到执行。 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。 打断睡眠（非唤醒） sleep()是可以打断的，而打断的方式是通过InterruptedException异常，所以sleep()需要捉起来。</description></item><item><title>sleep和wait的区别</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>sleep和wait的区别 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/sleep|sleep]]方法是不会释放当前的锁的，而wait方法会。 这也是最常见的一个多线程面试题。 wait可以指定时间，也可以不指定；而sleep必须指定时间。 wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。 wait必须放在同步块或同步方法中，而sleep可以在任意位置。</description></item><item><title>SPI</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/SPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/SPI/</guid><description>SPI SPI 全称为Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。
简单点说SPI就是 JDK 内置的一个服务发现机制，它使得接口和具体实现完全解耦。我们只声明接口，具体的实现类在配置中选择。
具体的就是你定义了一个接口，然后在META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。
这样就通过配置来决定具体用哪个实现！</description></item><item><title>spring</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/SSM/spring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/SSM/spring/</guid><description>spring 依赖注入 xml配置中常见形式 &amp;lt;xxx name=&amp;quot;abc&amp;quot;, ref=&amp;quot;abcBean&amp;quot;&amp;gt;：
setter注入时意味着：将前述创建的abcBean赋值给成员abc。 构造器注入时意味着：将前述创建的abcBean传递给形参abc。 ref填的是前述定义的bean的id值。
构造器传递会受到构造函数形参的限制，造成配置文件与代码的耦合，虽然提供了部分兼容性的解决方案：指定参数类型、指定参数顺序，但还是不好用，自己开发模块推荐用setter。</description></item><item><title>spring报错分析技巧</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/spring%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/spring%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/</guid><description>spring报错分析技巧 错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面。 有时最下一层是spring内部的异常，可以往上看一级。 最下面是核心原因，最上面是整条错误链的串显示。</description></item><item><title>squashfs</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/squashfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/squashfs/</guid><description>squashfs squashfs 是一个高度压缩的只读文件系统，它可以将高达 2-3GB 的数据压缩到一个只有 700M 的文件中。当一个 Live CD 启动时，它将加载整个 Linux 系统环境。Live CD 所使用的正是这种高度压缩的只读 squashfs 文件系统，其中的 root 文件系统就被压缩存放在这个文件系统之中。</description></item><item><title>SRAM</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/SRAM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/SRAM/</guid><description>SRAM 静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失（被称为volatile memory），这与在断电后还能储存资料的ROM或闪存是不同的。
存储结构 ![[z-oblib/z2-attachments/Pasted image 20220904150755.png]]
6T:指的是由六个晶体管组成，如图中的M1、M2、 M3、M4、M5、M6. SRAM中的每一bit存储在由4个场效应管(M1, M2, M3, M4)构成两个交叉耦合的反相器中。另外两个场效应管(M5, M6)是存储基本单元到用于读写的位线(BitLine)的控制开关。
6T电路等价于SR锁存器：
![[z-oblib/z2-attachments/Pasted image 20220904150813.png]]</description></item><item><title>StampedLock</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/StampedLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/StampedLock/</guid><description>StampedLock 该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用。
一个特殊的读写锁。
使用 读锁 1 2 long stamp = lock.readLock(); lock.unlockRead(stamp); 写锁 1 2 long stamp = lock.</description></item><item><title>static</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/static/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/static/</guid><description>static 父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</description></item><item><title>stream</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/stream/</guid><description>stream OJ中的应用 将内容读取成string，再按照空格分割出字符串数组，再通过stream将字符串数组转成int数组。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class P5788 { public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader(new InputStreamReader(System.</description></item><item><title>synchronized</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized/</guid><description>synchronized 简介 俗称对象锁，采用互斥的方式让同一时刻只有一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]能持有对象锁。其它线程再想获取这个对象锁时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]]内的代码，不用担心线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]。
特点 synchronized不可中断（不可放弃争抢锁）： 不可中断的意思是等待获取锁的时候不可中断，拿到锁之后可中断，没获取到锁的情况下，中断操作一直不会生效。 synchronized规定：线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。保证了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|内存可见性]]。 synchronized代码块中的代码越多，上锁时间越长，尽量减少锁的粒度。 synchronized可以保证原子性、可见性，并且对外部展现有序性，即内部的重排序不会影响外部（而不是不会发生重排序）（因为同一时刻进入synchronized代码块的只有一个线程，单线程下重排序无影响）。 要想保证有序性，就要把东西全部交给synchronized管理，而不能暴露一部分在外面，这也是[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/单例模式#双重校验锁|双重检查锁]]实现时要加[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]]。 语法 1 2 3 4 synchronized(对象) { // 临界区 } 流程 比喻 !</description></item><item><title>Thread</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Thread/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Thread/</guid><description>Thread Thread是一个实现了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Runnable|Runnable]]接口的类，创建一个包含自定义任务的Thread对象有两种方式：
通过继承Thread类并重写run()方法来实现。 通过实例化Thread类时传入Runnable对象来实现。 可以用两种方式来实现因为Thread中默认的run()方法采用了代理的思想：
1 2 3 4 5 6 @Override public void run() { if (target !</description></item><item><title>ThreadPoolExecutor</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</guid><description>ThreadPoolExecutor ![[z-oblib/z2-attachments/Pasted image 20220607225611.png]]
线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]状态，低 29 位表示[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]数量：
状态名 高3位 接收新任务 处理阻塞队列任务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务，但会处理阻塞队列剩余任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列任务 TIDYING 010 任务全执行完毕，活动线程为 0 即将进入 终结 TERMINATED 011 终结状态 从数字上比较，TERMINATED &amp;gt; TIDYING &amp;gt; STOP &amp;gt; SHUTDOWN &amp;gt; RUNNING。</description></item><item><title>Timer</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Timer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Timer/</guid><description>Timer 在[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/任务调度线程池|任务调度线程池]]功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void main(String[] args) { Timer timer = new Timer(); TimerTask task1 = new TimerTask() { @Override public void run() { log.</description></item><item><title>tomcat原理</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/tomcat%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/tomcat%E5%8E%9F%E7%90%86/</guid><description>tomcat原理 ![[z-oblib/z2-attachments/Pasted image 20220815211547.png]]
右边 &amp;ndash; 请求处理 ![[z-oblib/z2-attachments/Pasted image 20220815210239.png]]
wrapper的作用是给具体的servlet实现进行分类，每个servlet实现对应一个wrapper，存储多个运行时产生的实例。
作用的防止混乱。
valve本身是一个责任链的模式，例如可以自定义valve来记录日志。 请求到达对应层次的时候，tomcat就会将请求传递给valve链处理，最终从StandardEngineValve将请求转交给下一层。
Wrapper中最后一个valve（StandardWrapperValve）会调用具体的业务servlet实例对象上的方法，统一调用service方法（servlet父类方法）， service根据http头的动作字符串（GET/POST。。）调用对应的方法。
左边 &amp;ndash; 请求产生</description></item><item><title>Tomcat线程池</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>Tomcat线程池 合理的分工是实现高[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/并发|并发]]的保障。
![[z-oblib/z2-attachments/Pasted image 20220608183846.png]]
分工的原因就是为了防止[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]]，把
LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲 Acceptor 只负责【接收新的 socket 连接】 Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]处理 Executor 线程池中的[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工作线程|工作线程]]最终负责【处理请求】。 与JDK线程池差别 Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同：</description></item><item><title>ubuntu2004下安装物联网固件分析工具包</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/ubuntu2004%E4%B8%8B%E5%AE%89%E8%A3%85%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/ubuntu2004%E4%B8%8B%E5%AE%89%E8%A3%85%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>ubuntu2004下安装物联网固件分析工具包 基础环境 系统：ubuntu2004 64位。 代理工具：proxychains4。 宿主机网络加速软件开放端口用于给虚拟机代理。
安装流程 安装代理工具：sudo apt install proxychains4。 配置代理：sudo vim /etc/proxychains4.conf，将最后的代理服务器地址换成socks5 宿主机Ip 代理端口 克隆自动化分析工具包脚本项目：git clone --recursive https://github.</description></item><item><title>ubuntu环境配置</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>ubuntu环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # apt换源 sudo cp -a /etc/apt/sources.</description></item><item><title>Unix域套接字</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>Unix域套接字 Unix域套接字是[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/套接字|套接字]]的一种，用于本机进程间通信，一般用来实现双向通信的管道。Unix域套接字是比网络套接字轻量级且高效的多，因为它不涉及网络通信，不需要监听连接，不需要绑定地址，不需要关心协议类型，等等。
创建Unix域套接字后返回两个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件描述符|文件描述符]]，这两个文件描述符均对套接字可读、可写，从而实现全双工的双向通信。
同样的，为了避免使用单个文件描述符同时读、写造成的数据错乱，Unix域套接字也有两个buffer空间。
创建了两个方向不同的半双工缓冲区，拼在一起组成所谓全双工。单一buffer不会涉及同时的写入操作。
![[z-oblib/z2-attachments/Pasted image 20220803133056.png]]</description></item><item><title>Unsafe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Unsafe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Unsafe/</guid><description>Unsafe Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class UnsafeAccessor { static Unsafe unsafe; static { try { Field theUnsafe = Unsafe.</description></item><item><title>volatile</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/volatile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/volatile/</guid><description>volatile https://ifeve.com/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97/
内存可见性问题 1 2 3 4 5 6 7 8 9 10 11 A = 0; B = 0; T0 { A = 1; print(B); } T1 { B = 1; print(A); } 这样一段代码可能会出现下列四种输出：</description></item><item><title>wait&amp;notify</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/waitnotify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/waitnotify/</guid><description>wait&amp;amp;notify wait 为什么需要wait 由于条件不满足，小南不能继续进行计算 但小南如果一直占用着锁，其它人就得一直阻塞，效率太低 ![[z-oblib/z2-attachments/Pasted image 20220528165543.png]] 于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开， 其它人可以由老王随机安排进屋 直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法） !</description></item><item><title>x86寄存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/x86%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/x86%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>x86寄存器 ![[z-oblib/z2-attachments/Pasted image 20220912222502.png]]
这八个寄存器的名称如下：EAX（累加器）、EBX（基址）、ECX（计数）、EDX（数据）、ESP（栈指针）、EBP（基址指针）、ESI（源变址）、EDI（目的变址）。</description></item><item><title>yield</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/yield/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/yield/</guid><description>yield 作用 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程。 具体的实现依赖于操作系统的任务调度器。</description></item><item><title>一. NIO 基础</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/NIO/NIO%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/NIO/NIO%E5%9F%BA%E7%A1%80/</guid><description>一. NIO 基础 non-blocking io 非阻塞 IO
1. 三大组件 1.1 Channel &amp;amp; Buffer channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</description></item><item><title>一致性缓存</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%80%E8%87%B4%E6%80%A7%E7%BC%93%E5%AD%98/</guid><description>一致性缓存 使用读写锁实现一个简单的按需加载缓存：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class GenericCachedDao&amp;lt;T&amp;gt; { // HashMap 作为缓存非线程安全, 需要保护 // 这里对读写都加锁了，所以可以继续使用HashMap HashMap&amp;lt;SqlPair, T&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); GenericDao genericDao = new GenericDao(); public int update(String sql, Object.</description></item><item><title>三次握手</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</guid><description>三次握手 客户端、服务端都要确认两件事：
我发出去的包对面能不能收到 对面发给我的包我能不能收到 这也是因为网络是全双工的，所以可以想成有两条道，双方都要确认这两条道路通畅。
客户端向服务端发送一个控制位ACK=0，SYN=1的数据包表示请求建立连接，发送后客户端进入SYN-SENT状态。 此时，客户端虽然发出了数据，但是并不知道任何可用的信息。 服务端接收到数据包后，分配缓存空间，并返回给客户端一个ACK=1，SYN=1的数据包，确认号ack为客户端数据包序列号加一，服务端进入SYN-RCVD状态。 服务端收到客户端的包后知道了：客户端发给我的包，我能收到。 客户端收到服务端的响应后知道：服务端发给我的包，我能收到。 根据包的ack和syn字段客户端还能知道：我发给服务端的包，服务端能收到。 这一步客户端一方想要的信息都齐了，但服务端还差一点。</description></item><item><title>三色标记算法</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</guid><description>三色标记算法 解决的问题 CMS垃圾回收机制下，对象标记线程和用户线程同时执行，用户线程会影响标记准确度，导致：
浮游垃圾问题 该问题不同特别在意，因为浮动垃圾会在下次GC时被清理。 错误回收问题 该问题要特别在意，因为回收了一个正在使用的对象是严重的BUG。 解决思路 通过广度优先算法扫描gc树上的节点，并用黑色标记已经扫描完成的节点，灰色标记正在扫描的节点，白的未扫描的节点，达到性质：
黑色节点的所有子节点都应该是灰色节点。 所有白色节点都是垃圾。 因为黑色节点是已经扫描完成的，不会再处理，所以若用户线程把白色节点接入黑色节点就会产生错误：该白色节点不应该被回收但不会再变色了。</description></item><item><title>上下文</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>上下文 上下文是指某一时间点 CPU 寄存器和程序计数器的内容。</description></item><item><title>上下文切换</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</guid><description>上下文切换 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/上下文|上下文]]切换（有时也称做进程切换或任务切换）是指 CPU 从一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]（或[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]）切换到另一个进程（或线程）。</description></item><item><title>不可变小结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%B0%8F%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%B0%8F%E7%BB%93/</guid><description>不可变小结 不可变类使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/不可变设计|不可变设计]] 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/0-语法基础/final|ﬁnal]] 模式方面 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]]</description></item><item><title>不可变设计</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1/</guid><description>不可变设计 以String类为例：
1 2 3 4 5 6 7 8 9 10 11 public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage.</description></item><item><title>两阶段终止</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2/</guid><description>两阶段终止</description></item><item><title>两阶段终止模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</guid><description>两阶段终止模式 Two Phase Termination
要优雅 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]T1优雅的终止线程T2，指的是给T2一个料理后事的机会。
错误思路 使用线程对象的stop()停止线程： stop方法会真正杀死线程会强制释放CPU资源和锁，但是不能保证清理工作完整（如关闭文件/连接等），会导致数据不同步等问题，不安全。已弃用。 使用System.exit(int)方法停止线程： 目的是停止一个线程，但是会让整个程序都停止。 使用打断标记实现 例-系统状态定时监控 需要有停止监控的功能：</description></item><item><title>中断</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%AD%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%AD%E6%96%AD/</guid><description>中断 线程中断即线程运行过程中被其他线程给打断了。
原理 中断无法直接终止另一[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]，只能发起通知。 中断需要被中断线程自己处理。 每个对象有一boolean标识是否有中断请求（来自其它线程/自身）。 线程 t1 想中断线程 t2，只需要在线程 t1 中将线程 t2 对象的中断标识置为 true，然后线程 t2 可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。 java.</description></item><item><title>临界区</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%B4%E7%95%8C%E5%8C%BA/</guid><description>临界区 critical section
一段代码块内如果存在堆共享资源的多线程读写操作，称这段代码块为临界区。
1 2 3 4 5 6 7 8 9 10 11 12 13 static int counter = 0; static void increment() // 临界区 { counter++; } static void decrement() // 临界区 { counter--; }</description></item><item><title>乐观锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B9%90%E8%A7%82%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B9%90%E8%A7%82%E9%94%81/</guid><description>乐观锁 乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]的技术来保证线程执行的安全性。
由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。
乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/悲观锁|悲观锁]]多用于”写多读少“的环境，避免频繁失败和重试影响性能。</description></item><item><title>二分查找</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>二分查找 https://www.zhihu.com/question/36132386
二分查找的重点 将数据分成三个区间 左 中 右 左 右是已经搜索过的区间，中间是待搜索区间 区间全部采用左闭右开 搜索区间 搜索的过程就是尽量扩大左 右 区间的范围，最终消灭中间区间 可能的目标会出现在四个位置： 左区间下界 中区间上界 中区间下界 右区间上界 !</description></item><item><title>二级页表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8/</guid><description>二级页表 二级页表的作用：
页表本身也占用内存空间，且还不小，而程序运行时也不一定要把所有页表都载入到内存。
所以连页表本身也可以部分载入内存，这就需要对页表也分段，形成二级页表结构。</description></item><item><title>享元模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式 可以用来解决[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/保护性拷贝|保护性拷贝]]频繁创建对象开销过大的问题。 重用数量有限的同一类对象。
英文名称：Flyweight pattern。
wikipedia： A ﬂyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects</description></item><item><title>任务调度线程池</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>任务调度线程池 用来代替[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Timer|Timer]]。
ScheduledExecutorService 1 2 3 4 5 6 7 8 9 ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); // 添加两个任务，希望它们都在 1s 后执行 executor.</description></item><item><title>伪共享</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%85%B1%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%85%B1%E4%BA%AB/</guid><description>伪共享 给数据加填充让数组的每个元素在缓存中强制换行，将cpu缓存中的数据拆分成多行，防止数据挨在一起后被连坐导致缓存集体失效。
因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中。 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效，降低效率。
![[z-oblib/z2-attachments/Pasted image 20220602143831.</description></item><item><title>保护性拷贝</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D/</guid><description>保护性拷贝 先复制到本地，再做修改
使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例：
1 2 3 4 5 6 7 8 9 10 11 12 13 public String substring(int beginIndex) { // 边界检查 if (beginIndex &amp;lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.</description></item><item><title>保护性暂停</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C/</guid><description>保护性暂停 基本实现 Guarded Suspension：用于一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]等待另一个线程的执行结果，只适用于产生一个消息的情况。
有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject。 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）。 JDK 中，[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/join|join]] 的实现、Future 的实现，采用的就是此模式。 因为要等待另一方的结果，因此归类到[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]模式。 ![[z-oblib/z2-attachments/Pasted image 20220528230352.png]]
产生结果的线程和消费结果的线程要一一对应。
实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @Slf4j public class Test10GuardedSuspention { public static void main(String[] args) { // T1 等待 T2 下载结果 GuardedObj go = new GuardedObj(); new Thread(()-&amp;gt;{ log.</description></item><item><title>信号</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7/</guid><description>信号 Linux中的绝大多数信号都是由内核发送的，所以在发送信号给某[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]之前，需要先陷入内核。
Linux中定义了很多信号类型，这些信号都有默认的处理方式（例如红灯亮的信号，人的默认处理方式是停下），但程序内也可以自定义信号的处理方式（例如，红灯亮了偏不停）。当内核将相关信号发送给进程，该进程接收到这些信号后，会触发对应的信号处理程序去处理该信号，从而打断该进程的正常执行流程。
在shell中，也支持信号机制，可通过kill命令发送信号给指定进程。可能这里会出现一个疑惑，刚才说信号绝大多数是由内核发送的，为什么kill命令（bash下有两个kill命令，一个是bash内置kill命令，一个是外置kill命令，但无论如何，都是用户进程）对应的进程能够发送信号给其它进程？这是因为kill发送的信号先是传递给内核的，内核再将这个信号传递给对应进程。所以这里需要进行一次[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]。
![[z-oblib/z2-attachments/Pasted image 20220803161416.png]]</description></item><item><title>信号量</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid><description>信号量 信号量（[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Semaphore|Semaphore]]）也称为信号灯，典故来源于荷兰：火车根据旗标来决定是否通行。 通过红绿灯理解[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号|信号]]和信号量，感觉它们似乎是一样的。但是，信号量机制是根据红绿灯的事件让人等待（进程阻塞）或不等待（进程继续运行），只有这两种行为；而信号机制是根据红绿灯事件做出任何可能的处理，并不一定是等待（阻塞）或前行（不阻塞）。
![[z-oblib/z2-attachments/Pasted image 20220803161603.png]]
信号量有很多种变体，下面简单描述其中一种信号量的规则：
在荷兰文中，通过叫passeren，释放叫vrijgeven，PV操作因此得名。
如果一个进程请求P操作(减1操作，即请求一个信号灯)，如果减去之后信号量的数值为负数，则该进程被阻塞，如果减去之后为0或正数，则放行该进程 如果一个进程请求V操作(加1操作，即释放或增加一个信号灯)，进程直接放行 如果请求V操作，如果加1之后仍为0或负数，则放行该进程的同时还唤醒另一个被阻塞的进程。如果加1后为正数，则直接添加一个信号灯资源 总结起来很简单：如果当前没有信号灯资源(小于或等于0)，那么消费信号灯(P原语)的进程就会被阻塞；如果有信号灯资源(大于0)，就直接放行。如果一个进程是来生产信号灯资源的(V原语)，那么这个进程当然要放行；因为添加了一个信号灯，那么还可以拥有唤醒一个被阻塞进程的能力(如果有被阻塞进程的话)。
最简单的信号量当然是初始时只使用1个信号灯，从而实现互斥锁（也称为互斥量）机制：P是申请锁操作，只有在有值为1的时候才能申请锁，否则被阻塞；V是释放锁，一直被放行。</description></item><item><title>偏向锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%81%8F%E5%90%91%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%81%8F%E5%90%91%E9%94%81/</guid><description>偏向锁 存在缘由 轻量级锁在没有竞争时，每次[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#获取锁|在5.2重入锁时]]都要重复执行[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static final Object obj = new Object(); public static void m1() { synchronized( obj ) { // 同步块 A m2(); } } public static void m2() { synchronized( obj ) { // 同步块 B m3(); } } public static void m3() { synchronized( obj ) { // 同步块 C } } 对应轻量级锁：</description></item><item><title>共享内存</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid><description>共享内存 共享内存（Shared Memory）是直接从内核维护的内存中划分一片内存，并将该内存映射到一个或多个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]中。
因为可能多个进程映射到同一共享内存，所以某进程对此内存数据的修改会直接影响其它进程，这样就能在进程之间传递消息。但也正因为如此，在使用共享内存时，应当保证没有两个或以上的进程同时修改共享内存数据。
共享内存是效率最高的进程间通信方式，它完全内存化操作，且没有任何内存拷贝行为，此外，内存映射到不同进程之后，操作系统就不再参与该片内存的操作，用户进程可以有权访问这段内存。
内存共享和[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件映射|文件映射]]非常像，不同之处就在于共享内存没有对具体的磁盘文件进行映射，而是直接映射物理内存到进程中。所以，它也映射在进程堆栈中间的那片未分配内存上。如图。
![[z-oblib/z2-attachments/Pasted image 20220803160824.png]]</description></item><item><title>内存模型总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid><description>内存模型总结 重点设计到[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]中：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 由 JVM 缓存优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/有序性|有序性]] - 由 JVM [[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/指令重排序|指令重排序]]优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/happens-before|happens-before]] 规则 原理方面 CPU 指令[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/并行|并行]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 模式方面 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]]模式的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 改进 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]模式之 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|balking]]</description></item><item><title>内部类</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>内部类 被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。
Inner Class 1 2 3 4 5 class Outer { class Inner { // 定义了一个Inner Class } } 上述定义的Outer是一个普通类，而Inner是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</description></item><item><title>冒泡排序</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid><description>冒泡排序</description></item><item><title>创建和运行线程</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B/</guid><description>创建和运行线程 创建时部分使用了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/lambda|lambda]]简化代码，为了便于理解未全部使用。 方法1 直接使用Thread 1 2 3 4 5 6 7 Thread t1 = new Thread() { @Override public void run() { log.</description></item><item><title>动态代理</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>动态代理 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class DynamicProxySample { interface Greet { Object sayHello(String name); } public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.</description></item><item><title>协变</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8D%8F%E5%8F%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8D%8F%E5%8F%98/</guid><description>协变 子类型可以隐性的转换为父类型。</description></item><item><title>协议数据单元</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83/</guid><description>协议数据单元 Actually, there are five words commonly used when we talk about layers of reference models (or protocol stacks): data, segment, packet, frame and bit.</description></item><item><title>单例模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 线程安全的实现 懒汉式： [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|balking]]模式：
1 2 3 4 5 6 7 8 9 10 11 12 13 public final class Singleton { private Singleton() { } private static Singleton INSTANCE = null; public static synchronized Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); } return INSTANCE; } } 双重校验锁 由懒汉模式改进</description></item><item><title>单调栈</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>单调栈 https://www.cnblogs.com/liang24/p/14200734.html #TODO</description></item><item><title>原子引用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/</guid><description>原子引用 AtomicReference AtomicMarkableReference AtomicStampedReference 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DecimalAccountSafeCas implements DecimalAccount { AtomicReference&amp;lt;BigDecimal&amp;gt; ref; public DecimalAccountSafeCas(BigDecimal balance) { ref = new AtomicReference&amp;lt;&amp;gt;(balance); } @Override public BigDecimal getBalance() { return ref.</description></item><item><title>原子性</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%80%A7/</guid><description>原子性</description></item><item><title>原子操作</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>原子操作 JDK提供了一些用于原子操作的类，在java.util.concurrent.atomic包下面。在JDK 11中，有如下17个类： ![[z-oblib/z2-attachments/原子类 1.jpg]] 从名字就可以看得出来这些类大概的用途：
原子更新基本类型 原子更新数组 原子更新引用 原子更新字段（属性） 以AtomicInteger的getAndAdd(int delta)方法为例 实际就是调用native方法，获取某个对象内存空间偏移offset处的变量，循环尝试获取该变量的值是否与线程持有值一致，一致则替换成目标值，不一致表示有其它线程修改过了。
先看看这个方法的源码：
1 2 3 public final int getAndAdd(int delta) { return U.</description></item><item><title>原子数组</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>原子数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** 参数1，提供数组、可以是线程不安全数组或线程安全数组 参数2，获取数组长度的方法 参数3，自增方法，回传 array, index 参数4，打印数组的方法 */ // supplier 提供者 无中生有 ()-&amp;gt;结果 // function 函数 一个参数一个结果 (参数)-&amp;gt;结果 , BiFunction (参数1,参数2)-&amp;gt;结果 // consumer 消费者 一个参数没结果 (参数)-&amp;gt;void, BiConsumer (参数1,参数2)-&amp;gt; private static &amp;lt;T&amp;gt; void demo( Supplier&amp;lt;T&amp;gt; arraySupplier, Function&amp;lt;T, Integer&amp;gt; lengthFun, BiConsumer&amp;lt;T, Integer&amp;gt; putConsumer, Consumer&amp;lt;T&amp;gt; printConsumer ) { List&amp;lt;Thread&amp;gt; ts = new ArrayList&amp;lt;&amp;gt;(); T array = arraySupplier.</description></item><item><title>原子整数</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0/</guid><description>原子整数 J.U.C 并发包提供了：
AtomicBoolean AtomicInteger AtomicLong 以 AtomicInteger 为例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 AtomicInteger i = new AtomicInteger(0); // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.</description></item><item><title>原子累加器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8/</guid><description>原子累加器 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]&amp;hellip; 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。
累加单元不会超过cpu的核心数，核心数越多提升越明显。
源码分析 #TODO</description></item><item><title>双亲委派</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</guid><description>双亲委派 https://blog.csdn.net/weixin_36586120/article/details/117457014
定义 类加载器加载一个类时，会先将其逐级上交给父级加载器尝试加载 父子关系不是继承维护，而是组合，每个类加载器都持有一个 parent 字段，指向父加载器。 父级加载器先检查是否已加载，再尝试递归上交 若无法处理再向下委派加载任务。 ![[z-oblib/z2-attachments/20210601230727770.png]]
目的 双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。</description></item><item><title>双向认证</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</guid><description>双向认证</description></item><item><title>双层not_exists嵌套</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</guid><description>双层not_exists嵌套 SQL 中的 EXISTS 到底做了什么？ - 知乎 (zhihu.com) SQL 双层 not exist 嵌套
WHERE 做了什么 1 2 3 SELECTSno,SnameFROMStudentWHERESdept=&amp;#39;IS&amp;#39; DBMS 会扫描 表中的每一条记录 判断后面的逻辑表达式的值是否为 True 如果为 True，则将当前这条记录放到结果集里面去 如果逻辑表达式的值为 False 则不放 相关子查询 查询每个学生超过其选修的所有课程的平均成绩的课程的课程号:</description></item><item><title>变量命名规范</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid><description>变量命名规范 H hdr = HeaDeR = header 常出现在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|elf]]结构定义中，如shdr为 section header R rel = relocation = 重定位 rel.</description></item><item><title>变量的线程安全</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid><description>变量的线程安全 成员变量 如果它们没有共享，则[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]]，需要考虑线程安全 局部变量 局部变量是线程安全 局部变量引用的对象不一定线程安全 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围，需要考虑线程安全 分析 非引用局部变量 1 2 3 4 public static void test1() { int i = 10; i++; } 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。</description></item><item><title>可见性</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%AF%E8%A7%81%E6%80%A7/</guid><description>可见性 举例 main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：
1 2 3 4 5 6 7 8 9 10 11 12 13 static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-&amp;gt;{ while(run){ // .</description></item><item><title>同步</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5/</guid><description>同步 所有的执行顺序都严格地和代码书写的顺序一致。
以调用方角度 需要等待结果返回，才能继续运行就是同步。
线程同步 线程同步是线程之间按照一定的顺序执行。
优点 同步最大的优点是思路清晰。你永远可以知道你的程序是按照怎样的顺序执行的，不用担心任何意料之外的情况。
缺点 在某些情境下，它会带来性能的浪费。
以一个生活中的场景为例：你在网上下载一个文件，但是文件很大，需要很长时间才能下完。这时候，你肯定不会盯着进度条一点点走，而是去做点别的事情，读一会书，看一会电影，之类的。
但如果有一个完全“同步”的人，他为自己设定的程序是下载这个文件，然后运行它，这样的话，他为了不让自己的运行逻辑乱掉，就会一直守在电脑前，直到文件下载完成才做下一步的工作。正常人肯定不能忍受这样无聊的等待，也不会希望自己的程序在这种无聊的事上浪费时间。</description></item><item><title>哲学家就餐问题</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</guid><description>哲学家就餐问题 ![[z-oblib/z2-attachments/Pasted image 20220529223523.png]]
有五位哲学家，围坐在圆桌旁：
他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package test; import lombok.</description></item><item><title>四次挥手</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid><description>四次挥手 我要走了：客户端完成所有数据传输，向服务端发送一个FIN=1的终止连接报文，并设置序列号为传输数据的最后一个字节序号，发送后客户端进入FIN-Wait一阶段。 知道了，最后一点东西给你打包带上，稍等：服务端接收到终止连接报文，并返回给客户端一个ACK确认报文，此时客户端进入FIN-Wait二阶段，客户端无法再进行数据传输，然而服务端可能还存在没有发送给客户端的数据，因此不能立刻关闭连接。 所有东西都在这里了，拿好：服务端在发送完所有数据后，再发送一个ACK=1，FIN=1的终止确认给客户端，此时服务端进入LAST-ACK状态。 好的，你忙吧2MSL不找我，我就自己走了：客户端收到响应后，返回给服务端一个ACK=1的响应，并进入TIME-WAIT状态，等待时间为2MSL，即两倍的最大数据段传输时间。</description></item><item><title>回调</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9E%E8%B0%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9E%E8%B0%83/</guid><description>回调 A类a方法调用B类的b方法，b方法再调用A类的c方法 就是不光把工作内容交给别的线程做，还要把结果处理也交给别的线程做。
回调的本质，是将一个任务分成两部分，在耗时操作之前的部分，和耗时操作之后的部分，后者是前者的继续，或者叫做[[续体]]（continuation）。回调式就是把续体写成回调函数的形式，传递到其他地方，这种操作又叫做续体传递（continuation-passing）。从这个层面上看，回调是续体传递风格（Continuation-Passing Style, CPS）的一种。
举例 现在领导要员工A做一件事，给他发布了任务，需要员工A做完后再通知领导。
对于领导来说：发布任务（fabuTask）,获得结果（result）
对于员工来说：处理任务（doSomthing）,通知领导结果（result）
任务发布者 任务发布者定义了回调函数，回调函数的参数就是未来任务执行者提交的结果。
1 2 3 4 5 6 7 /** * 回调的方法 * */ public interface CallBack { void result(String result); } 领导发布的任务：让员工做事：</description></item><item><title>基地址</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%9F%BA%E5%9C%B0%E5%9D%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%9F%BA%E5%9C%B0%E5%9D%80/</guid><description>基地址 计算 linux - ELF的基地址 | 码农俱乐部 - Golang中国 - Go语言中文社区 (mlog.club) ELF 文件 - CTF Wiki (ctf-wiki.org)</description></item><item><title>基本语法</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法</description></item><item><title>多把锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%8A%8A%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E6%8A%8A%E9%94%81/</guid><description>多把锁 代码演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class BigRoom { public void sleep() { synchronized (this) { log.</description></item><item><title>套接字</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>套接字 套接字（Socket）用于协调不同计算机上的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]间通信，也就是基于网络的通信。当然，也可以在本机上使用套接字进行进程间的通信。
套接字通信的方式非常多，有Unix域套接字、TCP套接字、UDP套接字、链路层套接字等等。但最常用的肯定是TCP套接字。所以，这里介绍下TCP Socket通信方式，稍后再单独介绍Unix域套接字。
TCP Socket用于客户端、服务端的基于TCP协议的通信，所以在客户端和服务端均需要创建一个套接字。创建TCP套接字时会返回这个套接字的文件描述符，可通过这个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件描述符|文件描述符]]对套接字进行读和写操作。
对比一下，当一个程序需要对一个磁盘文件同时进行读写操作（在命令行下似乎没有找到这种命令，但通过编程方式是很容易实现的）时，由于只通过单个文件描述符同时负责读和写，很可能需要通过不断移动文件指针的方式来改变读写的位置，否则数据很容易错乱。
而TCP套接字也是通过单个文件描述符进行读写套接字的，为了保证读和写的位置不错乱，操作系统在内核空间为每个TCP套接字维护了两个buffer空间，一个buffer用于写、一个buffer用于读。提供读的buffer空间称为recv buffer，提供写的buffer空间称为send buffer，它们统称为socket buffer。
所以，服务端和客户端通过两个套接字通信就简单了，一端向send buffer写数据，该buffer的数据会通过已经建立好的TCP连接发送到另一端的recv buffer，于是另一端只需从recv buffer中读数据即可实现不同计算机上的进程间通信。过程如图。
![[z-oblib/z2-attachments/Pasted image 20220803132920.png]]</description></item><item><title>委派</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%A7%94%E6%B4%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%A7%94%E6%B4%BE/</guid><description>委派 A 委派 B 做某事，则 B 内会有 A 的实例，并调用 A 的方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Java program to illustrate // delegation class RealPrinter { // the &amp;#34;delegate&amp;#34; void print() { System.</description></item><item><title>字段更新器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8/</guid><description>字段更新器 AtomicReferenceFieldUpdater // 域 字段 AtomicIntegerFieldUpdater AtomicLongFieldUpdater 利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常
#TODO</description></item><item><title>字符串表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8/</guid><description>字符串表 字符串表节包含以空字符结尾的字符序列，通常称为字符串。目标文件使用这些字符串表示符号和节的名称。可以将字符串作为字符串表节的索引进行引用。
第一个字节（索引零）包含空字符。同样，字符串表的最后一个字节也包含空字符，从而确保所有字符串都以空字符结尾。根据上下文，索引为零的字符串不会指定任何名称或指定空名称。
允许使用空字符串表节。节头的 sh_size 成员值为零。对于空字符串表，非零索引无效。
节头的 sh_name 成员包含节头字符串表的节索引。节头字符串表由 ELF 头的 e_shstrndx 成员指定。下图显示了具有 25 个字节的字符串表，并且其字符串与各种索引关联。
举例 ELF 字符串表： ![[z-oblib/z2-attachments/Pasted image 20220911030139.</description></item><item><title>安装qemu</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/%E5%AE%89%E8%A3%85qemu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/%E5%AE%89%E8%A3%85qemu/</guid><description>安装qemu 1 2 3 4 5 sudo apt-get install qemu #user mode,包含qemu-mips-static，qemu-mipsel-static,qemu-arm-static等 sudo apt-get install qemu-user-static #system mode，包含qemu-system-mips，qemu-system-mipsel,qemu-system-arm等 sudo apt-get install qemu-system</description></item><item><title>寄存器，test，cmp剖析</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</guid><description>寄存器，test，cmp剖析 状态寄存器 首先复习一下状态寄存器.
PSW(Program Status Word)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,如下所示：
![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/汇编/z-attachments/Pasted image 20220917161214.png]]
条件码：
OF(Overflow Flag)溢出标志 溢出时为1，否则置0 标明一个溢出了的计算 SF(Sign Flag)符号标志 结果为负时置1，否则置0 ZF(Zero Flag)零标志, 运算结果为0时置1，否则置0 CF(Carry Flag)进位标志 进位时置1，否则置0 注意:Carry标志中存放计算后最右的位 AF(Auxiliary carry Flag)辅助进位标志 记录运算时第3位(半个字节)产生的进位置 有进位时1,否则置0。 PF(Parity Flag)奇偶标志 结果操作数中1的个数为偶数时置1，否则置0 控制标志位：</description></item><item><title>对象内存构成</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90/</guid><description>对象内存构成 Java 中通过 new 关键字创建一个类的实例对象，对象存于内存的堆中并给其分配一个内存地址。 ![[z-oblib/z2-attachments/Pasted image 20220428151815.png]] 在 JVM 中，Java对象保存在堆中时，由以下三部分组成：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/对象头|对象头]]（object header）：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。 实例数据（Instance Data）：主要是存放类的数据信息，父类的信息，对象字段属性信息。 对齐填充（Padding）：为了字节对齐，填充的数据，不是必须的。 ![[z-oblib/z2-attachments/Pasted image 20220428151834.</description></item><item><title>对象头</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%A4%B4/</guid><description>对象头 ![[z-oblib/z2-attachments/Pasted image 20220428151706.png]]
在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针。
普通对象 1 2 3 4 5 |--------------------------------------------------------------| | Object Header (64 bits) | |------------------------------------|-------------------------| | Mark Word (32 bits) | Klass Word (32 bits) | |------------------------------------|-------------------------| 数组对象 1 2 3 4 5 |------------------------------------------------------------------------------| | Object Header (96 bits) | |------------------------------|----------------------|------------------------| | Mark Word(32bits) | Klass Word(32bits) | array length(32bits) | |------------------------------|----------------------|------------------------| Mark Word [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]</description></item><item><title>对象的引用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</guid><description>对象的引用 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 当内存不足时 对象缓存 内存不足时终止 弱引用 正常垃圾回收时 对象缓存 垃圾回收后终止 虚引用 正常垃圾回收时 跟踪对象的垃圾回收 垃圾回收后终止 https://juejin.</description></item><item><title>寻址方式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</guid><description>寻址方式 寻址方式: 指令中指明操作数存放位置的表达方式.
指令中操作数的数据存放位置情况 存放指令中 (立即数) 操作数包含在指令中 备操作数据直接表示在指令的操作数字段中 紧跟在操作码之后 例如 MOV AL, 10H 存放于寄存器中 (寄存器操作数) 数据存放在 CPU 的一个寄存器中 例如 INC CX 存放于存储器中 (存储器操作数) 数据再内存或 I/I 端口中 存放数据的偏移地址以某种方式表示在指令中 例如 MOV AX, [2500H] 其中 [2500] 为存储器操作数 存储器操作数中操作的数字段指示此操作数的偏移地址 段地址由某个段寄存器提供 默认为 DS 提供 寻址方式分类 立即数寻址 操作数为立即数 直接存放在指令的操作数字段 只允许源操作数为立即数 目标操作数必须是寄存器或存储单元 给寄存器或存储单元赋值 寄存器寻址 直接在指令中写出寄存器名称 存储器寻址 直接寻址 操作数存在内存中, 操作数的偏移地址直接表示在指令中 表示格式: [偏移地址] 默认操作数存放在内存的数据段中 例如 MOV AL, [1064H] 段超越指明使用的段 寄存器间接寻址 基址加变址寻址 相对加基址变址寻址</description></item><item><title>导入表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%85%A5%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%85%A5%E8%A1%A8/</guid><description>导入表 (34条消息) PE导入表和IAT表的原理及工作关系_C4cke的博客-CSDN博客_pe文件iat表
分类 IAT: Import Address Table 导入（函数）地址表 INT: Import Name Table 导入（函数）名称表 结构 Import Descriptor 导入表，是记录PE文件中用到的动态连接库的集合，一个dll库在导入表中占用一个元素信息的位置，这个元素描述了该导入dll的具体信息。如dll的最新修改时间、dll中函数的名字/序号、dll加载后的函数地址等。而一个元素即一个结构体，一个导入表即该结构体的数组，其结构体如下所示：</description></item><item><title>导出表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%87%BA%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%87%BA%E8%A1%A8/</guid><description>导出表 导出表的作用是自身提供一张清单，表明自己又哪些函数，大多是dll为exe提供函数，存在导出表。</description></item><item><title>工作线程</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B/</guid><description>工作线程 定义 让有限的工作[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]（Worker Thread）来轮流[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/异步|异步]]处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]，也体现了经典设计模式中的[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]]。
例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）。
注意，不同任务类型应该使用不同的线程池，这样能够避免[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工作线程#饥饿|饥饿]]，并能提升效率。
例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工。
饥饿 固定大小线程池会有饥饿现象：
两个工人是同一个线程池中的两个线程 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 后厨做菜：没啥说的，做就是了 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class TestDeadLock { static final List&amp;lt;String&amp;gt; MENU = Arrays.</description></item><item><title>工厂模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>工厂模式 作用 把对象的创建和使用过程分割开来： 将对象实例化的动作解耦到一个工厂中，后续要修改或添加其它实例，只需要修改工厂方法。
例如：
如果对类A的功能进行修改，衍生出子类B继承自原始类A，则需要在所有实例化A的地方修改实例化代码。
而有工厂方法后，只需要修改工厂中的事件，将原来return new A() 改为 return new B()即可。
普通工厂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 interface fruit{ public abstract void eat(); } class Apple implements fruit{ public void eat(){ System.</description></item><item><title>并发</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91/</guid><description>并发 并发（concurrent）是同一时间应对（dealing with）多件事情的能力。 操作系统通过任务调度器组件，将CPU的时间片（win下最小15ms）分给不同的任务使用。CPU在多个任务之间快速切换，时间非常短，让人产生了一种多个任务在同时执行的错觉，实际上任务还是串行执行。
![[z-oblib/z2-attachments/Pasted image 20220525143804.png]]</description></item><item><title>并发集合容器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</guid><description>并发集合容器 并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。
我们知道在java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。
而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class TestVector { private Vector&amp;lt;String&amp;gt; vector; //方法一 public Object getLast(Vector vector) { int lastIndex = vector.</description></item><item><title>并查集</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>并查集 并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。
解释 并查集其实完成了两个操作 查找一个元素的根是谁 合并两个不同的树 用处 并查集初始化 并查集一般是用一个一维数组来存储的，其中pre[i]=i表示自己和自己是连通的，也就是说还没有往点之间添加路径。
![[z-oblib/z2-attachments/Pasted image 20220506195441.png]]
find() 找节点对应根节点 1 2 3 4 5 6 7 // 找某个节点的根节点 int find(int x) { while (fams[x]!</description></item><item><title>并行</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E8%A1%8C/</guid><description>并行 并行（parallel）是同一时间动手做（doing）多件事情的能力。 两个CPU核心真正同时运行两个任务（线程）。
![[z-oblib/z2-attachments/Pasted image 20220525143900.png]]</description></item><item><title>开闭原则</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid><description>开闭原则 开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
闭合原则 不想向外暴露的设置成final/private。</description></item><item><title>异常</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</guid><description>异常 通常，Java的异常(包括Exception和Error)分为：
检查异常（checked exceptions） 非检查的异常（unchecked exceptions）。 其中根据Exception异常进行划分，可分为： 运行时异常 非运行时异常 检查异常 就是编译器要求你必须处置的异常。不知道你编程的时候有没有遇到过，你写的某段代码，编译器要求你必须要对这段代码try&amp;hellip;catch，或者throws exception，如果你遇见过，没错，这就是检查异常，也就是说，你代码还没运行呢，编译器就会检查你的代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理。
处理 1、继续抛出，消极的方法，一直可以抛到java虚拟机来处理，就是通过throws exception抛出。
2、用try&amp;hellip;catch捕获
注意，对于检查的异常必须处理，或者必须捕获或者必须抛出
分类 除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。</description></item><item><title>异步</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5/</guid><description>异步 以调用方角度 不需要等待结果返回，就能继续运行就是异步。</description></item><item><title>快速取模</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%8F%96%E6%A8%A1/</guid><description>快速取模 使用位运算代替取模： 前提：b为2^n $a % b == a &amp;amp; (b - 1)$
原理 $X % 2^n = X &amp;amp; (2^n - 1)$</description></item><item><title>快速幂</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid><description>快速幂 二分的思想。
指数转换为二进制 二进制树又可以拆分成1 2 4 8&amp;hellip;的和 而1 2 4 8&amp;hellip;之间都是 X2的关系，每一位都是前一位的2倍，计算更高位只用x2 这样时间复杂度就降低了 同样的思路可以实现快速乘，只要将部分乘法换成加法即可。
基本方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class FastPower { // 递归 static int byRecursion(int base, int exponent) { if (exponent==0) // 指数为0 return 1; if (exponent % 2 == 1) { // 指数为奇数 return byRecursion(base, exponent-1) * base; } int tmp = byRecursion(base, exponent/2); // 指数为偶数 return tmp * tmp; // 除以2后，时间复杂度降为 log(n)，不用重复算两次byRecursion(base, exponent/2)了。 } // 迭代 static int byIteration(int base, int exponent) { int ans = 1; while(exponent&amp;gt;0) { if ((exponent &amp;amp; 1) == 1) { // 判断指数最低位是否为1，是的话则将当前 ans *= base; // 底数相乘指数相加 } base *= base; // 不断计算出 x^2 x^4 x*8 .</description></item><item><title>快速排序</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快速排序 快速排序是 [[2_0_2-计算机科学/2_0_2_0_2_1-数据结构与算法/冒泡排序|冒泡排序]] 的改进版本。
快排的每一轮都是讲一个基数归为，所以外层要循环 n 次： ![[z-oblib/z2-attachments/3.9-1.png]]
时间复杂度 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。 每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。 这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。 当然在最坏的情况下，仍可能是相邻的两个数进行了交换。 因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(N2)，它的平均时间复杂度为 O(NlogN)。 其实快速排序是基于一种叫做“二分”的思想。
实现 双指针版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 快速排序 public void quickSort(int left, int right) { // 子集只有一个元素旧没必要继续切分快排了 int lens = right - left + 1; if (lens&amp;lt;2) return; int base = num[left]; // 取区间第一个元素作base值 int curLeft = left; // 记录当前左区间下标，用于递归 int curRight = right; // 记录当前右区间下标，用于递归 boolean leftReady = false, rightReady = false; // 标志是否找到需要交换的数 while (left!</description></item><item><title>悲观锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%82%B2%E8%A7%82%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%82%B2%E8%A7%82%E9%94%81/</guid><description>悲观锁 悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]在执行。</description></item><item><title>指令级并行</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C/</guid><description>指令级并行 名词解释 Clock Cycle Time 主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.</description></item><item><title>指令重排序</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/</guid><description>指令重排序 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。
为什么指令重排序可以提高性能？
简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，流水线技术产生了，它的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2，这样就大大提高了效率。
但是，流水线技术最害怕中断，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。
我们分析一下下面这个代码的执行情况：
1 2 a = b + c; d = e - f; 先加载b、c（注意，即有可能先加载b，也有可能先加载c），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</description></item><item><title>文件指针</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88/</guid><description>文件指针 2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)
&amp;ldquo;文件指针(file pointer)&amp;ldquo;指向进程用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符值。而文件描述符值是文件描述符表中的一个索引。从某种意义上说文件指针就是句柄的句柄。 每个被使用的文件都在内存中开辟了一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，该结构体类型是由系统定义的，取名为FILE。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 /*FILE结构体*/ #ifndef _FILE_DEFINED struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //当前缓冲区的相对位置 char *_base; //指基础位置(即是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //缓冲区大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 实际上，FILE结构是间接地操作系统的文件控制块 (FCB)来实现对文件的操作的，如下图：</description></item><item><title>文件描述符</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid><description>文件描述符 2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。
具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。内核使用3种数据结构表示打开的文件，他们之间的关系决定了在文件共享方面一个进程对另一个进程的影响。
进程级的文件描述符表。每个进程在进程表中都有一个纪录项，纪录项中包含一张打开文件描述符表，每个文件描述符各占一项，与每个文件描述符相关的是： 文件描述符标志 指向一个文件表项的指针 系统级的打开文件描述符表。内核为所有打开文件维护一张文件表项，每个文件表项包含： 文件状态(读 写 同步 非阻塞等) 当前文件偏移量 指向改文件inode（Linux）节点(v节点unix )的指针 文件系统的i-node表。每打开一个文件或设备，都有一个inode节点结构，inode节点包含了文件类型和对此文件进行操作函数的指针，对于大多数文件，inode节点还包含了文件的i节点索引节点，这些信息是在打开文件时从磁盘读入内存的，所以，文件的所有文件信息都是随时可用的。inode节点包含了文件的所有者，文件长度，指向文件实际数据块在磁盘上位置的指针等。  不同的进程打开同一个文件，那么他们应该有各自对应的文件表表项。因为文件表表项记录了进程读写文件时的偏移量和存取权限。多个进程不可能共享一个文件偏移量。另外他们各自打开文件的权限也可能是不同的，有的是为了读、有的为了写，有的为了读写。所以，他们应该有不同的文件表表项。</description></item><item><title>文件映射</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84/</guid><description>文件映射 文件映射（Memory-mapped file）是将磁盘上文件的某段数据映射到内核的一段物理内存上，然后将此物理内存映射到一个或多个进程的虚拟内存中。映射了文件的进程可以直接读、写这段内存来达到读、写磁盘文件的功能。如果多个进程请求映射的文件区段相同，则只映射一次。
所以，文件映射进行了两次映射，一次映射是将属于磁盘文件的部分或全部数据块映射到物理内存页中，另一次映射是将物理内存页映射到进程的虚拟页上。
如图，图中假设磁盘数据块大小和内存页大小相同，将某文件中的6个数据块（可能只是该文件的一部分数据）映射到物理内存的页1、2、3、4、5、6中，并且两个进程都映射该磁盘文件相同的数据区域，所以两个进程都指向相同的物理内存页。
![[z-oblib/z2-attachments/Pasted image 20220803141346.png]]
使用文件映射时，最开始该内存区是空的。当访问这段内存时，如果访问的数据不在内存中（例如第一次访问），将出现page fault，于是会从磁盘中读取相应的数据块拷贝到这段内存（基于操作系统提供的预读优化，可能一次性会多读一些数据到映射的内存中）。当向此内存区写数据时，会自动写入到磁盘文件对应的数据块中（可以设置为其它写方式）。
此外，通过设置文件映射方式，还支持写时复制。某进程要向该映射区的某内存页写数据时，会拷贝该页到自己的虚拟内存中，然后写数据到该副本页，而不会影响映射区的数据，而且以后该进程对该页的操作都将使用该副本。
既然每个进程都能访问到文件映射的物理内存，那么这段物理内存分配在进程虚拟内存布局的哪一部分呢？这个简单思考下即可得知答案，进程的虚拟内存中，只有堆内存和堆栈中间的未分配地址空间是可以由用户进程自由使用的地址区域，如果将文件映射到堆中，假如映射的文件数据较大，已分配的堆内存中空闲页很可能不足以映射该文件，操作系统需要为其分配更多的堆内存，另一方面，就算当前堆内存能放下文件映射，但也很可能因此而导致空闲页所剩不多，进程之后的运行很可能还是要请求分配新的堆内存，如此看来，倒不如直接映射在堆栈中间那片未分配的地址空间，并且为堆和栈都预留一段未分配空间。图中给出文件映射在进程内存布局中的位置。
![[z-oblib/z2-attachments/Pasted image 20220803141403.png]]</description></item><item><title>无状态</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%8A%B6%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%8A%B6%E6%80%81/</guid><description>无状态 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的。因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】。</description></item><item><title>无锁小结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</guid><description>无锁小结 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS与volatile|CAS与volatile]] API [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子整数|原子整数]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子引用|原子引用]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子数组|原子数组]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/字段更新器|字段更新器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子累加器|原子累加器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Unsafe|Unsafe]] 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/LongAdder|LongAdder]] 源码 伪共享</description></item><item><title>晶体管</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E6%99%B6%E4%BD%93%E7%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E6%99%B6%E4%BD%93%E7%AE%A1/</guid><description>晶体管 所有可以通过一个电流或电压控制另一个电流或电压的器件。</description></item><item><title>最短路径</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid><description>最短路径 该算法的关键是： 找两个集合之间的最短路径，分别是已经确定的点的集合/未确定点的集合。 每次都在已确定点中的未知道路找最短的路。 因此可以将路都加入优先级队列，自动排序。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 import java.</description></item><item><title>有序性</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%9C%89%E5%BA%8F%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%9C%89%E5%BA%8F%E6%80%A7/</guid><description>有序性 JVM 会在不影响正确性的前提下，可以调整语句的执行顺序。
有序性被破坏的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean ready = false; // 线程1 执行此方法 public void actor1(I_Result r) { if(ready) { r.</description></item><item><title>构建RPC思路</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/%E6%9E%84%E5%BB%BARPC/%E6%9E%84%E5%BB%BARPC%E6%80%9D%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/%E6%9E%84%E5%BB%BARPC/%E6%9E%84%E5%BB%BARPC%E6%80%9D%E8%B7%AF/</guid><description>构建RPC思路 问题 客户端如何知道服务端地址 客户端如何知道有哪些服务 客户端如何向服务端传递参数 数据如何编解码 服务端如何验证客户端和请求合法 服务端如何将执行结果返回给客户端 客户端如何等待结果 服务端如何同时处理多个请求</description></item><item><title>枚举</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%9E%9A%E4%B8%BE/</guid><description>枚举 枚举是一个类，内部写规定了这个类的所有实例。
用途 编译器类型检测 和int定义的常量相比，使用enum定义枚举有如下好处：
首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：
1 2 3 int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator &amp;#39;==&amp;#39; } 其次，不可能引用到非枚举的值，因为无法通过编译。</description></item><item><title>标志寄存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>标志寄存器 结构： ![[z-oblib/z2-attachments/Pasted image 20220912223816.png]]
含义： ![[z-oblib/z2-attachments/Pasted image 20220912223822.png]]
状态标志 用于记录程序运行结果的状态信息 CF 进位标志 (Carry Flag) 当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0 ZF 零标志 (Zero Flag) 弱运算结果为 0, 则置 1, 否则 0 SF 符号标志 (Sign Flag) 若运算结果最高位(符号位)为 1, 则置 1, 否则 0 PF 奇偶标志 (Parity Flag) 运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0 OF 溢出标志 (Overflow Flag) 运算结果有溢出, 则置 1, 否则 0 溢出: 有符号数的运算结果不正确 AF 辅助进位标志 (Auxiliary Carry Flag) 运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0 控制标志 用于控制处理器执行指令 DF 方向标志 (Direction Flag) 用于串操作指令, 控制地址的变化方向 1 则存储器地址自动增加 0 则存储器地址自动减少 CLD 用于复位 DF = 0 STD 用于置位 DF = 1 IF 终端允许标志 (Interrupt-enable Flag) 0 禁止中断 1 允许中断 CLI 用于复位 IF = 0 STI 用于置位 IF = 1 TF 陷阱标志 (Trap Flag) 0 处理器正常工作 1 处理器单步执行</description></item><item><title>栈帧</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%A0%88%E5%B8%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%A0%88%E5%B8%A7/</guid><description>栈帧 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的虚拟机栈的栈元素。
栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在 虚拟机里面从入栈到出栈的过程。
在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了。
因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
局部变量表 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。
动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支付方法调用过程中的动态连接（Dynamic Linking）。
在类加载阶段中的解析阶段会将符号引用转为直接引用，这种转化也称为静态解析。另外的一部分将在每一次运行时期转化为直接引用。这部分称为动态连接。
返回地址 当一个方法开始执行后，只有2种方式可以退出这个方法 ：</description></item><item><title>栈迁移</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</guid><description>栈迁移</description></item><item><title>模板模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid><description>模板模式 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。
意图： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
主要解决： 一些方法通用，却在每一个子类都重新写了这一方法。
何时使用： 有一些通用的方法。
如何解决： 将这些通用算法抽象出来。
关键代码： 在抽象类实现，其他步骤在子类实现。
应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</description></item><item><title>死锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%AD%BB%E9%94%81/</guid><description>死锁 原因 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/多把锁|多把锁]]的情况可能会发生死锁：
一个线程需要同时获取多把锁，这时就容易发生死锁 t1 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]] 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package test; import lombok.</description></item><item><title>段寄存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>段寄存器 8086CPU 有 4 个段寄存器
每个段寄存器用来确定一个逻辑段的起始位置
每种逻辑段均有自己的用途
CS: 代码段寄存器 (Code Segment) 利用 CS:IP 取得下一条要执行的指令 DS: 数据段寄存器 (Data Segment) 利用 DS:EA 存取数据段中的数据 SS: 栈段寄存器 (Stach Segment) 利用 CS:IP 操作堆栈顶的数据 ES: 附加段寄存器 (Extra Segment) 利用 ES:EA 存取附加段中的数据 EA 是偏移地址, 称之为有效地址 EA</description></item><item><title>汇编快速入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>汇编快速入门 寄存器 CS : IP 物理地址 = 段地址 X 10H + 偏移地址 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H 同一个物理地址可以由不同的段地址和偏移地址构成 段寄存器 CS: 代码段寄存器 (Code Segment) 主要关注此寄存器 DS: 数据段寄存器 (Data Segment) SS: 栈段寄存器 (Stach Segment) ES: 附加段寄存器 (Extra Segment) 程序执行 任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:</description></item><item><title>泛型</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B/</guid><description>泛型 类型擦除 下面的例子无法编译通过：
1 2 3 4 5 6 7 // generics/HasF.java public class HasF { public void f() { System.</description></item><item><title>活跃性</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E8%B7%83%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E8%B7%83%E6%80%A7/</guid><description>活跃性 包括：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]]</description></item><item><title>活锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E9%94%81/</guid><description>活锁 活锁出现在两个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]互相改变对方的结束条件，最后谁也无法结束，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class TestLiveLock { static volatile int count = 10; static final Object lock = new Object(); public static void main(String[] args) { new Thread(() -&amp;gt; { // 期望减到 0 退出循环 while (count &amp;gt; 0) { sleep(0.</description></item><item><title>流</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%B5%81/</guid><description>流 基本概念 流只是一个比喻。
任何比喻都无法完美。
流比喻数据的均匀连续性。
你从水龙头接水，无论拿杯子，脸盘，还是桶。只要水流不断，你都可以接满。
假设水龙头吐出的是大小不一的冰块，那就不叫连续了。
当然，计算机最小单位是字节，所以流数据最小单位也是字节（byte)。当然可以通过写程序模拟以位(bit 每字节8位）为单位的bit流。
模拟bit流多用在压缩算法。平常我们更多时候是需要连续的字节以某种方式组合起来读入或写出，比如以字符形式就是两个两个读（char，在java里是两个字节。）。看看jdk里有什xxxstream的类。
你的问题是自我想像流一定是个管子。其实在计算机世界里，管子是管子，流是流。
以文件流为比喻。你下载了1个G的某片，存在磁盘上总要占用一大块磁盘空间（物理上很可能是不连续的，但暂时想像它们是家里瓷盘上的一汪水）然后你凑过嘴，把嘴嘟起来，陶醉（假装）地吸上一口，字节带着细微的水花从你嘴唇穿入，这时候磁盘的一汪字节和你产生吸力的嘴之间，没有吸管，但真的有流。
你说嘴巴吸不了磁盘上的字节。你说甚至一G的文件在磁盘上很可能是分在不连续的扇区存储的，怎么有连续的流呢？
你说得很对。。。也许你看本地片子时，突然某处稍卡了一下，你怀疑是不是正好上个字节和下个字节之间 隔了几个扇区几个 磁道
。。。但其实通常不是的。操作系统不会这么直接。它会趁你慢慢欣赏某些片段时，早就将数据从慢腾腾的磁盘预读到快如闪电的内存中了，这个位于磁盘和播放器程序之间的缓存区，是很像你说的管子，但它真的和流这个对象没有什么关系，在代码中的流对象看来 那缓存区就是操作系统提供的文件。
JAVA代码是在 虚拟机</description></item><item><title>流</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%81/</guid><description>流 2、文件指针与文件描述符 - 孤情剑客 - 博客园 (cnblogs.com)
在C语言中引入了流(stream)的概念。它将数据的输入输出看做是数据的流入和流出，这样不管是磁盘文件或者是物理设备（打印机，显示器，键盘等）都可以看做一种流的源和目的地，视他们为同一种东西，而不管其具体的物理结构，即对他们的操作，就是数据的流入和流出。这种把数据的输入输出作为操作对象，抽象化为一种流，而不管它的具体结构的方法有利于编程，而设计流的输出操作的函数可用于各种对象，与具体的实体无关，即具有通用性。
标准I/O库的所有操作都是围绕流来进行的，在标准I/O中流用FILE *来描述。
标准I/O的核心对象就是流。当用标准I/O打开一个文件时，就会创建一个FILE结构体描述该文件（或者理解为创建一个FILE结构体和实际打开的文件关联起来）。我们把这个FILE结构体形象的称为流。标准I/O函数都基于流进行各种操作。
C语言将每个文件简单地作为顺序字节流(如下图)。
![[z-oblib/z2-attachments/Pasted image 20220802234132.png]]
每个文件用文件结束符结束，或者在特定字节数的地方结束，这个特定的字节数可以存储在系统维护的管理数据结构中。 当打开文件时，就建立了和文件的关系。在开始执行程序的时候，将自动打开3个文件和相关的流：标准输入流、标准输出流和标准错误。流提供了文件和程序的通信通道。例如，标准输入流使得程序可以从键盘读取数据，而标准输出流使得程序可以在屏幕上输出数据。</description></item><item><title>消息队列</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 消息队列（Message Queue）用于在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]之间传递较小的数据，进程可以向一个或多个消息队列中放入数据（消息），其它进程可以从消息队列中按照各种方式（例如最典型的先进先出FIFO方式）取出消息，从而实现进程间通信。
消息队列是一种[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]]模型，生产者生产消息放入队列，等待被消费者消费走。如果消息队列已满，生产者被阻塞，如果队列已空，消费者被阻塞。当然，按照不同设计方式，可能会以通知的方式替代阻塞行为。
在分布式系统中，也常使用消息队列模型（如RabbitMQ、Kafka）在多个服务程序之间异步地传递消息。</description></item><item><title>生产者消费者</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</guid><description>生产者消费者 与[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]]中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应。 消息队列是一种异步的模式，消息生产出来不一定被立刻消费。 消费队列可以用来平衡生产和消费的线程资源。 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据。 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据。 JDK 中各种[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/阻塞队列|阻塞队列]]，采用的就是这种模式。 ![[z-oblib/z2-attachments/Pasted image 20220529162239.png]]
实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 package test; import lombok.</description></item><item><title>竞态条件</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/</guid><description>竞态条件 race condition
多个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]]内执行，由于代码的执行序列不同，而导致的结果无法预测。</description></item><item><title>符号表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description>符号表 作用 一张“查询表。
符号表包含了一些通用的符号，这部分信息在进行了 strip 操作后就会消失。这些符号信息可能包括变量名、函数名。 符号表本质就是一个映射表，举个例子：某行二进制汇编代码映射到源码第几行。
符号表的作用：
调试：汇编&amp;ndash;查找&amp;ndash;&amp;gt;源码位置 重定位：函数名&amp;ndash;查找&amp;ndash;&amp;gt;汇编位置 调试 window工程有一个*.pdb文件,里面编包含调试符号.可参阅wiki window pdb格式。 在java工程会使用一个叫混淆的技术，混淆后会生成混淆前后的映射文件mapping.txt,这个也可以理解为符号表的一种。 在linux有一个dwarf的文件格式也是专门用于调试的文件。参阅wiki DWARF。 重定位 重定位可以大致分为两种类别动态重定位与静态重定位</description></item><item><title>符号解析</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</guid><description>符号解析 作用 确定符号引用关系，将每个模块中引用的符号与某个目标模块的定义符号建立关联。
在我们通常的观念里,之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件,所以要将它们链接起来。比如我们直接使用ld来链接“a.o”,而不将“b.o”作为输入。链接器就会发现 shared和swap两个符号没有被定义,没有办法完成链接工作： ![[z-oblib/z2-attachments/Pasted image 20220911163933.png]] 这也是我们平时在编写程序的时候最常碰到的问题之一,就是链接时符号未定义。导致这个问题的原因很多,最常见的一般都是链接时缺少了某个库,或者输入目标文件路径不正确或符号的声明与定义不一样。所以从普通程序员的角度看,符号的解析占据了链接过程的主要内容。 重定位过程也伴随着符号的解析过程,每个目标文件都可能定义一些符号也可能引用到定义在其他目标文件的符号。重定位的过程中,每个重定位的入口都是对一个符号的引用,那么当链接器须要对某个符号的引用进行重定位时,它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表,找到相应的符号后进行重定位。比如我们查看“a.o”的符号表： ![[z-oblib/z2-attachments/Pasted image 20220911164046.png]] GLOBAL”类型的符号,除了“main”函数是定义在代码段之外,其他两个“ shared和“swap”都是“UND”,即“undefined”未定义类型,这种未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后,所有这些未定义的符号都应该能够在全局符号表中找到,否则链接器就报符号未定义错误。
流程 《程序员的自我修养》番外笔记——符号解析与重定位 - SegmentFault 思否</description></item><item><title>管程总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</guid><description>管程总结 悲观锁
需要重点掌握的是
分析多[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]访问共享资源时，哪些代码片段属于[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]] 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 互斥解决临界区的线程安全问题 掌握 synchronized 锁对象语法 掌握 synchronzied 加载成员方法和静态方法语法 掌握 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|wait&amp;amp;notify]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]方法 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/ReentrantLock|lock]] 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]性、掌握常见[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程安全类|线程安全类]]的使用 了解线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活跃性|活跃性]]问题：[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]] 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait&amp;amp;notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]、synchronized 、wait&amp;amp;notify 原理 synchronized 进阶原理 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/park&amp;amp;unpark|park&amp;amp;unpark]] 原理 模式方面 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/异步|异步]]模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/顺序控制|顺序控制]]</description></item><item><title>管道</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E9%81%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E9%81%93/</guid><description>管道 管道是操作系统提供的一种最基本的进程间通信方式。每创建一个管道，就有两个文件描述符，一个是负责读管道的，一个是负责写管道的。所以，使用管道通信时，可以看作是两个文件描述符加一段内核空间中的内存，如图。
![[z-oblib/z2-attachments/Pasted image 20220803110054.png]]
管道只能协调有亲缘关系的进程间通信，所谓亲缘，比如父子进程、兄弟进程。当某进程创建一个管道后，它就拥有了这个管道的两个文件描述符，它的子进程会继承这两个文件描述符，所以子进程也能读写这个管道。如图。
![[z-oblib/z2-attachments/Pasted image 20220803110138.png]]
但为了让管道通信更安全、更方便，一般管道两端的每个进程都会各自关闭一个管道的文件描述符，例如父进程关闭读描述符，这样父进程只能向管道写数据，子进程关闭写描述符，这样子进程只能从管道读数据。或者相反。如图。
![[z-oblib/z2-attachments/Pasted image 20220803110147.png]]
Shell也提供了管道，只需使用一根竖线连接两个命令即可。例如：
1 2 3 ps -elf | grep &amp;#34;sshd&amp;#34; cat a.</description></item><item><title>类加载器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>类加载器 简介 一个可以将Java字节码加载为java.lang.Class实例的工具。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。
特点 动态加载，无需在程序一开始运行的时候加载，而是在程序运行的过程中，动态按需加载，字节码的来源也很多，压缩包jar、war中，网络中，本地文件等。类加载器动态加载的特点为热部署，热加载做了有力支持。 全盘负责，当一个类加载器加载一个类时，这个类所依赖的、引用的其他所有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。所以破坏双亲委派不能破坏扩展类加载器以上的顺序。 为何需要多个类加载器 思考以下情景：
首先，是为了区分同名的类：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 jvm 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？当然是不同的应用都拥有自己独立的类加载器了。 其次，是为了更方便的加强类的能力：类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？一个比较方便的模式就是每个类库都可以使用独立的类加载器 一个类的唯一性由加载它的类加载器和这个类的本身决定（类的全限定名+类加载器的实例ID作为唯一标识）。比较两个类是否相等（包括Class对象的equals()、isAssignableFrom()、isInstance()以及instanceof关键字等），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类就必定不相等。</description></item><item><title>索引</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95/</guid><description>索引</description></item><item><title>线程</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</guid><description>线程 线程是进程中的子任务，同一个进程的线程之间共享进程占有的内存空间和I/O。</description></item><item><title>线程安全类</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB/</guid><description>线程安全类 自己实现类的时候维护[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]比较繁琐，java就给我们提供了一些线程安全的类。
常见线程安全类 String Integer StringBuﬀer Random Vector Hashtable java.util.concurrent 包下的类 线程安全场景举例：
1 2 3 4 5 6 7 8 9 Hashtable table = new Hashtable(); new Thread(()-&amp;gt;{ table.</description></item><item><title>线程安全集合类概述</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</guid><description>线程安全集合类概述 ![[z-oblib/z2-attachments/Pasted image 20220612211057.png]]</description></item><item><title>线程池</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程池 使用线程池的原因 创建/销毁[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理 原理 Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。
ThreadPoolExecutor 构造方法 四个构造方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) // 六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory) // 六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) // 七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 5~7个参数，其中5个为必须： ^22da28</description></item><item><title>线程状态</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid><description>线程状态 操作系统层面有5种状态：
![[z-oblib/z2-attachments/Pasted image 20220526173846.png]]
【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联。 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行。 【运行状态】指获取了 CPU 时间片运行中的状态。 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】。 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】。 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们。 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</description></item><item><title>线程通讯</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/</guid><description>线程通讯 方法 使用消息队列</description></item><item><title>组合优于继承</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</guid><description>组合优于继承 Program to an interface, not an implementation. (面向接口编程，而不是具体的实现)
Favor object composition over class inheritance.（如果某个场景的代码复用既可以通过类继承实现， 也可以通过对象组合实现， 尽量选择对象组合的设计方式）</description></item><item><title>继承</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF/</guid><description>继承 B 继承自 A，则 B 能获得 A 的属性，并接管操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Java program to illustrate // Inheritance class RealPrinter { // base class implements method void print() { System.</description></item><item><title>继承和委派的选择</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</guid><description>继承和委派的选择 想要表达 is-a 关系，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]。 想要将类传递给已有的API，使用继承。 想要增强A，但A不能再被[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。 想要某方法并且不想覆盖该方法，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。</description></item><item><title>缓存更新策略</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</guid><description>缓存更新策略 先清缓存 清缓存&amp;ndash;更新数据库之间，其它线程读取了数据库中的旧数据，并写入缓存，导致5中缓存长时间被污染。
![[z-oblib/z2-attachments/Pasted image 20220610172505.png]]
先更新数据库 更新数据库&amp;ndash;清空缓存之间，其它线程可能读取到缓存中的旧数据，2中存在一定的窗口期。
![[z-oblib/z2-attachments/Pasted image 20220610172620.png]]
特殊情况 假设查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询，这种情况的出现几率非常小，见 facebook 论文：
![[z-oblib/z2-attachments/Pasted image 20220610173806.png]]</description></item><item><title>联合查询</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</guid><description>联合查询 联合索引就是复合索引、组合索引、多列索引。
联合查询是在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_2-数据库系统/索引|索引]]的基础上，一个节点压缩放入多个列。类似一个多条件联合的if语句
![[z-oblib/z2-attachments/3f7c0b118d08445d9a66131124ec2276.png]]
1 if (name==Bill &amp;amp;&amp;amp; age==30 &amp;amp;&amp;amp; role==dev) 重复值越少的越放前面，比如一个列 95%的值都不重复，那么一般可以将这个列放最前面。另外，复合索引的字段数尽量不要超过 3个，一旦超过，要慎重考虑必要性。</description></item><item><title>自定义线程池</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>自定义线程池 ![[z-oblib/z2-attachments/Pasted image 20220607213829.png]]
拒绝策略接口 策略模式： 具体操作抽象成接口，具体实现由调用者传递进来。
1 2 3 4 5 // 拒绝策略 @FunctionalInterface interface RejectPolicy&amp;lt;T&amp;gt; { void reject(BlockingQueue&amp;lt;T&amp;gt; queue, T task); } 参数要包含queue，来决定是否要在queue上等待，例如queue.</description></item><item><title>自旋</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B/</guid><description>自旋 不断尝试去获取锁，一般用循环来实现。
自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。 ^f17d9d</description></item><item><title>自旋优化</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/</guid><description>自旋优化 自旋优化会因为循环消耗CPU资源。 java6后自旋锁是自适应的，成功的多尝试次数就多。 java7后不能控制是否开启自旋。 自旋成功 ![[z-oblib/z2-attachments/Pasted image 20220527214938.png]]
自旋失败 ![[z-oblib/z2-attachments/Pasted image 20220527214953.png]]</description></item><item><title>装饰器模式</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>装饰器模式 对现有类不改动结构的情况下为类添加新职责和功能的模式。
使用场景 需要大量的子类为某一个对象进行职责增强的时候，可以使用装饰器模式 希望使用继承对于类进行动态扩展的时候，可以考虑使用装饰器模式 动机 一般有两种方式可以实现给一个类或对象增加行为：
继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator) 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。
角色 Component：抽象组件，装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为，可以给这些对象动态添加职责 ConcreteComponent：具体的组件对象，实现类 ，即被装饰者，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责 Decorator：所有装饰器的抽象父类，一般是抽象类，实现接口；它的属性必然有个指向 Conponent 抽象组件的对象 ，其实就是持有一个被装饰的对象 ConcreteDecorator：具体的装饰对象，实现具体要被装饰对象添加的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 !</description></item><item><title>设计模式总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</guid><description>设计模式总结 模式 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/装饰器模式|装饰器模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/模板模式|模板模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/单例模式|单例模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工厂模式|工厂模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 工具 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|Balking]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工作线程|工作线程]]</description></item><item><title>访问控制符</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6/</guid><description>访问控制符 ![[z-oblib/z2-attachments/v2-315cda6274202d57b75be7641eba442f_1440w.png]]
public 可以被所有其它类访问。 private 只能被自己访问。 protected 只能被自身、子类、同属一个包的其他类访问。 在同一个包相当于public。 default 默认修饰符（friendly）。 只能被自身、同属一个包的其他类访问。</description></item><item><title>路径配置</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/%E6%AF%9B%E7%BA%BF%E5%89%AA%E8%97%8F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/%E6%AF%9B%E7%BA%BF%E5%89%AA%E8%97%8F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</guid><description>路径配置 1 0_0-收集/0_0_0-mxwc/0_0_0_0-默认分类</description></item><item><title>跳表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</guid><description>跳表 https://www.jianshu.com/p/9d8296562806
针对顺序表，以某一概率在当前最上层选点构建新的一层，以此构建多层索引，由上往下逐层增加稠密度。
![[z-oblib/z2-attachments/19063731-70b00aafa9f5b793.webp]] ![[z-oblib/z2-attachments/19063731-4f4535e6d0959c32.webp]] ![[z-oblib/z2-attachments/19063731-3852cc36af701f46.webp]]
索引高度 假设原始链表有n个元素，以每两个节点抽出一个节点为例，即某个点有1/2的概率被选中：
1级索引节点数：n/2 2级索引节点数：n/4 k级索引节点数：$n/2^k$ 此例中跳表索引高度为：$h = log_2{n} - 1$，-1是因为最上层不会有节点个数为1的层，所以减掉1。 因此原始链表有n个元素，各级跳表的选取概率为p，则第k层的节点数 $m_k = m_{k-1} \times 1/p$，索引的高度为$h = log_{1/p}{n} - 1$。</description></item><item><title>轻量级锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</guid><description>轻量级锁 使用方式 轻量级锁任然使用[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]语法，实现对使用者透明。
使用场景 如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。
流程 示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 static final Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } } 获取锁 每个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]都的栈帧都会包含一个锁记录（Lock Record）的结构，内部可以存储锁定对象的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]，用于存储锁对象目前的Mark Word的拷贝。</description></item><item><title>运行时动态链接</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</guid><description>运行时动态链接 PLT与GOT关系 PLTPLT表中的数据就是GOTGOT表中的一个地址，可以理解为一定是一一对应的： PLTPLT表中的每一项的数据内容都是对应的GOTGOT表中一项的地址这个是固定不变的。
![[z-oblib/z2-attachments/Pasted image 20220908214812.png]]
流程 (35条消息) PWN基础15：GOT表 和 PLT表_prettyX的博客-CSDN博客_查看got表
程序加载 触发重定向 修改GOT表[0]，向其填充PLT表首地址，用于触发查找 修改GOT表[2]，向其填充连接器查找函数地址，用于查找目标函数真实地址 首次调用目标动态连接函数，假设目标函数标号为n： PLT跳转到GOT[n] GOT[n]初始填充的是PLT[n]后一条地址，接着两条指令： push 编号n 跳转到PLT[0] PLT[0] 包含两条指令： push GOT[1] &amp;ndash; 填充的是[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/运行时动态链接#link_map|link_map]]的地址 跳转到GOT[2]内填充的地址空间 &amp;ndash; 链接器 此时一共push了2个参数，一个目标函数ID，一个link_map地址，正好是_dl_runtime_resolve的两个参数。 _dl_runtime_resolve 找到动态链接函数真实地址，回填到GOT[n]。 _dl_runtime_resolve - 简书 (jianshu.</description></item><item><title>进程</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</guid><description>进程 进程相当于一个工厂，代表一个程序。</description></item><item><title>进程与线程的区别</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>进程与线程的区别 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]基本上相互独立的，相互之间独占内存地址空间和系统资源（I/O等）；而[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]存在于进程内，是进程的一个子集。 进程拥有共享的资源，如内存空间等，供其内部的线程共享。 进程间通信较为复杂。 同一台计算机的进程通信称为 IPC（Inter-process communication）。 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP。 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量。 进程管理开销更大，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度。 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低，线程只需要保存寄存器和栈信息。 不同平台和语言下的区别 Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</description></item><item><title>进程间通讯</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</guid><description>进程间通讯 单机操作系统上的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]可以分为两类：
独立进程：这类进程不会和其它进程有任何交[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/流|流]]。 协作进程：两个或多个进程之间需要交流。 例如，ls /tmp命令是独立运行的，不依赖于其它进程，而cat a.log | grep 'abc'命令中的两个进程是协作进程，grep进程依赖于cat进程，grep只有等待到了cat进程产生的数据才能继续执行下去。
对于单机上不同进程之间的协作，各进程之间需要进行数据的交流，这种行为称为进程间通信（Inter-process communication，IPC），即进程与进程的通信。
除了单机上的多个进程可能需要进程间通信，多计算机之间的进程有时候也需要进行进程间的通信，这很常见，例如本机上的QQ客户端进程需要和腾讯的QQ服务器上的进程进行数据传输，浏览器浏览网页时，浏览器进程需要和网页所在的服务端进程进行数据传输，等等。
进程间通信的方式有很多种。从广义上讲，只要进程间能共享数据或传递数据就算是进程间通信。下面列出常见的进程间通信方式：
进程间通信方式 描述 文件（File） 多个进程可以获取到同一个文件的数据 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/管道 | 管道]]（pipe） 单方向传输数据的管道，只能一方写，另一方读 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/套接字|套接字]]（Socket） 多机进程间通信，当然也可以在本机让两个进程使用socket通信 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/Unix域套接字|Unix域套接字]]（Unix Domain Socket） 单机进程间通过域套接字模式通信，可看作是双向管道 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/共享内存|共享内存]]（Shared Memory，shm） 在物理内存上划分一片内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件映射|文件映射]]（Memory-maped file） 将文件中的一段数据映射到物理内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/消息队列|消息队列]]（Message Queue） 某进程将消息放入消息队列，其它进程从队列中接收消息 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号|信号]]（Signal） 通过发送某些信号通知其它进程，进程收到信号做出不同的处理 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号量|信号量]]（Semaphore） 就是信号灯。应用方式有多种，其作用概括起来就是，根据是否有信号灯或信号灯的数量多少来决定是否阻塞进程 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/锁|锁]]（Lock） 对资源上锁，如果资源已被某进程锁住，则其它进程想要修改甚至读取这些资源，都将被阻塞，直到锁被打开。</description></item><item><title>迭代器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>迭代器 迭代器是一个用于保存状态的类，状态是指一个可迭代对象当前的遍历情况，例如可迭代对象元素量，当前迭代指针等。 迭代器主要是通过内部类实现，比如ArrayList内部有个Iterator类，这样iterator可以通过ArrayList.this访问到外部类的内容，最重要的是访问到外部类中存储的具体数据。 迭代器设计上降低了空间开销（维护指针信息而不用复制原数据），保证了与原数据的一致性（如果是复制则可能造成与原数据不一致）。 iterator()方法会返回一个可迭代对象内部的迭代器实例。</description></item><item><title>逆向wp-Easy-CrackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</guid><description>逆向wp-Easy-CrackMe 题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 windows 窗体程序 没什么输入限制 错误返回字符串 Incorrect Password ![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214007.png]]
反编译 程序是 32 位的.
定位关键函数 通过字符串 Incorrect Password 定位关键函数, F5 分析 C 代码.</description></item><item><title>逆向wp-Easy-Keygen</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</guid><description>逆向wp-Easy-Keygen 基础的异或加密题.
http://gokoucat.ys168.com/
题目要求 Find the Name when the Serial is 5B134977135E7D13
黑盒测试 简单运行一下程序, 发现是 Windows 下的命令行程序, 要求输入 name 和 serial, 程序判断是否正确, 错误直接跳出.</description></item><item><title>逆向wp-Easy-Re</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</guid><description>逆向wp-Easy-Re bugku 逆向第二题.
定位关键函数 通过 ida 反编译, 很容易定位关键函数, 本题结构十分简单:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;amp;v5, _mm_loadu_si128((const __m128i *)&amp;amp;xmmword_413E34)); // &amp;amp;xmmword_413E34 即被比较数据 flag v7 = 0; v6 = qword_413E44; v8 = 0; printf(&amp;#34;欢迎来到DUTCTF呦\n&amp;#34;); printf(&amp;#34;这是一道很可爱很简单的逆向题呦\n&amp;#34;); printf(&amp;#34;输入flag吧:&amp;#34;); scanf(&amp;#34;%s&amp;#34;, &amp;amp;v9); v3 = strcmp((const char *)&amp;amp;v5, &amp;amp;v9); // 将输入与已有数据进行比较, if ( v3 ) v3 = -(v3 &amp;lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;amp;unk_413E90); system(&amp;#34;pause&amp;#34;); return 0; } 解析字符串 对 &amp;amp;xmmword_413E34 位置的数据进行分析, 发现此处就是 flag 的逆序存储, 直接右键显示为 字符, 然后手工反向输入即可.</description></item><item><title>逆向wp-Easy-UnpackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</guid><description>逆向wp-Easy-UnpackMe 脱壳入门题, 找程序 EOP (入口点).
题目在网络对应目录中: http://gokoucat.ys168.com/
题目要求 Find the OEP, ex) 00401000
黑盒测试 双击打开, 是一个空白的 Windows 窗体程序, 没什么特别的.
OD 调试 通过使用 OD 动态调试, 寻找程序的 EOP, 使用的方法是单步跟踪.</description></item><item><title>逆向wp-ebCTF-Teaser-BIN100-Dice</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</guid><description>逆向wp-ebCTF-Teaser-BIN100-Dice 杭电 CTF 平台逆向第一题.
http://gokoucat.ys168.com/
定位关键函数 使用 IDA 字符串搜索 定位回显字符串被交叉引用的位置 得到关键函数中的重要片段如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { .</description></item><item><title>逆向wp-keylead</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</guid><description>逆向wp-keylead 杭电 CTF 平台逆向第二题.
题目在网络对应目录中: http://gokoucat.ys168.com/
文件分析 通过在 lunux 环境下, 使用 file keylead 发现是一个压缩文件, 解压后得到可执行文件.
1 2 3 file keylead keylead: XZ compressed data 函数分析 通过字符串定位的方法, 找到主函数.</description></item><item><title>逆向wp-Reverse-100</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</guid><description>逆向wp-Reverse-100 杭电 CTF 平台逆向第四题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位关键函数 老套路, string 查找, 不多 BB.
解析函数 这个函数比较简单, key 和 判断流程在一个简单的函数中直接展示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __cdecl main(int argc, const char **argv, const char **envp) { signed int i; // edi char s_input; // [esp+10h] [ebp-104h] char Dst; // [esp+11h] [ebp-103h] s_input = 0; memset(&amp;amp;Dst, 0, 0xFFu); printf(&amp;#34;please input ns-ctf password: &amp;#34;); scanf_s(&amp;#34;%s&amp;#34;, &amp;amp;s_input); for ( i = 1; strncmp(&amp;#34;nsF0cuS!</description></item><item><title>逆向wp-reverse02</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</guid><description>逆向wp-reverse02 杭电 CTF 平台逆向第三题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位函数 程序时一个 win32 的窗口程序, 按钮是灰色的.
老套路, 根据字符串来定位函数.
这题可以找到一个内容是 flag:{NSCTF_md57e0cad17016b0&amp;gt;?45?f7c&amp;gt;0&amp;gt;4a&amp;gt;1c3a0} 的字符串, 直接提交错误, 看来没这么简单.
交叉引用 对该字符串的交叉引用有两处, 分别分析发现其中一个应该为主要的函数:</description></item><item><title>逆向wp-WannaLOL2</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</guid><description>逆向wp-WannaLOL2 逆向入门题.
题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 拿到题目第一步, 就是运行软件进行测试
判断软件平台 观察输入限制 观察输出信息 本题是一道 Windows 平台下的窗体程序, 任意输入内容进行测试:
![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215724.png]]
随意输入后, 发现程序对输入的内容和长度没有做限制, 输入不通过时返回字符串 error !</description></item><item><title>逆向wp-游戏过关</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</guid><description>逆向wp-游戏过关 bugku 逆向第三题.
http://gokoucat.ys168.com/
定位关键函数 通过对字符串 done!!! the flag is 进行交叉引用的定位, 找到关键函数的位置.
1 2 3 4 5 6 7 8 9 10 11 12 .</description></item><item><title>逆向中的双字节</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%AD%97%E8%8A%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%AD%97%E8%8A%82/</guid><description>逆向中的双字节 数据储存类型分为 byte, word, dword 区别在于占用几个字节(byte) byte 不受大小端的影响, 因为其只有一位 word, 和 dword 受大小端的影响 一般的计算机使用的是小端序 一个2位16进制是1字节 技巧 IDA 中看到 word 16 进制显示时, 两两一组(4位16进制数)从右向左 IDA 中看到 dword 16 进制显示时, 四个一组(8位16进制数)从右向左</description></item><item><title>重定位表</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/</guid><description>重定位表 一张“需求表”：告诉链接器哪些指令即该指令的哪些部分要调整。
重定位表（Relocation Table）用于在程序加载到内存中时，进行内存地址的修正。
对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。
对于每个要重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF文件中的一个段，所以其实重定位表也可以叫重定位段。
结构 比如代码段“text”如有要被重定位的地方,那么会有一个相对应叫“, rel.text”的段保存了代码段的重定位表;如果代码段“data”有要被重定位的地方,就会有一个相对应叫“ rel.data&amp;quot;”的段保存了数据段的重定位表。我们可以使用 objdump来查看目标文件的重定位表。 ![[z-oblib/z2-attachments/Pasted image 20220911164434.png]]
每个要被重定位的地方叫一个重定入口( Relocation Entry,我们可以看到“a.o&amp;quot;里面有两个重定位入口。
重定位入口的偏移(Oset)表示该入口在要被重定位的段中的位置, RELOCATION RECORDS FOR .</description></item><item><title>重量级锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</guid><description>重量级锁 介绍 重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。
前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：
1 2 3 4 5 6 Contention List：所有请求锁的线程将被首先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !</description></item><item><title>针对延迟绑定的攻击</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>针对延迟绑定的攻击  2015 年的论文 “How the [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|ELF]] Ruined Christmas” 中提出的。
强迫动态装载器解析请求的函数。
![[z-oblib/z2-attachments/Pasted image 20220911020331.png]] ![[z-oblib/z2-attachments/Pasted image 20220911020936.png]]
图a中，因为动态转载器是从 .</description></item><item><title>锁</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/</guid><description>锁 计算机领域中，锁机制使用的非常多。它主要是为了避免多个进程访问同一资源时，可能出现的数据不一致问题。
例如，cat命令输出一个比较大的文件内容，cat命令的特性是需要先将所有磁盘文件数据读取到内存后再输出，所以cat输出一个大文件可能需要花费一些时间。如果在cat在加载文件时，在另一个终端上向这个文件追加了一行数据，那么cat最终加载的数据会包含这行新追加的数据吗？
再更简单的一个示例是，两个用户同时用vim打开一个文件去修改数据，那么以谁修改的数据为准呢？所以，vim为了避免这种问题，每次打开一个文件的时候，都会在文件的同一个目录下创建一个隐藏的.swp临时文件（例如vim a.log时会生成一个.a.log.swp的文件），如果有其它用户用vim去打开同一个文件，会检查这个隐藏文件是否存在，如果存在说明有人正在编辑这个文件。
锁的内容非常多，这里简单介绍下它最基本也最实用的基础知识。
如果不使用锁，也就是允许多个进程同时更新、读取同一份数据，将可能出现以下问题：
脏读：读取到脏数据。例如用户A用vim将文件中的字母x修改为了y，用户B在vim保存之前通过cat读取，得到的这个字母将是x，这种现象称为脏读。但其实A已经将它修改为了y，只不过该修改只存在于A的vim缓存中，还没有保存到磁盘文件中。通常，将缓存中修改后但没有保存的数据称为脏数据。 更新丢失：某用户的数据更新操作被其它用户覆盖。例如，用户A和用户B同时修改同一文件中的最后一个字符a，A将a修改为x，B将a修改为y，那么A先保存的话，B的修改将覆盖A的修改，最终保存的结果是y，如果B先保存的话，A的修改将覆盖B的修改，最终结果得到字符x。所以，同时修改数据时，有一个进程的更新被覆盖了，也就是丢失了。 除这两个问题之外，在多进程同时更新、读取同一份数据时，还可能会出现其它现象，这里不再多做描述。下面介绍一下锁的机制。
![[z-oblib/z2-attachments/Pasted image 20220803161908.png]]
当需要读数据时，将申请读锁，当需要修改数据时，将申请写锁。
申请锁的时候，需要先检查该资源上是否已经有锁，如果有锁，检查已存在的锁与待申请的锁是否可以兼容共存。
当多个进程都只是读取同一份资源（即都申请S锁），因为没有修改数据，所以可以允许它们同时读取，所以S锁与S锁是可以共存的。 如果有一个进程修改数据，它将申请X锁，这时显然不能让其它进程读取或写入数据，所以X锁与S锁、X锁和X锁都是互斥的。 如果一个进程正在读取数据（即已申请S锁），其它进程想修改数据，也是不允许的，所以S锁和X锁是互斥的。 此外，使用锁需要考虑锁的粒度，即对多少资源量上锁。例如，对于一个文件来说，可以直接对整个文件上锁，也可以只对文件中想要访问的那部分数据上锁。如果直接对整个文件上锁，其它进程申请该文件的互斥锁将总是被阻塞，而如果只是锁定该文件中的前10K数据，那么其它进程如果申请的互斥锁从第20K开始的数据，就不会收到影响。</description></item><item><title>锁存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>锁存器 我们将能够存储一个状态的电路叫做锁存器。设想一个电路，初始输入为0，输出为0；然后输入为1，输出变为1（状态发生了变化）。对于迄今为止所有的电路，我们都能保证当输入回到0时，输出也会同时归0；但这个电路不同，它保持在了1，也就是状态没有发生变化，而是被存储了下来。此时，这种电路便可以被叫做锁存器。
为了让电路拥有自己的”状态“，必须要有某种”反馈“机制，将输出输入形成一个闭环。
分类 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/RS锁存器|RS锁存器]]</description></item><item><title>锁接口和类</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</guid><description>锁接口和类 分类 可重入锁和非可重入锁 可重入：[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]能对资源重复加锁。
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]关键字就是使用的重入锁。 在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。 如果我们自己在继承[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/AQS|AQS]]实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。 ReentrantLock就是可重入锁。 公平锁和非公平锁 公平：现来后到，FIFO，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足。
非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。 ReentrantLock支持非公平锁和公平锁两种。 读写锁和排它锁 排它：同一时刻只允许一个线程访问。 读写：同一时刻允许多个读线程访问。
Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。 即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。 JDK中有关锁的一些接口和类 抽象类AQS/AQLS/AOS AQS（AbstractQueuedSynchronizer）资源上限是Integer.</description></item><item><title>锁消除</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%B6%88%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%B6%88%E9%99%A4/</guid><description>锁消除 JIT会对java字节码进行优化，逃逸分析时发现对象不可能被共享，就会取消无意义的加锁操作。</description></item><item><title>锁的优缺点对比</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</guid><description>锁的优缺点对比 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/偏向锁|偏向锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]
锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。同步块执行时间较长。</description></item><item><title>锁的其他优化</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/</guid><description>锁的其他优化 适应性自旋（Adaptive Spinning）：从[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]获取的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#^8418aa|过程]]中我们知道，当[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]在获取轻量级锁的过程中执行[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作失败时，是要通过自旋来获取[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。 锁粗化（Lock Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子： 1 2 3 4 5 6 7 8 9 public void lockCoarsening() { int i=0; synchronized (this){ i=i+1; } synchronized (this){ i=i+2; } } 上面的两个同步代码块可以变成一个</description></item><item><title>锁膨胀</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E8%86%A8%E8%83%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E8%86%A8%E8%83%80/</guid><description>锁膨胀 锁由[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]向[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]升级的过程。
竞争者升级锁 接着[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#获取锁|轻量级锁中升级的5.1分支]]继续说：
如果在尝试加轻量级锁的过程中，[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]] 操作无法成功，这时一种情况就是有其它[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。
当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁。 ![[z-oblib/z2-attachments/Pasted image 20220527214017.png]] Thread-1 加轻量级锁失败，进入锁膨胀流程： 为 Object 对象申请 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|Monitor]] 锁，让 Object 指向重量级锁地址。 自己进入 Monitor 的 EntryList BLOCKED。 !</description></item><item><title>阻塞队列</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</guid><description>阻塞队列 简介 jdk中阻塞队列BlockingQueue解决的问题和实现的功能：
多线程场景下的生产者-消费者模式中，多个线程操作共享变量（资源）容易产生线程安全问题：重复消费、死锁。 资源池空了，需要阻塞消费者，唤醒生产者。 资源池满了，需要阻塞生产者，唤醒消费者。 BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了线程安全的队列访问方式，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。开发者只管往里面存取即可，不用担心线程安全问题。 BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。
操作方法 阻塞队列提供了四组不同的方法用于插入、移除、检查元素：
方法\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() - - 抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。 一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。 超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。 注意：</description></item><item><title>静态代理</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>静态代理 概述 代理类实现目标接口 代理类在内部实例化一个被代理类的对象 代理类重写目标方法，加入修改的逻辑，并可以调用被代理类的对象的方法 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StaticProxySample { interface Greet { void sayHello(String name); } static class GreetImpl implements Greet { @Override public void sayHello(String name) { System.</description></item><item><title>静态重定位</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</guid><description>静态重定位 1 2 3 4 5 6 7 8 9 10 11 12 13 //mainA.c int globalvar=0x123; fun test(){ } //mainB.</description></item><item><title>顺序一致性模型</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid><description>顺序一致性模型 顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。
顺序一致性模型有两大特性：
一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。
不管程序是否[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是原子性的，且立刻对所有线程可见。
为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-&amp;gt;A2-&amp;gt;A3，线程B也有3个操作，B1-&amp;gt;B2-&amp;gt;B3。
假设正确使用了同步，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示：
![[z-oblib/z2-attachments/正确同步.png]]
操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。
假设没有使用同步，那么在顺序一致性模型中的执行效果如下所示：
![[z-oblib/z2-attachments/没有正确同步.png]]
操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的每个操作必须立即对任意线程可见。
但是[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]没有这样的保证： 比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</description></item><item><title>顺序控制</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6/</guid><description>顺序控制 线程之间按规定的先后顺序执行。
交替输出 线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现：</description></item><item><title>饥饿</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A5%A5%E9%A5%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A5%A5%E9%A5%BF/</guid><description>饥饿 一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束。</description></item></channel></rss>