<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>atom on</title><link>http://localhost:1313/tags/atom/</link><description>Recent content in atom on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="http://localhost:1313/tags/atom/index.xml" rel="self" type="application/rss+xml"/><item><title>_dl_runtime_resolve</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/_dl_runtime_resolve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/_dl_runtime_resolve/</guid><description>_dl_runtime_resolve 首先用link_map访问.dynamic，分别取出.dynstr、.dynsym、.rel.plt的地址 .rel.plt+参数relic_index，求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&amp;gt;r_info &amp;raquo; 8 作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&amp;gt;st_name得出符号名 字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&amp;gt;r_offset，即GOT表 最后调用这个函数 ![[z-oblib/z2-attachments/Pasted image 20220911014856.png]]
方法过程 6.</description></item><item><title>AQS</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS/</guid><description>AQS 全称是 AbstractQueuedSynchronizer，是阻塞式锁（类似[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]）和相关的同步器工具的框架。
特点 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁 getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - cas 机制设置 state 状态 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet 子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</description></item><item><title>call</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/call/</guid><description>call push eip+4 mov eip, func</description></item><item><title>Callable</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Callable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Callable/</guid><description>Callable 带返回值的call，并且可以抛出异常。
1 2 public interface Callable&amp;lt;V&amp;gt; { V call() throws Exception;</description></item><item><title>CAS</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS/</guid><description>CAS 原理 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。
在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。
CAS应用 java中：与volatile配合实现乐观锁。
CAS为什么能保证原子操作呐？ 这个就关系到了CAS底层所用到的Unsafe类，Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</description></item><item><title>CAS与volatile</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E4%B8%8Evolatile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E4%B8%8Evolatile/</guid><description>CAS与volatile 用例 AtomicInteger 的解决方法，内部并没有用锁来保护共享[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]。那么它是如何实现的呢？
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void withdraw(Integer amount) { while(true) { // 需要不断尝试，直到成功为止 while (true) { // 比如拿到了旧值 1000 int prev = balance.</description></item><item><title>CAS实现原子操作的三大问题</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</guid><description>CAS实现原子操作的三大问题 ABA问题 所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。
ABA问题的解决思路是在变量前面追加上版本号或者时间戳。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。
这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。
1 2 3 4 5 6 7 8 9 10 11 12 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.</description></item><item><title>CAS锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E9%94%81/</guid><description>CAS锁 利用原子类配合cas操作组成标志位，来模拟锁：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 不要用于实践！！！ public class LockCas { private AtomicInteger state = new AtomicInteger(0); public void lock() { while (true) { if (state.</description></item><item><title>CMOS</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/CMOS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/CMOS/</guid><description>CMOS CMOS是Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）的缩写。</description></item><item><title>cmpxchg</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cmpxchg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cmpxchg/</guid><description>cmpxchg https://zhuanlan.zhihu.com/p/34556594
底层实现 linux_x86的实现：
![[z-oblib/z2-attachments/v2-918101df747ba9d03815cefff3955d74_1440w.jpg]]
windows_x86的实现：
![[z-oblib/z2-attachments/v2-cd24129a2b8f106ec3179083d3e8cfd1_1440w.jpg]]
mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。
如果当前系统是多处理器，该函数返回1。 否则，返回0。 LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。
如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。 否则，不加lock前缀。 这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。</description></item><item><title>ConcurrentHashMap</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentHashMap/</guid><description>ConcurrentHashMap 用例 分布式计算字符串数量：
生成测试数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static final String ALPHA = &amp;#34;abcedfghijklmnopqrstuvwxyz&amp;#34;; public static void main(String[] args) { int length = ALPHA.</description></item><item><title>ConcurrentLinkedQueue</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentLinkedQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ConcurrentLinkedQueue/</guid><description>ConcurrentLinkedQueue</description></item><item><title>CyclicBarrier</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CyclicBarrier/</guid><description>CyclicBarrier [ˈsaɪklɪk ˈbæriɚ] 循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。
与CountdownLatch不同，CyclicBarrier可以重复使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CyclicBarrier cb = new CyclicBarrier(2); // 个数为2时才会继续执行 new Thread(()-&amp;gt;{ System.</description></item><item><title>dao</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/dao/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/dao/</guid><description>dao DAO（Data Access Object）是用于访问数据的对象，实际上是一个映射关系，将java中访问对象的操作映射的具体数据库的操作，例如Mybatis的设计中，MapperScannerConfigurer会扫描所有dao，得到domain数据对象操作和数据库语句的映射关系，通过[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/动态代理|动态代理]]的方式拦截所有对domain的操作，转到对数据库的操作。</description></item><item><title>DES</title><link>http://localhost:1313/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/DES/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/DES/</guid><description>DES</description></item><item><title>ELF</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ELF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ELF/</guid><description>ELF 文件格式 目标文件既会参与程序链接又会参与程序执行。出于方便性和效率考虑，根据过程的不同，目标文件格式提供了其内容的两种并行视图，如下： ![[z-oblib/z2-attachments/Pasted image 20220912001910.png]]</description></item><item><title>fork&amp;join</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/forkjoin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/forkjoin/</guid><description>fork&amp;amp;join 概念 Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解 Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 Fork/Join 默认会创建与 cpu 核心数大小相同的线程池 使用 提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务：</description></item><item><title>FutureTask</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/FutureTask/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/FutureTask/</guid><description>FutureTask FutureTask 能够接收 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Callable|Callable]] 类型的参数，用来处理有返回结果的情况。
1 2 FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; // Future.get()用来返回任务的返回值</description></item><item><title>GOT表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/GOT%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/GOT%E8%A1%A8/</guid><description>GOT表 深入理解GOT表和PLT表 - 知乎 (zhihu.com)
GOT(Global Offset Table)全局偏移表，链接器为外部符号填充的实际偏移地址表。
位于数据段，内容可修改。
结构 GOT[1]：一个指向内部数据结构的指针，类型是 link_map，在动态装载器内部使用，包含了进行[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/符号解析|符号解析]]需要的当前 ELF 对象的信息。在它的 l_info 域中保存了 .</description></item><item><title>happens-before</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/happens-before/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/happens-before/</guid><description>happens-before 什么是happens-before 如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。
一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。
JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。
而对于程序员，JMM提供了happens-before规则（JSR-133规范），满足了程序员的需求——简单易懂，并且提供了足够强的内存可见性保证。换言之，程序员只要遵循happens-before规则，那他写的程序就能保证在JMM中具有强的内存可见性。
JMM使用happens-before的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。
happens-before关系的定义如下：
概念：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 实际是结果为导向：两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。 happens-before关系本质上和as-if-serial语义是一回事。 as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。
满足的几种情况 synchronized 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见：</description></item><item><title>HashMap</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/HashMap/</guid><description>HashMap 并发问题 JDK7并发死链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public static void main(String[] args) { // 测试 java 7 中哪些数字的 hash 结果相等 System.</description></item><item><title>interrupt</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/interrupt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/interrupt/</guid><description>interrupt 打断 sleep, wait, join 的线程 interrupt强行打断线程：
线程会记录本身是否被打断过，但是sleep, wait, join 以异常的方式响应interrupt后会清除异常标记，isInterrupted() == false。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-&amp;gt;{ log.</description></item><item><title>Java内存模型</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>Java内存模型 运行时内存的划分 ![[z-oblib/z2-attachments/Java运行时数据区.png]] 对于每一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]来说，栈都是私有的，而堆是公有的。
也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量，内存的可见性针对的是共享变量。
既然堆是共享的，为什么在堆中会有内存不可见? 这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为cpu访问缓存区比访问内存要快得多。
线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。
Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM#JMM的抽象示意图|JMM的抽象示意图]]。
一个例子 https://www.bilibili.com/video/BV16J411h7Rd?p=21&amp;t=575.8
![[z-oblib/z2-attachments/Pasted image 20220526104910.png]]
初始化时会将类加载到方法区。 jvm启动main方法作为主线程。 main线程栈中包含： 程序计数器：指向下一句要执行的代码地址。 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/栈帧|栈帧]]：每次调用其它函数都会生成一个运行时栈帧。 每次调用一个方法，就会在main线程栈中创建一个目标方法的栈帧。 局部变量可以指向堆空间的数组或者是对象。</description></item><item><title>java守护线程</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</guid><description>java守护线程 主线程结束时不管守护线程还有没有其它任务，都会强制结束守护线程。
主要用在：
垃圾回收器线程。 Tomcat中的Accetor和Poller线程。（结束tomcat后不会等待当前请求处理完成而是会直接结束运行）。</description></item><item><title>Java实现的CAS</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%AE%9E%E7%8E%B0%E7%9A%84CAS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%AE%9E%E7%8E%B0%E7%9A%84CAS/</guid><description>Java实现的CAS 前面提到，CAS是一种原子操作。那么Java是怎样来使用CAS的呢？我们知道，在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。
在Java中，有一个Unsafe类，它在sun.misc包中。它里面是一些native方法，其中就有几个关于CAS的：
1 2 3 boolean compareAndSwapObject(Object o, long offset,Object expected, Object x); boolean compareAndSwapInt(Object o, long offset,int expected,int x); boolean compareAndSwapLong(Object o, long offset,long expected,long x); 当然，他们都是public native的。</description></item><item><title>java线程上下文切换（Thread Context Switch）</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</guid><description>java线程上下文切换（Thread Context Switch） 因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：
线程的 cpu 时间片用完
垃圾回收
有更高优先级的线程需要运行
线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</description></item><item><title>java线程状态</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid><description>java线程状态 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程状态|线程状态]]
根据Java API Thread.State枚举，有6种状态：
![[z-oblib/z2-attachments/Pasted image 20220526174139.png]]
BLOCKED是指线程正在等待获取锁；WAITING是指线程正在等待其他线程发来的通知（notify），收到通知后，可能会顺序向后执行（RUNNABLE），也可能会再次获取锁，进而被阻塞住（BLOCKED）。
状态转换 1. NEW &amp;ndash;&amp;gt; RUNNABLE NEW [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]刚被创建，但是还没有调用 start() 方法，还未与操作系统线程相关联。 当调用 t.</description></item><item><title>JMM</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JMM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/JMM/</guid><description>JMM 简介 JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。 JMM 体现在以下几个方面：
原子性 - 保证指令不会受到线程上下文切换的影响 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 JMM的抽象示意图 !</description></item><item><title>join</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/join/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/join/</guid><description>join join()方法是Thread类的一个实例方法。让当前线程陷入等待，等待某个其它[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]运行结束，谁调用就等待谁，join起到了[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]的作用。
join()底层就是wait()。
有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。
如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。
示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Join { static class ThreadA implements Runnable { @Override public void run() { try { System.</description></item><item><title>kmp</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/kmp/</guid><description>kmp</description></item><item><title>lambda</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/lambda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/lambda/</guid><description>lambda</description></item><item><title>leave</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/leave/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/leave/</guid><description>leave mov esp, ebp 清空当前函数栈以还原栈空间（直接移动栈顶指针 esp 到当前函数的栈底 ebp ）； pop ebp 还原栈底（将此时 esp 所指的上层函数栈底 old ebp 弹入 ebp 寄存器内）；</description></item><item><title>LinkedBlockingQueue</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LinkedBlockingQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LinkedBlockingQueue/</guid><description>LinkedBlockingQueue 入队出队 类似[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/AQS|AQS]]中的等待队列:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LinkedBlockingQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt; implements BlockingQueue&amp;lt;E&amp;gt;, java.</description></item><item><title>LongAdder</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LongAdder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/LongAdder/</guid><description>LongAdder 原理 LongAdder 类有几个关键域：
1 2 3 4 5 6 7 8 // 累加单元数组, 懒惰初始化 transient volatile Cell[] cells; // 基础值, 如果没有竞争, 则用 cas 累加这个域 transient volatile long base; // 在 cells 创建或扩容时, 置为 1, 表示加锁 transient volatile int cellsBusy; cellsBusy用到了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS锁|CAS锁]]的方法。</description></item><item><title>Mark Word</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Mark-Word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/Mark-Word/</guid><description>Mark Word 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]持有的锁、偏向线程ID、偏向时间戳等等。
Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。我们打开 openjdk的源码包，对应路径/openjdk/hotspot/src/share/vm/oops，Mark Word对应到C++的代码markOop.hpp，可以从注释中看到它们的组成，本文所有代码是基于Jdk1.8。
Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：
![[z-oblib/z2-attachments/1162587-20200918154115022-312986152.png]]
在64位JVM中是这么存的：
![[z-oblib/z2-attachments/1162587-20200918154125385-1537793659.png]]
虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。
注意上述结构不是每一行都同时存在，而是根据锁标志位来决定当前行的状态。 例如在重量级锁状态下，当对象获取到Mointer的时，会先复制并暂存无锁态对应的信息，将信息覆写为Mointer地址。当释放锁后，会恢复无锁态对应数据。
锁标志位（lock）：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。 biased_lock：是否[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/偏向锁|偏向锁]]，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。 分代年龄（age）：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。 对象的hashcode（hash）：运行期间调用System.</description></item><item><title>monitor</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/monitor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/monitor/</guid><description>monitor 监视器/管程。
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 给对象上锁（重量级）之后，该[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/对象头|对象头]]的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]] 中就被设置指向 Monitor 对象的指针。
Monitor 结构： ![[z-oblib/z2-attachments/Pasted image 20220527172014.png]]
Monitor 中 Owner 初始为 null。 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner。 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行synchronized(obj)，就会进入 EntryList BLOCKED。 Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的。 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。 注意： synchronized 必须是进入同一个对象的 monitor 才有上述的效果， 不加 synchronized 的对象不会关联监视器，不遵从以上规则。</description></item><item><title>park&amp;unpark</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/parkunpark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/parkunpark/</guid><description>park&amp;amp;unpark 特点 与 wait&amp;amp;notify相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp;amp; unpark 是以线程为单位来阻塞/唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精准。 park &amp;amp; unpark 可以先 unpark，而 wait &amp;amp; notify 不能先 notify。 原理 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻：</description></item><item><title>PLT表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/PLT%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/PLT%E8%A1%A8/</guid><description>PLT表 深入理解GOT表和PLT表 - 知乎 (zhihu.com)
PLT（Procedure Linkage Table）过程链接表，位于代码段，内容不可修改。 PLT表通过引用GOT表中的函数的绝对地址，来把控制转移到实际的函数。 在实际的可执行程序或者共享目标文件中，PLT表在名称为.plt的section中。
结构 PLT[0]：保存一段操作，操作内容：push目标函数编号，跳转到GOT[2]
来源 GOT表和PLT表知识详解_77458的博客-CSDN博客_got表
这个函数是编译系统自己加的，大家可以通过disas gets看看里面的代码，如下图：</description></item><item><title>PUF</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/mcu/PUF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/mcu/PUF/</guid><description>PUF 特点 唯一性：每一个芯片都是随机分布的、唯一的。 防克隆性：芯片本身就是在芯片制造过程中由于不确定因素提取出来的，无法重新复制相同的PUF值。误差本就是不可控因素，因此不能逆向去生成指定的“误差”。 不可预测性：由于芯片在制造出来之前，没有办法来预测。 防篡改性：芯片本身PUF值无法定位修改。 无需存储：每次芯片启动只需要在电路结构中提取，无需存储器件来存储。 实现分类 ![[z-oblib/z2-attachments/Pasted image 20220904144719.png]]
SRAM PUF SRAM PUF利用[[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/SRAM|SRAM]] Cell，首尾相接的反相器，在制造过程中，虽然电路架构完全一样，但是电路驱动能力有强弱之分，导致SRAM在上电时的Cell上0,1的分布是随机分布的，因此，利用这个特征可以提取出PUF 仲裁PUF 仲裁PUF，同一个信号从起点到终点所用的时间（延迟），在制造过程中会存在误差。 RO PUF（环形振荡器） 环形振荡器PUF，利用环形振荡器电路，在不同芯片制造出来之后，频率产生也会存在误差 VIA PUF 实际设计中，VIA存在设计规则，利用设计规则，设计从小到大的孔洞，根据工艺的特性，来提取出VIA PUF SRAM实现 工作原理 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/锁存器|锁存器]]在初始无输入情况下，输出会因生成工业的不可控误差产生不同的初始输出值。</description></item><item><title>ReentrantLock</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantLock/</guid><description>ReentrantLock 相当于是一个java层面实现的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]。
特点 相对于 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 它具备如下特点：
可中断（放弃争抢锁） 可以设置超时时间 可以设置为公平锁 先到先得，而不是随机争抢 解决线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]]问题 支持多个条件变量 条件变量相当于synchronized中的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|waitSet]]，不满足条件的可以在wait_set等待 支持多个条件变量意味着有多个waitSet，可以根据不同条件进入不同set等待 与 synchronized 一样，都支持可重入 state标识资源是否为锁定状态。</description></item><item><title>ReentrantReadWriteLock</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantReadWriteLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ReentrantReadWriteLock/</guid><description>ReentrantReadWriteLock 当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select &amp;hellip;from &amp;hellip; lock in share mode 提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</description></item><item><title>ret</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/ret/</guid><description>ret pop eip 还原执行流（将此时 esp 所指的上层函数调用foo时的地址弹入 eip 寄存器内）；</description></item><item><title>RS锁存器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/RS%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/RS%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>RS锁存器 RS锁存器是一两输入、两输出的电路，其电路如下图a，其有两个互相交叉反馈相连的两个与非门构成，其两个输出为两个相反的输出（或称为互补输出）。
![[z-oblib/z2-attachments/Pasted image 20220904151011.png]]</description></item><item><title>Runnable</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Runnable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Runnable/</guid><description>Runnable 用来承载供Thread对象执行的任务，将任务从Thread中抽出来可以更加灵活。
1 2 Runnable runnable = () -&amp;gt; log.debug(&amp;#34;runnable&amp;#34;); // lambda Thread t2 = new Thread(runnable); 因为Runnable是一个@FunctionalInterface接口，所以可以通过[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/lambda|lambda]]的形式实现。 通过把方法包装成Runnable更加灵活，并且Runnable对[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]等高级API更加友好。这种思想也就是[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/组合优于继承|组合优于继承]]。</description></item><item><title>safepoint</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/safepoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/safepoint/</guid><description>safepoint 什么是safepoint safepoint可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。
从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。
什么地方可以放safepoint 下面以Hotspot为例，简单的说明一下什么地方会放置safepoint
理论上，在解释器的每条字节码的边界都可以放一个safepoint，不过挂在safepoint的调试符号信息要占用内存空间，如果每条机器码后面都加safepoint的话，需要保存大量的运行时数据，所以要尽量少放置safepoint，在safepoint会生成polling代码询问VM是否要“进入safepoint”，polling操作也是有开销的，polling操作会在后续解释。
通过JIT编译的代码里，会在所有方法的返回之前，以及所有非counted loop的循环（无界循环）回跳之前放置一个safepoint，为了防止发生GC需要STW时，该线程一直不能暂停。另外，JIT编译器在生成机器码的同时会为每个safepoint生成一些“调试符号信息”，为GC生成的符号信息是OopMap，指出栈上和寄存器里哪里有GC管理的指针。</description></item><item><title>Semaphore</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Semaphore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Semaphore/</guid><description>Semaphore [ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]上限。
应用 使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现） 用 Semaphore 实现简单连接池，对比『[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]]』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的 简化连接池 一种享元模式应用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Pool { // 1.</description></item><item><title>sleep</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep/</guid><description>sleep sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间，睡眠是指让线程放弃当前CPU的时间片，但是并不会释放锁，抱着锁睡觉。它有这样两个方法：
Thread.sleep(long) Thread.sleep(long, int) 同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。
作用 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException。 睡眠结束后的线程未必会立刻得到执行。 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。 打断睡眠（非唤醒） sleep()是可以打断的，而打断的方式是通过InterruptedException异常，所以sleep()需要捉起来。</description></item><item><title>sleep和wait的区别</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>sleep和wait的区别 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/sleep|sleep]]方法是不会释放当前的锁的，而wait方法会。 这也是最常见的一个多线程面试题。 wait可以指定时间，也可以不指定；而sleep必须指定时间。 wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。 wait必须放在同步块或同步方法中，而sleep可以在任意位置。</description></item><item><title>SPI</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/SPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/SPI/</guid><description>SPI SPI 全称为Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。
简单点说SPI就是 JDK 内置的一个服务发现机制，它使得接口和具体实现完全解耦。我们只声明接口，具体的实现类在配置中选择。
具体的就是你定义了一个接口，然后在META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。
这样就通过配置来决定具体用哪个实现！</description></item><item><title>spring报错分析技巧</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/spring%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/spring%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7/</guid><description>spring报错分析技巧 错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面。 有时最下一层是spring内部的异常，可以往上看一级。 最下面是核心原因，最上面是整条错误链的串显示。</description></item><item><title>SRAM</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/SRAM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/SRAM/</guid><description>SRAM 静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失（被称为volatile memory），这与在断电后还能储存资料的ROM或闪存是不同的。
存储结构 ![[z-oblib/z2-attachments/Pasted image 20220904150755.png]]
6T:指的是由六个晶体管组成，如图中的M1、M2、 M3、M4、M5、M6. SRAM中的每一bit存储在由4个场效应管(M1, M2, M3, M4)构成两个交叉耦合的反相器中。另外两个场效应管(M5, M6)是存储基本单元到用于读写的位线(BitLine)的控制开关。
6T电路等价于SR锁存器：
![[z-oblib/z2-attachments/Pasted image 20220904150813.png]]</description></item><item><title>StampedLock</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/StampedLock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/StampedLock/</guid><description>StampedLock 该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用。
一个特殊的读写锁。
使用 读锁 1 2 long stamp = lock.readLock(); lock.unlockRead(stamp); 写锁 1 2 long stamp = lock.</description></item><item><title>stream</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/stream/</guid><description>stream OJ中的应用 将内容读取成string，再按照空格分割出字符串数组，再通过stream将字符串数组转成int数组。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class P5788 { public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader(new InputStreamReader(System.</description></item><item><title>synchronized</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized/</guid><description>synchronized 简介 俗称对象锁，采用互斥的方式让同一时刻只有一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]能持有对象锁。其它线程再想获取这个对象锁时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]]内的代码，不用担心线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/上下文切换|上下文切换]]。
特点 synchronized不可中断（不可放弃争抢锁）： 不可中断的意思是等待获取锁的时候不可中断，拿到锁之后可中断，没获取到锁的情况下，中断操作一直不会生效。 synchronized规定：线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。保证了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|内存可见性]]。 synchronized代码块中的代码越多，上锁时间越长，尽量减少锁的粒度。 synchronized可以保证原子性、可见性，并且对外部展现有序性，即内部的重排序不会影响外部（而不是不会发生重排序）（因为同一时刻进入synchronized代码块的只有一个线程，单线程下重排序无影响）。 要想保证有序性，就要把东西全部交给synchronized管理，而不能暴露一部分在外面，这也是[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/单例模式#双重校验锁|双重检查锁]]实现时要加[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]]。 语法 1 2 3 4 synchronized(对象) { // 临界区 } 流程 比喻 !</description></item><item><title>ThreadPoolExecutor</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</guid><description>ThreadPoolExecutor ![[z-oblib/z2-attachments/Pasted image 20220607225611.png]]
线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程池|线程池]]状态，低 29 位表示[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]数量：
状态名 高3位 接收新任务 处理阻塞队列任务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务，但会处理阻塞队列剩余任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列任务 TIDYING 010 任务全执行完毕，活动线程为 0 即将进入 终结 TERMINATED 011 终结状态 从数字上比较，TERMINATED &amp;gt; TIDYING &amp;gt; STOP &amp;gt; SHUTDOWN &amp;gt; RUNNING。</description></item><item><title>tomcat原理</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/tomcat%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Tomcat/tomcat%E5%8E%9F%E7%90%86/</guid><description>tomcat原理 ![[z-oblib/z2-attachments/Pasted image 20220815211547.png]]
右边 &amp;ndash; 请求处理 ![[z-oblib/z2-attachments/Pasted image 20220815210239.png]]
wrapper的作用是给具体的servlet实现进行分类，每个servlet实现对应一个wrapper，存储多个运行时产生的实例。
作用的防止混乱。
valve本身是一个责任链的模式，例如可以自定义valve来记录日志。 请求到达对应层次的时候，tomcat就会将请求传递给valve链处理，最终从StandardEngineValve将请求转交给下一层。
Wrapper中最后一个valve（StandardWrapperValve）会调用具体的业务servlet实例对象上的方法，统一调用service方法（servlet父类方法）， service根据http头的动作字符串（GET/POST。。）调用对应的方法。
左边 &amp;ndash; 请求产生</description></item><item><title>volatile</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/volatile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/volatile/</guid><description>volatile https://ifeve.com/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97/
内存可见性问题 1 2 3 4 5 6 7 8 9 10 11 A = 0; B = 0; T0 { A = 1; print(B); } T1 { B = 1; print(A); } 这样一段代码可能会出现下列四种输出：</description></item><item><title>wait&amp;notify</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/waitnotify/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/waitnotify/</guid><description>wait&amp;amp;notify wait 为什么需要wait 由于条件不满足，小南不能继续进行计算 但小南如果一直占用着锁，其它人就得一直阻塞，效率太低 ![[z-oblib/z2-attachments/Pasted image 20220528165543.png]] 于是老王单开了一间休息室（调用 wait 方法），让小南到休息室（WaitSet）等着去了，但这时锁释放开， 其它人可以由老王随机安排进屋 直到小M将烟送来，大叫一声 [ 你的烟到了 ] （调用 notify 方法） !</description></item><item><title>x86寄存器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/x86%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/x86%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>x86寄存器 ![[z-oblib/z2-attachments/Pasted image 20220912222502.png]]
这八个寄存器的名称如下：EAX（累加器）、EBX（基址）、ECX（计数）、EDX（数据）、ESP（栈指针）、EBP（基址指针）、ESI（源变址）、EDI（目的变址）。</description></item><item><title>三色标记算法</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/</guid><description>三色标记算法 解决的问题 CMS垃圾回收机制下，对象标记线程和用户线程同时执行，用户线程会影响标记准确度，导致：
浮游垃圾问题 该问题不同特别在意，因为浮动垃圾会在下次GC时被清理。 错误回收问题 该问题要特别在意，因为回收了一个正在使用的对象是严重的BUG。 解决思路 通过广度优先算法扫描gc树上的节点，并用黑色标记已经扫描完成的节点，灰色标记正在扫描的节点，白的未扫描的节点，达到性质：
黑色节点的所有子节点都应该是灰色节点。 所有白色节点都是垃圾。 因为黑色节点是已经扫描完成的，不会再处理，所以若用户线程把白色节点接入黑色节点就会产生错误：该白色节点不应该被回收但不会再变色了。</description></item><item><title>上下文</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>上下文 上下文是指某一时间点 CPU 寄存器和程序计数器的内容。</description></item><item><title>上下文切换</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</guid><description>上下文切换 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/上下文|上下文]]切换（有时也称做进程切换或任务切换）是指 CPU 从一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]（或[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]）切换到另一个进程（或线程）。</description></item><item><title>两阶段终止模式</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</guid><description>两阶段终止模式 Two Phase Termination
要优雅 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]T1优雅的终止线程T2，指的是给T2一个料理后事的机会。
错误思路 使用线程对象的stop()停止线程： stop方法会真正杀死线程会强制释放CPU资源和锁，但是不能保证清理工作完整（如关闭文件/连接等），会导致数据不同步等问题，不安全。已弃用。 使用System.exit(int)方法停止线程： 目的是停止一个线程，但是会让整个程序都停止。 使用打断标记实现 例-系统状态定时监控 需要有停止监控的功能：</description></item><item><title>中断</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%AD%E6%96%AD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%B8%AD%E6%96%AD/</guid><description>中断 线程中断即线程运行过程中被其他线程给打断了。
原理 中断无法直接终止另一[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]，只能发起通知。 中断需要被中断线程自己处理。 每个对象有一boolean标识是否有中断请求（来自其它线程/自身）。 线程 t1 想中断线程 t2，只需要在线程 t1 中将线程 t2 对象的中断标识置为 true，然后线程 t2 可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。 java.</description></item><item><title>乐观锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B9%90%E8%A7%82%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B9%90%E8%A7%82%E9%94%81/</guid><description>乐观锁 乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]的技术来保证线程执行的安全性。
由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。
乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/悲观锁|悲观锁]]多用于”写多读少“的环境，避免频繁失败和重试影响性能。</description></item><item><title>任务调度线程池</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>任务调度线程池 用来代替[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Timer|Timer]]。
ScheduledExecutorService 1 2 3 4 5 6 7 8 9 ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); // 添加两个任务，希望它们都在 1s 后执行 executor.</description></item><item><title>伪共享</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%85%B1%E4%BA%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E4%BC%AA%E5%85%B1%E4%BA%AB/</guid><description>伪共享 给数据加填充让数组的每个元素在缓存中强制换行，将cpu缓存中的数据拆分成多行，防止数据挨在一起后被连坐导致缓存集体失效。
因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中。 CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效，降低效率。
![[z-oblib/z2-attachments/Pasted image 20220602143831.</description></item><item><title>偏向锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%81%8F%E5%90%91%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%81%8F%E5%90%91%E9%94%81/</guid><description>偏向锁 存在缘由 轻量级锁在没有竞争时，每次[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#获取锁|在5.2重入锁时]]都要重复执行[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static final Object obj = new Object(); public static void m1() { synchronized( obj ) { // 同步块 A m2(); } } public static void m2() { synchronized( obj ) { // 同步块 B m3(); } } public static void m3() { synchronized( obj ) { // 同步块 C } } 对应轻量级锁：</description></item><item><title>内部类</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/0-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>内部类 被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。
Inner Class 1 2 3 4 5 class Outer { class Inner { // 定义了一个Inner Class } } 上述定义的Outer是一个普通类，而Inner是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</description></item><item><title>创建和运行线程</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B/</guid><description>创建和运行线程 创建时部分使用了[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/lambda|lambda]]简化代码，为了便于理解未全部使用。 方法1 直接使用Thread 1 2 3 4 5 6 7 Thread t1 = new Thread() { @Override public void run() { log.</description></item><item><title>动态代理</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>动态代理 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class DynamicProxySample { interface Greet { Object sayHello(String name); } public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.</description></item><item><title>协变</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8D%8F%E5%8F%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8D%8F%E5%8F%98/</guid><description>协变 子类型可以隐性的转换为父类型。</description></item><item><title>单调栈</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>单调栈 https://www.cnblogs.com/liang24/p/14200734.html #TODO</description></item><item><title>原子引用</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/</guid><description>原子引用 AtomicReference AtomicMarkableReference AtomicStampedReference 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DecimalAccountSafeCas implements DecimalAccount { AtomicReference&amp;lt;BigDecimal&amp;gt; ref; public DecimalAccountSafeCas(BigDecimal balance) { ref = new AtomicReference&amp;lt;&amp;gt;(balance); } @Override public BigDecimal getBalance() { return ref.</description></item><item><title>原子性</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%80%A7/</guid><description>原子性</description></item><item><title>原子操作</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>原子操作 JDK提供了一些用于原子操作的类，在java.util.concurrent.atomic包下面。在JDK 11中，有如下17个类： ![[z-oblib/z2-attachments/原子类 1.jpg]] 从名字就可以看得出来这些类大概的用途：
原子更新基本类型 原子更新数组 原子更新引用 原子更新字段（属性） 以AtomicInteger的getAndAdd(int delta)方法为例 实际就是调用native方法，获取某个对象内存空间偏移offset处的变量，循环尝试获取该变量的值是否与线程持有值一致，一致则替换成目标值，不一致表示有其它线程修改过了。
先看看这个方法的源码：
1 2 3 public final int getAndAdd(int delta) { return U.</description></item><item><title>原子数组</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>原子数组 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** 参数1，提供数组、可以是线程不安全数组或线程安全数组 参数2，获取数组长度的方法 参数3，自增方法，回传 array, index 参数4，打印数组的方法 */ // supplier 提供者 无中生有 ()-&amp;gt;结果 // function 函数 一个参数一个结果 (参数)-&amp;gt;结果 , BiFunction (参数1,参数2)-&amp;gt;结果 // consumer 消费者 一个参数没结果 (参数)-&amp;gt;void, BiConsumer (参数1,参数2)-&amp;gt; private static &amp;lt;T&amp;gt; void demo( Supplier&amp;lt;T&amp;gt; arraySupplier, Function&amp;lt;T, Integer&amp;gt; lengthFun, BiConsumer&amp;lt;T, Integer&amp;gt; putConsumer, Consumer&amp;lt;T&amp;gt; printConsumer ) { List&amp;lt;Thread&amp;gt; ts = new ArrayList&amp;lt;&amp;gt;(); T array = arraySupplier.</description></item><item><title>双亲委派</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</guid><description>双亲委派 https://blog.csdn.net/weixin_36586120/article/details/117457014
定义 类加载器加载一个类时，会先将其逐级上交给父级加载器尝试加载 父子关系不是继承维护，而是组合，每个类加载器都持有一个 parent 字段，指向父加载器。 父级加载器先检查是否已加载，再尝试递归上交 若无法处理再向下委派加载任务。 ![[z-oblib/z2-attachments/20210601230727770.png]]
目的 双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。</description></item><item><title>双向认证</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</guid><description>双向认证</description></item><item><title>变量命名规范</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</guid><description>变量命名规范 H hdr = HeaDeR = header 常出现在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|elf]]结构定义中，如shdr为 section header R rel = relocation = 重定位 rel.</description></item><item><title>变量的线程安全</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid><description>变量的线程安全 成员变量 如果它们没有共享，则[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]]，需要考虑线程安全 局部变量 局部变量是线程安全 局部变量引用的对象不一定线程安全 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围，需要考虑线程安全 分析 非引用局部变量 1 2 3 4 public static void test1() { int i = 10; i++; } 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。</description></item><item><title>同步</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5/</guid><description>同步 所有的执行顺序都严格地和代码书写的顺序一致。
以调用方角度 需要等待结果返回，才能继续运行就是同步。
线程同步 线程同步是线程之间按照一定的顺序执行。
优点 同步最大的优点是思路清晰。你永远可以知道你的程序是按照怎样的顺序执行的，不用担心任何意料之外的情况。
缺点 在某些情境下，它会带来性能的浪费。
以一个生活中的场景为例：你在网上下载一个文件，但是文件很大，需要很长时间才能下完。这时候，你肯定不会盯着进度条一点点走，而是去做点别的事情，读一会书，看一会电影，之类的。
但如果有一个完全“同步”的人，他为自己设定的程序是下载这个文件，然后运行它，这样的话，他为了不让自己的运行逻辑乱掉，就会一直守在电脑前，直到文件下载完成才做下一步的工作。正常人肯定不能忍受这样无聊的等待，也不会希望自己的程序在这种无聊的事上浪费时间。</description></item><item><title>哲学家就餐问题</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</guid><description>哲学家就餐问题 ![[z-oblib/z2-attachments/Pasted image 20220529223523.png]]
有五位哲学家，围坐在圆桌旁：
他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package test; import lombok.</description></item><item><title>回调</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9E%E8%B0%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9E%E8%B0%83/</guid><description>回调 A类a方法调用B类的b方法，b方法再调用A类的c方法 就是不光把工作内容交给别的线程做，还要把结果处理也交给别的线程做。
回调的本质，是将一个任务分成两部分，在耗时操作之前的部分，和耗时操作之后的部分，后者是前者的继续，或者叫做[[续体]]（continuation）。回调式就是把续体写成回调函数的形式，传递到其他地方，这种操作又叫做续体传递（continuation-passing）。从这个层面上看，回调是续体传递风格（Continuation-Passing Style, CPS）的一种。
举例 现在领导要员工A做一件事，给他发布了任务，需要员工A做完后再通知领导。
对于领导来说：发布任务（fabuTask）,获得结果（result）
对于员工来说：处理任务（doSomthing）,通知领导结果（result）
任务发布者 任务发布者定义了回调函数，回调函数的参数就是未来任务执行者提交的结果。
1 2 3 4 5 6 7 /** * 回调的方法 * */ public interface CallBack { void result(String result); } 领导发布的任务：让员工做事：</description></item><item><title>基地址</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%9F%BA%E5%9C%B0%E5%9D%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%9F%BA%E5%9C%B0%E5%9D%80/</guid><description>基地址 计算 linux - ELF的基地址 | 码农俱乐部 - Golang中国 - Go语言中文社区 (mlog.club) ELF 文件 - CTF Wiki (ctf-wiki.org)</description></item><item><title>基本语法</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>基本语法</description></item><item><title>委派</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%A7%94%E6%B4%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%A7%94%E6%B4%BE/</guid><description>委派 A 委派 B 做某事，则 B 内会有 A 的实例，并调用 A 的方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Java program to illustrate // delegation class RealPrinter { // the &amp;#34;delegate&amp;#34; void print() { System.</description></item><item><title>字符串表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8/</guid><description>字符串表 字符串表节包含以空字符结尾的字符序列，通常称为字符串。目标文件使用这些字符串表示符号和节的名称。可以将字符串作为字符串表节的索引进行引用。
第一个字节（索引零）包含空字符。同样，字符串表的最后一个字节也包含空字符，从而确保所有字符串都以空字符结尾。根据上下文，索引为零的字符串不会指定任何名称或指定空名称。
允许使用空字符串表节。节头的 sh_size 成员值为零。对于空字符串表，非零索引无效。
节头的 sh_name 成员包含节头字符串表的节索引。节头字符串表由 ELF 头的 e_shstrndx 成员指定。下图显示了具有 25 个字节的字符串表，并且其字符串与各种索引关联。
举例 ELF 字符串表： ![[z-oblib/z2-attachments/Pasted image 20220911030139.</description></item><item><title>对象内存构成</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90/</guid><description>对象内存构成 Java 中通过 new 关键字创建一个类的实例对象，对象存于内存的堆中并给其分配一个内存地址。 ![[z-oblib/z2-attachments/Pasted image 20220428151815.png]] 在 JVM 中，Java对象保存在堆中时，由以下三部分组成：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/对象头|对象头]]（object header）：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。 实例数据（Instance Data）：主要是存放类的数据信息，父类的信息，对象字段属性信息。 对齐填充（Padding）：为了字节对齐，填充的数据，不是必须的。 ![[z-oblib/z2-attachments/Pasted image 20220428151834.</description></item><item><title>对象头</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%A4%B4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E5%A4%B4/</guid><description>对象头 ![[z-oblib/z2-attachments/Pasted image 20220428151706.png]]
在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。另外对于数组而言还会有一份记录数组长度的数据。类型指针是指向该对象所属类对象的指针。
普通对象 1 2 3 4 5 |--------------------------------------------------------------| | Object Header (64 bits) | |------------------------------------|-------------------------| | Mark Word (32 bits) | Klass Word (32 bits) | |------------------------------------|-------------------------| 数组对象 1 2 3 4 5 |------------------------------------------------------------------------------| | Object Header (96 bits) | |------------------------------|----------------------|------------------------| | Mark Word(32bits) | Klass Word(32bits) | array length(32bits) | |------------------------------|----------------------|------------------------| Mark Word [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]</description></item><item><title>对象的引用</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</guid><description>对象的引用 引用类型 被垃圾回收时间 用途 生存时间 强引用 从来不会 对象的一般状态 JVM停止运行时终止 软引用 当内存不足时 对象缓存 内存不足时终止 弱引用 正常垃圾回收时 对象缓存 垃圾回收后终止 虚引用 正常垃圾回收时 跟踪对象的垃圾回收 垃圾回收后终止 https://juejin.</description></item><item><title>寻址方式</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/</guid><description>寻址方式 寻址方式: 指令中指明操作数存放位置的表达方式.
指令中操作数的数据存放位置情况 存放指令中 (立即数) 操作数包含在指令中 备操作数据直接表示在指令的操作数字段中 紧跟在操作码之后 例如 MOV AL, 10H 存放于寄存器中 (寄存器操作数) 数据存放在 CPU 的一个寄存器中 例如 INC CX 存放于存储器中 (存储器操作数) 数据再内存或 I/I 端口中 存放数据的偏移地址以某种方式表示在指令中 例如 MOV AX, [2500H] 其中 [2500] 为存储器操作数 存储器操作数中操作的数字段指示此操作数的偏移地址 段地址由某个段寄存器提供 默认为 DS 提供 寻址方式分类 立即数寻址 操作数为立即数 直接存放在指令的操作数字段 只允许源操作数为立即数 目标操作数必须是寄存器或存储单元 给寄存器或存储单元赋值 寄存器寻址 直接在指令中写出寄存器名称 存储器寻址 直接寻址 操作数存在内存中, 操作数的偏移地址直接表示在指令中 表示格式: [偏移地址] 默认操作数存放在内存的数据段中 例如 MOV AL, [1064H] 段超越指明使用的段 寄存器间接寻址 基址加变址寻址 相对加基址变址寻址</description></item><item><title>导入表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%85%A5%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%85%A5%E8%A1%A8/</guid><description>导入表 (34条消息) PE导入表和IAT表的原理及工作关系_C4cke的博客-CSDN博客_pe文件iat表
分类 IAT: Import Address Table 导入（函数）地址表 INT: Import Name Table 导入（函数）名称表 结构 Import Descriptor 导入表，是记录PE文件中用到的动态连接库的集合，一个dll库在导入表中占用一个元素信息的位置，这个元素描述了该导入dll的具体信息。如dll的最新修改时间、dll中函数的名字/序号、dll加载后的函数地址等。而一个元素即一个结构体，一个导入表即该结构体的数组，其结构体如下所示：</description></item><item><title>导出表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%87%BA%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%AF%BC%E5%87%BA%E8%A1%A8/</guid><description>导出表 导出表的作用是自身提供一张清单，表明自己又哪些函数，大多是dll为exe提供函数，存在导出表。</description></item><item><title>开闭原则</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid><description>开闭原则 开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
闭合原则 不想向外暴露的设置成final/private。</description></item><item><title>异步</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5/</guid><description>异步 以调用方角度 不需要等待结果返回，就能继续运行就是异步。</description></item><item><title>快速排序</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快速排序 快速排序是 [[2_0_2-计算机科学/2_0_2_0_2_1-数据结构与算法/冒泡排序|冒泡排序]] 的改进版本。
快排的每一轮都是讲一个基数归为，所以外层要循环 n 次： ![[z-oblib/z2-attachments/3.9-1.png]]
时间复杂度 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。 每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。 这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。 当然在最坏的情况下，仍可能是相邻的两个数进行了交换。 因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(N2)，它的平均时间复杂度为 O(NlogN)。 其实快速排序是基于一种叫做“二分”的思想。
实现 双指针版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 快速排序 public void quickSort(int left, int right) { // 子集只有一个元素旧没必要继续切分快排了 int lens = right - left + 1; if (lens&amp;lt;2) return; int base = num[left]; // 取区间第一个元素作base值 int curLeft = left; // 记录当前左区间下标，用于递归 int curRight = right; // 记录当前右区间下标，用于递归 boolean leftReady = false, rightReady = false; // 标志是否找到需要交换的数 while (left!</description></item><item><title>悲观锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%82%B2%E8%A7%82%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%82%B2%E8%A7%82%E9%94%81/</guid><description>悲观锁 悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]在执行。</description></item><item><title>无状态</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%8A%B6%E6%80%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E7%8A%B6%E6%80%81/</guid><description>无状态 在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的。因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】。</description></item><item><title>晶体管</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E6%99%B6%E4%BD%93%E7%AE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E6%99%B6%E4%BD%93%E7%AE%A1/</guid><description>晶体管 所有可以通过一个电流或电压控制另一个电流或电压的器件。</description></item><item><title>最短路径</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid><description>最短路径 该算法的关键是： 找两个集合之间的最短路径，分别是已经确定的点的集合/未确定点的集合。 每次都在已确定点中的未知道路找最短的路。 因此可以将路都加入优先级队列，自动排序。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 import java.</description></item><item><title>有序性</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%9C%89%E5%BA%8F%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%9C%89%E5%BA%8F%E6%80%A7/</guid><description>有序性 JVM 会在不影响正确性的前提下，可以调整语句的执行顺序。
有序性被破坏的例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean ready = false; // 线程1 执行此方法 public void actor1(I_Result r) { if(ready) { r.</description></item><item><title>构建RPC思路</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/%E6%9E%84%E5%BB%BARPC/%E6%80%9D%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/%E6%9E%84%E5%BB%BARPC/%E6%80%9D%E8%B7%AF/</guid><description>构建RPC思路 问题 客户端如何知道服务端地址 客户端如何知道有哪些服务 客户端如何向服务端传递参数 数据如何编解码 服务端如何验证客户端和请求合法 服务端如何将执行结果返回给客户端 客户端如何等待结果 服务端如何同时处理多个请求</description></item><item><title>标志寄存器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>标志寄存器 结构： ![[z-oblib/z2-attachments/Pasted image 20220912223816.png]]
含义： ![[z-oblib/z2-attachments/Pasted image 20220912223822.png]]
状态标志 用于记录程序运行结果的状态信息 CF 进位标志 (Carry Flag) 当运算结果的最高有效位有进位(加法)或借位(减法)时, 置 1, 否则 0 ZF 零标志 (Zero Flag) 弱运算结果为 0, 则置 1, 否则 0 SF 符号标志 (Sign Flag) 若运算结果最高位(符号位)为 1, 则置 1, 否则 0 PF 奇偶标志 (Parity Flag) 运算结果最低字节中 1 的个数为 0 或偶数, 则置 1, 否则 0 OF 溢出标志 (Overflow Flag) 运算结果有溢出, 则置 1, 否则 0 溢出: 有符号数的运算结果不正确 AF 辅助进位标志 (Auxiliary Carry Flag) 运算时 D3 (低半字节) 有进位或借位, 置1, 否则 0 控制标志 用于控制处理器执行指令 DF 方向标志 (Direction Flag) 用于串操作指令, 控制地址的变化方向 1 则存储器地址自动增加 0 则存储器地址自动减少 CLD 用于复位 DF = 0 STD 用于置位 DF = 1 IF 终端允许标志 (Interrupt-enable Flag) 0 禁止中断 1 允许中断 CLI 用于复位 IF = 0 STI 用于置位 IF = 1 TF 陷阱标志 (Trap Flag) 0 处理器正常工作 1 处理器单步执行</description></item><item><title>栈帧</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%A0%88%E5%B8%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%A0%88%E5%B8%A7/</guid><description>栈帧 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的虚拟机栈的栈元素。
栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。
每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在 虚拟机里面从入栈到出栈的过程。
在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了。
因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
局部变量表 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。
动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支付方法调用过程中的动态连接（Dynamic Linking）。
在类加载阶段中的解析阶段会将符号引用转为直接引用，这种转化也称为静态解析。另外的一部分将在每一次运行时期转化为直接引用。这部分称为动态连接。
返回地址 当一个方法开始执行后，只有2种方式可以退出这个方法 ：</description></item><item><title>栈迁移</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E6%A0%88%E8%BF%81%E7%A7%BB/</guid><description>栈迁移</description></item><item><title>死锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%AD%BB%E9%94%81/</guid><description>死锁 原因 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/多把锁|多把锁]]的情况可能会发生死锁：
一个线程需要同时获取多把锁，这时就容易发生死锁 t1 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]] 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package test; import lombok.</description></item><item><title>段寄存器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/</guid><description>段寄存器 8086CPU 有 4 个段寄存器
每个段寄存器用来确定一个逻辑段的起始位置
每种逻辑段均有自己的用途
CS: 代码段寄存器 (Code Segment) 利用 CS:IP 取得下一条要执行的指令 DS: 数据段寄存器 (Data Segment) 利用 DS:EA 存取数据段中的数据 SS: 栈段寄存器 (Stach Segment) 利用 CS:IP 操作堆栈顶的数据 ES: 附加段寄存器 (Extra Segment) 利用 ES:EA 存取附加段中的数据 EA 是偏移地址, 称之为有效地址 EA</description></item><item><title>活跃性</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E8%B7%83%E6%80%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B4%BB%E8%B7%83%E6%80%A7/</guid><description>活跃性 包括：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]]</description></item><item><title>流</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E6%B5%81/</guid><description>流 基本概念 流只是一个比喻。
任何比喻都无法完美。
流比喻数据的均匀连续性。
你从水龙头接水，无论拿杯子，脸盘，还是桶。只要水流不断，你都可以接满。
假设水龙头吐出的是大小不一的冰块，那就不叫连续了。
当然，计算机最小单位是字节，所以流数据最小单位也是字节（byte)。当然可以通过写程序模拟以位(bit 每字节8位）为单位的bit流。
模拟bit流多用在压缩算法。平常我们更多时候是需要连续的字节以某种方式组合起来读入或写出，比如以字符形式就是两个两个读（char，在java里是两个字节。）。看看jdk里有什xxxstream的类。
你的问题是自我想像流一定是个管子。其实在计算机世界里，管子是管子，流是流。
以文件流为比喻。你下载了1个G的某片，存在磁盘上总要占用一大块磁盘空间（物理上很可能是不连续的，但暂时想像它们是家里瓷盘上的一汪水）然后你凑过嘴，把嘴嘟起来，陶醉（假装）地吸上一口，字节带着细微的水花从你嘴唇穿入，这时候磁盘的一汪字节和你产生吸力的嘴之间，没有吸管，但真的有流。
你说嘴巴吸不了磁盘上的字节。你说甚至一G的文件在磁盘上很可能是分在不连续的扇区存储的，怎么有连续的流呢？
你说得很对。。。也许你看本地片子时，突然某处稍卡了一下，你怀疑是不是正好上个字节和下个字节之间 隔了几个扇区几个 磁道
。。。但其实通常不是的。操作系统不会这么直接。它会趁你慢慢欣赏某些片段时，早就将数据从慢腾腾的磁盘预读到快如闪电的内存中了，这个位于磁盘和播放器程序之间的缓存区，是很像你说的管子，但它真的和流这个对象没有什么关系，在代码中的流对象看来 那缓存区就是操作系统提供的文件。
JAVA代码是在 虚拟机</description></item><item><title>符号表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</guid><description>符号表 作用 一张“查询表。
符号表包含了一些通用的符号，这部分信息在进行了 strip 操作后就会消失。这些符号信息可能包括变量名、函数名。 符号表本质就是一个映射表，举个例子：某行二进制汇编代码映射到源码第几行。
符号表的作用：
调试：汇编&amp;ndash;查找&amp;ndash;&amp;gt;源码位置 重定位：函数名&amp;ndash;查找&amp;ndash;&amp;gt;汇编位置 调试 window工程有一个*.pdb文件,里面编包含调试符号.可参阅wiki window pdb格式。 在java工程会使用一个叫混淆的技术，混淆后会生成混淆前后的映射文件mapping.txt,这个也可以理解为符号表的一种。 在linux有一个dwarf的文件格式也是专门用于调试的文件。参阅wiki DWARF。 重定位 重定位可以大致分为两种类别动态重定位与静态重定位</description></item><item><title>符号解析</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</guid><description>符号解析 作用 确定符号引用关系，将每个模块中引用的符号与某个目标模块的定义符号建立关联。
在我们通常的观念里,之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件,所以要将它们链接起来。比如我们直接使用ld来链接“a.o”,而不将“b.o”作为输入。链接器就会发现 shared和swap两个符号没有被定义,没有办法完成链接工作： ![[z-oblib/z2-attachments/Pasted image 20220911163933.png]] 这也是我们平时在编写程序的时候最常碰到的问题之一,就是链接时符号未定义。导致这个问题的原因很多,最常见的一般都是链接时缺少了某个库,或者输入目标文件路径不正确或符号的声明与定义不一样。所以从普通程序员的角度看,符号的解析占据了链接过程的主要内容。 重定位过程也伴随着符号的解析过程,每个目标文件都可能定义一些符号也可能引用到定义在其他目标文件的符号。重定位的过程中,每个重定位的入口都是对一个符号的引用,那么当链接器须要对某个符号的引用进行重定位时,它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表,找到相应的符号后进行重定位。比如我们查看“a.o”的符号表： ![[z-oblib/z2-attachments/Pasted image 20220911164046.png]] GLOBAL”类型的符号,除了“main”函数是定义在代码段之外,其他两个“ shared和“swap”都是“UND”,即“undefined”未定义类型,这种未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后,所有这些未定义的符号都应该能够在全局符号表中找到,否则链接器就报符号未定义错误。
流程 《程序员的自我修养》番外笔记——符号解析与重定位 - SegmentFault 思否</description></item><item><title>类加载器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid><description>类加载器 简介 一个可以将Java字节码加载为java.lang.Class实例的工具。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。
特点 动态加载，无需在程序一开始运行的时候加载，而是在程序运行的过程中，动态按需加载，字节码的来源也很多，压缩包jar、war中，网络中，本地文件等。类加载器动态加载的特点为热部署，热加载做了有力支持。 全盘负责，当一个类加载器加载一个类时，这个类所依赖的、引用的其他所有类都由这个类加载器加载，除非在程序中显式地指定另外一个类加载器加载。所以破坏双亲委派不能破坏扩展类加载器以上的顺序。 为何需要多个类加载器 思考以下情景：
首先，是为了区分同名的类：假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。试想，这时候 jvm 该怎么加载这些类同时能尽可能的避免掉类加载时对同名类的差异检测呢？当然是不同的应用都拥有自己独立的类加载器了。 其次，是为了更方便的加强类的能力：类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。怎么样达到仅修改一个类库而不对其他类库产生影响的效果呢？一个比较方便的模式就是每个类库都可以使用独立的类加载器 一个类的唯一性由加载它的类加载器和这个类的本身决定（类的全限定名+类加载器的实例ID作为唯一标识）。比较两个类是否相等（包括Class对象的equals()、isAssignableFrom()、isInstance()以及instanceof关键字等），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类就必定不相等。</description></item><item><title>索引</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95/</guid><description>索引</description></item><item><title>线程</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/</guid><description>线程 线程是进程中的子任务，同一个进程的线程之间共享进程占有的内存空间和I/O。</description></item><item><title>线程安全类</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB/</guid><description>线程安全类 自己实现类的时候维护[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]比较繁琐，java就给我们提供了一些线程安全的类。
常见线程安全类 String Integer StringBuﬀer Random Vector Hashtable java.util.concurrent 包下的类 线程安全场景举例：
1 2 3 4 5 6 7 8 9 Hashtable table = new Hashtable(); new Thread(()-&amp;gt;{ table.</description></item><item><title>线程池</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程池 使用线程池的原因 创建/销毁[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理 原理 Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor是这个接口的实现类。
ThreadPoolExecutor 构造方法 四个构造方法：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 五个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) // 六个参数的构造函数-1 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory) // 六个参数的构造函数-2 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) // 七个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 5~7个参数，其中5个为必须： ^22da28</description></item><item><title>线程通讯</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/</guid><description>线程通讯 方法 使用消息队列</description></item><item><title>组合优于继承</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF/</guid><description>组合优于继承 Program to an interface, not an implementation. (面向接口编程，而不是具体的实现)
Favor object composition over class inheritance.（如果某个场景的代码复用既可以通过类继承实现， 也可以通过对象组合实现， 尽量选择对象组合的设计方式）</description></item><item><title>继承</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF/</guid><description>继承 B 继承自 A，则 B 能获得 A 的属性，并接管操作。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Java program to illustrate // Inheritance class RealPrinter { // base class implements method void print() { System.</description></item><item><title>联合查询</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</guid><description>联合查询 联合索引就是复合索引、组合索引、多列索引。
联合查询是在[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_2-数据库系统/索引|索引]]的基础上，一个节点压缩放入多个列。类似一个多条件联合的if语句
![[z-oblib/z2-attachments/3f7c0b118d08445d9a66131124ec2276.png]]
1 if (name==Bill &amp;amp;&amp;amp; age==30 &amp;amp;&amp;amp; role==dev) 重复值越少的越放前面，比如一个列 95%的值都不重复，那么一般可以将这个列放最前面。另外，复合索引的字段数尽量不要超过 3个，一旦超过，要慎重考虑必要性。</description></item><item><title>自定义线程池</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>自定义线程池 ![[z-oblib/z2-attachments/Pasted image 20220607213829.png]]
拒绝策略接口 策略模式： 具体操作抽象成接口，具体实现由调用者传递进来。
1 2 3 4 5 // 拒绝策略 @FunctionalInterface interface RejectPolicy&amp;lt;T&amp;gt; { void reject(BlockingQueue&amp;lt;T&amp;gt; queue, T task); } 参数要包含queue，来决定是否要在queue上等待，例如queue.</description></item><item><title>自旋</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B/</guid><description>自旋 不断尝试去获取锁，一般用循环来实现。
自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。 ^f17d9d</description></item><item><title>自旋优化</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/</guid><description>自旋优化 自旋优化会因为循环消耗CPU资源。 java6后自旋锁是自适应的，成功的多尝试次数就多。 java7后不能控制是否开启自旋。 自旋成功 ![[z-oblib/z2-attachments/Pasted image 20220527214938.png]]
自旋失败 ![[z-oblib/z2-attachments/Pasted image 20220527214953.png]]</description></item><item><title>轻量级锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</guid><description>轻量级锁 使用方式 轻量级锁任然使用[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]语法，实现对使用者透明。
使用场景 如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。
流程 示例代码：
1 2 3 4 5 6 7 8 9 10 11 12 static final Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } } 获取锁 每个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]都的栈帧都会包含一个锁记录（Lock Record）的结构，内部可以存储锁定对象的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/Mark Word|Mark Word]]，用于存储锁对象目前的Mark Word的拷贝。</description></item><item><title>运行时动态链接</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</guid><description>运行时动态链接 PLT与GOT关系 PLTPLT表中的数据就是GOTGOT表中的一个地址，可以理解为一定是一一对应的： PLTPLT表中的每一项的数据内容都是对应的GOTGOT表中一项的地址这个是固定不变的。
![[z-oblib/z2-attachments/Pasted image 20220908214812.png]]
流程 (35条消息) PWN基础15：GOT表 和 PLT表_prettyX的博客-CSDN博客_查看got表
程序加载 触发重定向 修改GOT表[0]，向其填充PLT表首地址，用于触发查找 修改GOT表[2]，向其填充连接器查找函数地址，用于查找目标函数真实地址 首次调用目标动态连接函数，假设目标函数标号为n： PLT跳转到GOT[n] GOT[n]初始填充的是PLT[n]后一条地址，接着两条指令： push 编号n 跳转到PLT[0] PLT[0] 包含两条指令： push GOT[1] &amp;ndash; 填充的是[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/运行时动态链接#link_map|link_map]]的地址 跳转到GOT[2]内填充的地址空间 &amp;ndash; 链接器 此时一共push了2个参数，一个目标函数ID，一个link_map地址，正好是_dl_runtime_resolve的两个参数。 _dl_runtime_resolve 找到动态链接函数真实地址，回填到GOT[n]。 _dl_runtime_resolve - 简书 (jianshu.</description></item><item><title>迭代器</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid><description>迭代器 迭代器是一个用于保存状态的类，状态是指一个可迭代对象当前的遍历情况，例如可迭代对象元素量，当前迭代指针等。 迭代器主要是通过内部类实现，比如ArrayList内部有个Iterator类，这样iterator可以通过ArrayList.this访问到外部类的内容，最重要的是访问到外部类中存储的具体数据。 迭代器设计上降低了空间开销（维护指针信息而不用复制原数据），保证了与原数据的一致性（如果是复制则可能造成与原数据不一致）。 iterator()方法会返回一个可迭代对象内部的迭代器实例。</description></item><item><title>重定位表</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/</guid><description>重定位表 一张“需求表”：告诉链接器哪些指令即该指令的哪些部分要调整。
重定位表（Relocation Table）用于在程序加载到内存中时，进行内存地址的修正。
对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。
对于每个要重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF文件中的一个段，所以其实重定位表也可以叫重定位段。
结构 比如代码段“text”如有要被重定位的地方,那么会有一个相对应叫“, rel.text”的段保存了代码段的重定位表;如果代码段“data”有要被重定位的地方,就会有一个相对应叫“ rel.data&amp;quot;”的段保存了数据段的重定位表。我们可以使用 objdump来查看目标文件的重定位表。 ![[z-oblib/z2-attachments/Pasted image 20220911164434.png]]
每个要被重定位的地方叫一个重定入口( Relocation Entry,我们可以看到“a.o&amp;quot;里面有两个重定位入口。
重定位入口的偏移(Oset)表示该入口在要被重定位的段中的位置, RELOCATION RECORDS FOR .</description></item><item><title>重量级锁</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</guid><description>重量级锁 介绍 重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。
前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：
1 2 3 4 5 6 Contention List：所有请求锁的线程将被首先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !</description></item><item><title>锁接口和类</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB/</guid><description>锁接口和类 分类 可重入锁和非可重入锁 可重入：[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]能对资源重复加锁。
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]]关键字就是使用的重入锁。 在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。 如果我们自己在继承[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/AQS|AQS]]实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。 ReentrantLock就是可重入锁。 公平锁和非公平锁 公平：现来后到，FIFO，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足。
非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。 ReentrantLock支持非公平锁和公平锁两种。 读写锁和排它锁 排它：同一时刻只允许一个线程访问。 读写：同一时刻允许多个读线程访问。
Java提供了ReentrantReadWriteLock类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。 即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。 JDK中有关锁的一些接口和类 抽象类AQS/AQLS/AOS AQS（AbstractQueuedSynchronizer）资源上限是Integer.</description></item><item><title>锁的优缺点对比</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/</guid><description>锁的优缺点对比 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/偏向锁|偏向锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]
锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。同步块执行时间较长。</description></item><item><title>锁的其他优化</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/</guid><description>锁的其他优化 适应性自旋（Adaptive Spinning）：从[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁|轻量级锁]]获取的[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/轻量级锁#^8418aa|过程]]中我们知道，当[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]在获取轻量级锁的过程中执行[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]操作失败时，是要通过自旋来获取[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/重量级锁|重量级锁]]的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。 锁粗化（Lock Coarsening）：锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。举个例子： 1 2 3 4 5 6 7 8 9 public void lockCoarsening() { int i=0; synchronized (this){ i=i+1; } synchronized (this){ i=i+2; } } 上面的两个同步代码块可以变成一个</description></item><item><title>阻塞队列</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</guid><description>阻塞队列 简介 jdk中阻塞队列BlockingQueue解决的问题和实现的功能：
多线程场景下的生产者-消费者模式中，多个线程操作共享变量（资源）容易产生线程安全问题：重复消费、死锁。 资源池空了，需要阻塞消费者，唤醒生产者。 资源池满了，需要阻塞生产者，唤醒消费者。 BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了线程安全的队列访问方式，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。开发者只管往里面存取即可，不用担心线程安全问题。 BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue就是存放元素的容器。
操作方法 阻塞队列提供了四组不同的方法用于插入、移除、检查元素：
方法\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() - - 抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。 返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。 一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。 超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。 注意：</description></item><item><title>静态代理</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>静态代理 概述 代理类实现目标接口 代理类在内部实例化一个被代理类的对象 代理类重写目标方法，加入修改的逻辑，并可以调用被代理类的对象的方法 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StaticProxySample { interface Greet { void sayHello(String name); } static class GreetImpl implements Greet { @Override public void sayHello(String name) { System.</description></item><item><title>静态重定位</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</guid><description>静态重定位 1 2 3 4 5 6 7 8 9 10 11 12 13 //mainA.c int globalvar=0x123; fun test(){ } //mainB.</description></item><item><title>顺序一致性模型</title><link>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</guid><description>顺序一致性模型 顺序一致性内存模型是一个理想化的理论参考模型，它为程序员提供了极强的内存可见性保证。
顺序一致性模型有两大特性：
一个[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。
不管程序是否[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是原子性的，且立刻对所有线程可见。
为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是A1-&amp;gt;A2-&amp;gt;A3，线程B也有3个操作，B1-&amp;gt;B2-&amp;gt;B3。
假设正确使用了同步，A线程的3个操作执行后释放锁，B线程获取同一个锁。那么在顺序一致性模型中的执行效果如下所示：
![[z-oblib/z2-attachments/正确同步.png]]
操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。
假设没有使用同步，那么在顺序一致性模型中的执行效果如下所示：
![[z-oblib/z2-attachments/没有正确同步.png]]
操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的每个操作必须立即对任意线程可见。
但是[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]没有这样的保证： 比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</description></item></channel></rss>