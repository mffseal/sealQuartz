<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>todo on</title><link>https://mffseal.top/tags/todo/</link><description>Recent content in todo on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://mffseal.top/tags/todo/index.xml" rel="self" type="application/rss+xml"/><item><title>快速排序</title><link>https://mffseal.top/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mffseal.top/3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快速排序 快速排序是 [[3-计算机科学/0-数据结构与算法/冒泡排序|冒泡排序]] 的改进版本。
快排的每一轮都是讲一个基数归为，所以外层要循环 n 次： ![[z-oblib/z2-attachments/3.9-1.png]]
时间复杂度 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。 每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。 这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。 当然在最坏的情况下，仍可能是相邻的两个数进行了交换。 因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(N2)，它的平均时间复杂度为 O(NlogN)。 其实快速排序是基于一种叫做“二分”的思想。
实现 双指针版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 快速排序 public void quickSort(int left, int right) { // 子集只有一个元素旧没必要继续切分快排了 int lens = right - left + 1; if (lens&amp;lt;2) return; int base = num[left]; // 取区间第一个元素作base值 int curLeft = left; // 记录当前左区间下标，用于递归 int curRight = right; // 记录当前右区间下标，用于递归 boolean leftReady = false, rightReady = false; // 标志是否找到需要交换的数 while (left!</description></item></channel></rss>