<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>article on</title><link>https://harbor.mffseal.top/tags/article/</link><description>Recent content in article on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://harbor.mffseal.top/tags/article/index.xml" rel="self" type="application/rss+xml"/><item><title>AbstractDispatcherServletInitializer 的实现类为什么可以在初始化 Web 容器的时候被调用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</guid><description>AbstractDispatcherServletInitializer 的实现类为什么可以在初始化 Web 容器的时候被调用 (33条消息) AbstractDispatcherServletInitializer 的实现类为什么可以在初始化Web容器的时候被调用_Nishkata的博客-CSDN博客
Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析_Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析|Samuel个人博客 (yangshuaibin.com)
Servlet 做的事 Servlet3.0 环境中，容器会在类路径中查找实现 ServletContainerInitializer 接口的类，如果发现的话，就用它来配置 Servlet 容器。</description></item><item><title>hugo启用最后修改日期</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</guid><description>hugo启用最后修改日期 读取笔记yaml信息 修改模板：
1 updated:填入日期 设置配置文件： 如果是yaml文件：
1 2 frontmatter:lastmod:[&amp;#34;:lastmod&amp;#34;,&amp;#34;updated&amp;#34;] 如果是toml文件：
1 2 [frontmatter] lastmod = [&amp;#34;:lastmod&amp;#34;, &amp;#34;updated&amp;#34;] 配置文件中第二个字段与yaml中定义的字段一致即可。</description></item><item><title>Obsidian配置webdav远程同步服务器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>Obsidian配置webdav远程同步服务器 准备 obsidian软件 obsidian remotely save插件 vps服务器 （ubuntu2004） 安装并配置nginx服务器 安装nginx及webdav插件 1 2 sudo apt sudo apt -y install nginx nginx-extras libnginx-mod-http-dav-ext libnginx-mod-http-auth-pam 创建nginx配置文件 1 vim /etc/nginx/conf.</description></item><item><title>OJ常用代码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>OJ常用代码 进制转换 任意进制转 10 进制 对于一个 p 进制的 n 位数 y 来说, 其每一位$a_n$的关系是 $$ y = a_1 \times p^{n-1} + n_2 \times p^{n-2} + &amp;hellip; + a_{n-1} \times p^1 + a_n \times p^0 $$</description></item><item><title>Python中16进制与字符串转换</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid><description>Python中16进制与字符串转换 python3 中的字符串和编码 在最新的 Python 3 版本中，字符串是以 Unicode 编码的 Python 的字符串类型是str 在内存中以Unicode表示，一个字符对应若干个字节 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的 bytes 1 注意区分`&amp;#39;ABC&amp;#39;`和`b&amp;#39;ABC&amp;#39;`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。 hex() hex() 函数用于将10进制整数转换成16进制，以字符串形式表示 1 注意!</description></item><item><title>Python网络爬虫入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</guid><description>Python网络爬虫入门 爬虫简介 合法性 抓取数据时现实生活中真实数据则合法 抓取数据为原创数据则受版权保护 背景调研 检查 robots.txt 检查 robots.txt 可以最小化爬虫被封禁的可能 发现和网络结构相关的线索 查看方法 通过访问 http://example.webscraping.com/robots.txt, 得到内容:</description></item><item><title>ubuntu环境配置</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>ubuntu环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 # apt换源 sudo cp -a /etc/apt/sources.</description></item><item><title>内存模型总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid><description>内存模型总结 重点设计到[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]中：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 由 JVM 缓存优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/有序性|有序性]] - 由 JVM [[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/指令重排序|指令重排序]]优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/happens-before|happens-before]] 规则 原理方面 CPU 指令[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/并行|并行]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 模式方面 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]]模式的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 改进 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]模式之 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|balking]]</description></item><item><title>双层not_exists嵌套</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</guid><description>双层not_exists嵌套 SQL 中的 EXISTS 到底做了什么？ - 知乎 (zhihu.com) SQL 双层 not exist 嵌套
WHERE 做了什么 1 2 3 SELECTSno,SnameFROMStudentWHERESdept=&amp;#39;IS&amp;#39; DBMS 会扫描 表中的每一条记录 判断后面的逻辑表达式的值是否为 True 如果为 True，则将当前这条记录放到结果集里面去 如果逻辑表达式的值为 False 则不放 相关子查询 查询每个学生超过其选修的所有课程的平均成绩的课程的课程号:</description></item><item><title>寄存器，test，cmp剖析</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</guid><description>寄存器，test，cmp剖析 状态寄存器 首先复习一下状态寄存器.
PSW(Program Status Word)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,如下所示：
![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/汇编/z-attachments/Pasted image 20220917161214.png]]
条件码：
OF(Overflow Flag)溢出标志 溢出时为1，否则置0 标明一个溢出了的计算 SF(Sign Flag)符号标志 结果为负时置1，否则置0 ZF(Zero Flag)零标志, 运算结果为0时置1，否则置0 CF(Carry Flag)进位标志 进位时置1，否则置0 注意:Carry标志中存放计算后最右的位 AF(Auxiliary carry Flag)辅助进位标志 记录运算时第3位(半个字节)产生的进位置 有进位时1,否则置0。 PF(Parity Flag)奇偶标志 结果操作数中1的个数为偶数时置1，否则置0 控制标志位：</description></item><item><title>无锁小结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</guid><description>无锁小结 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS与volatile|CAS与volatile]] API [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子整数|原子整数]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子引用|原子引用]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子数组|原子数组]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/字段更新器|字段更新器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子累加器|原子累加器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Unsafe|Unsafe]] 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/LongAdder|LongAdder]] 源码 伪共享</description></item><item><title>汇编快速入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>汇编快速入门 寄存器 CS : IP 物理地址 = 段地址 X 10H + 偏移地址 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H 同一个物理地址可以由不同的段地址和偏移地址构成 段寄存器 CS: 代码段寄存器 (Code Segment) 主要关注此寄存器 DS: 数据段寄存器 (Data Segment) SS: 栈段寄存器 (Stach Segment) ES: 附加段寄存器 (Extra Segment) 程序执行 任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:</description></item><item><title>管程总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</guid><description>管程总结 悲观锁
需要重点掌握的是
分析多[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]访问共享资源时，哪些代码片段属于[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]] 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 互斥解决临界区的线程安全问题 掌握 synchronized 锁对象语法 掌握 synchronzied 加载成员方法和静态方法语法 掌握 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|wait&amp;amp;notify]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]方法 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/ReentrantLock|lock]] 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]性、掌握常见[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程安全类|线程安全类]]的使用 了解线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活跃性|活跃性]]问题：[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]] 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait&amp;amp;notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]、synchronized 、wait&amp;amp;notify 原理 synchronized 进阶原理 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/park&amp;amp;unpark|park&amp;amp;unpark]] 原理 模式方面 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/异步|异步]]模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/顺序控制|顺序控制]]</description></item><item><title>线程安全集合类概述</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</guid><description>线程安全集合类概述 ![[z-oblib/z2-attachments/Pasted image 20220612211057.png]]</description></item><item><title>继承和委派的选择</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</guid><description>继承和委派的选择 想要表达 is-a 关系，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]。 想要将类传递给已有的API，使用继承。 想要增强A，但A不能再被[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。 想要某方法并且不想覆盖该方法，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。</description></item><item><title>进程间通讯</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</guid><description>进程间通讯 单机操作系统上的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]可以分为两类：
独立进程：这类进程不会和其它进程有任何交[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/流|流]]。 协作进程：两个或多个进程之间需要交流。 例如，ls /tmp命令是独立运行的，不依赖于其它进程，而cat a.log | grep 'abc'命令中的两个进程是协作进程，grep进程依赖于cat进程，grep只有等待到了cat进程产生的数据才能继续执行下去。
对于单机上不同进程之间的协作，各进程之间需要进行数据的交流，这种行为称为进程间通信（Inter-process communication，IPC），即进程与进程的通信。
除了单机上的多个进程可能需要进程间通信，多计算机之间的进程有时候也需要进行进程间的通信，这很常见，例如本机上的QQ客户端进程需要和腾讯的QQ服务器上的进程进行数据传输，浏览器浏览网页时，浏览器进程需要和网页所在的服务端进程进行数据传输，等等。
进程间通信的方式有很多种。从广义上讲，只要进程间能共享数据或传递数据就算是进程间通信。下面列出常见的进程间通信方式：
进程间通信方式 描述 文件（File） 多个进程可以获取到同一个文件的数据 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/管道 | 管道]]（pipe） 单方向传输数据的管道，只能一方写，另一方读 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/套接字|套接字]]（Socket） 多机进程间通信，当然也可以在本机让两个进程使用socket通信 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/Unix域套接字|Unix域套接字]]（Unix Domain Socket） 单机进程间通过域套接字模式通信，可看作是双向管道 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/共享内存|共享内存]]（Shared Memory，shm） 在物理内存上划分一片内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件映射|文件映射]]（Memory-maped file） 将文件中的一段数据映射到物理内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/消息队列|消息队列]]（Message Queue） 某进程将消息放入消息队列，其它进程从队列中接收消息 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号|信号]]（Signal） 通过发送某些信号通知其它进程，进程收到信号做出不同的处理 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号量|信号量]]（Semaphore） 就是信号灯。应用方式有多种，其作用概括起来就是，根据是否有信号灯或信号灯的数量多少来决定是否阻塞进程 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/锁|锁]]（Lock） 对资源上锁，如果资源已被某进程锁住，则其它进程想要修改甚至读取这些资源，都将被阻塞，直到锁被打开。</description></item><item><title>逆向wp-Easy-CrackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</guid><description>逆向wp-Easy-CrackMe 题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 windows 窗体程序 没什么输入限制 错误返回字符串 Incorrect Password ![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214007.png]]
反编译 程序是 32 位的.
定位关键函数 通过字符串 Incorrect Password 定位关键函数, F5 分析 C 代码.</description></item><item><title>逆向wp-Easy-Keygen</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</guid><description>逆向wp-Easy-Keygen 基础的异或加密题.
http://gokoucat.ys168.com/
题目要求 Find the Name when the Serial is 5B134977135E7D13
黑盒测试 简单运行一下程序, 发现是 Windows 下的命令行程序, 要求输入 name 和 serial, 程序判断是否正确, 错误直接跳出.</description></item><item><title>逆向wp-Easy-Re</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</guid><description>逆向wp-Easy-Re bugku 逆向第二题.
定位关键函数 通过 ida 反编译, 很容易定位关键函数, 本题结构十分简单:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;amp;v5, _mm_loadu_si128((const __m128i *)&amp;amp;xmmword_413E34)); // &amp;amp;xmmword_413E34 即被比较数据 flag v7 = 0; v6 = qword_413E44; v8 = 0; printf(&amp;#34;欢迎来到DUTCTF呦\n&amp;#34;); printf(&amp;#34;这是一道很可爱很简单的逆向题呦\n&amp;#34;); printf(&amp;#34;输入flag吧:&amp;#34;); scanf(&amp;#34;%s&amp;#34;, &amp;amp;v9); v3 = strcmp((const char *)&amp;amp;v5, &amp;amp;v9); // 将输入与已有数据进行比较, if ( v3 ) v3 = -(v3 &amp;lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;amp;unk_413E90); system(&amp;#34;pause&amp;#34;); return 0; } 解析字符串 对 &amp;amp;xmmword_413E34 位置的数据进行分析, 发现此处就是 flag 的逆序存储, 直接右键显示为 字符, 然后手工反向输入即可.</description></item><item><title>逆向wp-Easy-UnpackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</guid><description>逆向wp-Easy-UnpackMe 脱壳入门题, 找程序 EOP (入口点).
题目在网络对应目录中: http://gokoucat.ys168.com/
题目要求 Find the OEP, ex) 00401000
黑盒测试 双击打开, 是一个空白的 Windows 窗体程序, 没什么特别的.
OD 调试 通过使用 OD 动态调试, 寻找程序的 EOP, 使用的方法是单步跟踪.</description></item><item><title>逆向wp-ebCTF-Teaser-BIN100-Dice</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</guid><description>逆向wp-ebCTF-Teaser-BIN100-Dice 杭电 CTF 平台逆向第一题.
http://gokoucat.ys168.com/
定位关键函数 使用 IDA 字符串搜索 定位回显字符串被交叉引用的位置 得到关键函数中的重要片段如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { .</description></item><item><title>逆向wp-keylead</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</guid><description>逆向wp-keylead 杭电 CTF 平台逆向第二题.
题目在网络对应目录中: http://gokoucat.ys168.com/
文件分析 通过在 lunux 环境下, 使用 file keylead 发现是一个压缩文件, 解压后得到可执行文件.
1 2 3 file keylead keylead: XZ compressed data 函数分析 通过字符串定位的方法, 找到主函数.</description></item><item><title>逆向wp-Reverse-100</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</guid><description>逆向wp-Reverse-100 杭电 CTF 平台逆向第四题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位关键函数 老套路, string 查找, 不多 BB.
解析函数 这个函数比较简单, key 和 判断流程在一个简单的函数中直接展示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __cdecl main(int argc, const char **argv, const char **envp) { signed int i; // edi char s_input; // [esp+10h] [ebp-104h] char Dst; // [esp+11h] [ebp-103h] s_input = 0; memset(&amp;amp;Dst, 0, 0xFFu); printf(&amp;#34;please input ns-ctf password: &amp;#34;); scanf_s(&amp;#34;%s&amp;#34;, &amp;amp;s_input); for ( i = 1; strncmp(&amp;#34;nsF0cuS!</description></item><item><title>逆向wp-reverse02</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</guid><description>逆向wp-reverse02 杭电 CTF 平台逆向第三题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位函数 程序时一个 win32 的窗口程序, 按钮是灰色的.
老套路, 根据字符串来定位函数.
这题可以找到一个内容是 flag:{NSCTF_md57e0cad17016b0&amp;gt;?45?f7c&amp;gt;0&amp;gt;4a&amp;gt;1c3a0} 的字符串, 直接提交错误, 看来没这么简单.
交叉引用 对该字符串的交叉引用有两处, 分别分析发现其中一个应该为主要的函数:</description></item><item><title>逆向wp-WannaLOL2</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</guid><description>逆向wp-WannaLOL2 逆向入门题.
题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 拿到题目第一步, 就是运行软件进行测试
判断软件平台 观察输入限制 观察输出信息 本题是一道 Windows 平台下的窗体程序, 任意输入内容进行测试:
![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215724.png]]
随意输入后, 发现程序对输入的内容和长度没有做限制, 输入不通过时返回字符串 error !</description></item><item><title>逆向wp-游戏过关</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</guid><description>逆向wp-游戏过关 bugku 逆向第三题.
http://gokoucat.ys168.com/
定位关键函数 通过对字符串 done!!! the flag is 进行交叉引用的定位, 找到关键函数的位置.
1 2 3 4 5 6 7 8 9 10 11 12 .</description></item><item><title>针对延迟绑定的攻击</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>针对延迟绑定的攻击  2015 年的论文 “How the [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|ELF]] Ruined Christmas” 中提出的。
强迫动态装载器解析请求的函数。
![[z-oblib/z2-attachments/Pasted image 20220911020331.png]] ![[z-oblib/z2-attachments/Pasted image 20220911020936.png]]
图a中，因为动态转载器是从 .</description></item><item><title>锁存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>锁存器 我们将能够存储一个状态的电路叫做锁存器。设想一个电路，初始输入为0，输出为0；然后输入为1，输出变为1（状态发生了变化）。对于迄今为止所有的电路，我们都能保证当输入回到0时，输出也会同时归0；但这个电路不同，它保持在了1，也就是状态没有发生变化，而是被存储了下来。此时，这种电路便可以被叫做锁存器。
为了让电路拥有自己的”状态“，必须要有某种”反馈“机制，将输出输入形成一个闭环。
分类 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/RS锁存器|RS锁存器]]</description></item></channel></rss>