<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>article on</title><link>https://harbor.mffseal.top/tags/article/</link><description>Recent content in article on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://harbor.mffseal.top/tags/article/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/gcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/gcc%E7%BC%96%E8%AF%91%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</guid><description>gcc编译动态链接库 gcc -shared -fPIC xxx.c -o libxxx.so
-shared告诉gcc我正在编译一个dll而不是一个可执行文件，不要去找main函数等生成入口点。 -fPIC 表示生成地址无关代码，实际上是</description></item><item><title/><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid><description>Linux线程同步 mutex锁 条件变量 信号量</description></item><item><title>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</guid><description>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用 (33条消息) AbstractDispatcherServletInitializer 的实现类为什么可以在初始化Web容器的时候被调用_Nishkata的博客-CSDN博客
Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析_Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析|Samuel个人博客 (yangshuaibin.com)
Servlet 做的事 Servlet3.0 环境中，容器会在类路径中查找实现 ServletContainerInitializer 接口的类，如果发现的话，就用它来配置 Servlet 容器。</description></item><item><title>ARM的37个寄存器和异常处理机制</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/ARM%E7%9A%8437%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/arm/ARM%E7%9A%8437%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</guid><description>ARM的37个寄存器和异常处理机制 参考 (1条消息) ARM的37个寄存器和异常处理机制详解_正在起飞的蜗牛的博客-CSDN博客</description></item><item><title>CAS实现原子操作的三大问题</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</guid><description>CAS实现原子操作的三大问题 ABA问题 所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS|CAS]]是检查不出变化的，但实际上却被更新了两次。
ABA问题的解决思路是在变量前面追加上版本号或者时间戳。从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。
这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。
1 2 3 4 5 6 7 8 9 10 11 12 public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair&amp;lt;V&amp;gt; current = pair; return expectedReference == current.</description></item><item><title>hugo启用最后修改日期</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</guid><description>hugo启用最后修改日期 读取笔记yaml信息 修改模板：
1 updated:填入日期 设置配置文件： 如果是yaml文件：
1 2 frontmatter:lastmod:[&amp;#34;:lastmod&amp;#34;,&amp;#34;updated&amp;#34;] 如果是toml文件：
1 2 [frontmatter] lastmod = [&amp;#34;:lastmod&amp;#34;, &amp;#34;updated&amp;#34;] 配置文件中第二个字段与yaml中定义的字段一致即可。</description></item><item><title>Linux进程间通讯</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</guid><description>Linux进程间通讯 想要进行进程间通讯，需要借助内核空间。 ![[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/z-attachments/Pasted image 20221005230322.png]]
单机操作系统上的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]可以分为两类：
独立进程：这类进程不会和其它进程有任何交[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/流|流]]。 协作进程：两个或多个进程之间需要交流。 例如，ls /tmp命令是独立运行的，不依赖于其它进程，而cat a.log | grep 'abc'命令中的两个进程是协作进程，grep进程依赖于cat进程，grep只有等待到了cat进程产生的数据才能继续执行下去。
对于单机上不同进程之间的协作，各进程之间需要进行数据的交流，这种行为称为进程间通信（Inter-process communication，IPC），即进程与进程的通信。
除了单机上的多个进程可能需要进程间通信，多计算机之间的进程有时候也需要进行进程间的通信，这很常见，例如本机上的QQ客户端进程需要和腾讯的QQ服务器上的进程进行数据传输，浏览器浏览网页时，浏览器进程需要和网页所在的服务端进程进行数据传输，等等。
进程间通信的方式有很多种。从广义上讲，只要进程间能共享数据或传递数据就算是进程间通信。下面列出常见的进程间通信方式：</description></item><item><title>Netty优化与源码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</guid><description>Netty优化与源码 1. 优化 1.1 扩展序列化算法 序列化，反序列化主要用在消息正文的转换上
序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]） 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理 目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</description></item><item><title>Netty入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E5%85%A5%E9%97%A8/</guid><description>Netty入门 1. 概述 1.1 Netty 是什么？ 1 2 Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.</description></item><item><title>Netty进阶</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E8%BF%9B%E9%98%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Netty/Netty%E8%BF%9B%E9%98%B6/</guid><description>Netty进阶 1. 粘包与半包 1.1 粘包现象 服务端代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class HelloWorldServer { static final Logger log = LoggerFactory.</description></item><item><title>Obsidian配置webdav远程同步服务器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>Obsidian配置webdav远程同步服务器 准备 obsidian软件 obsidian remotely save插件 vps服务器 （ubuntu2004） 安装并配置nginx服务器 安装nginx及webdav插件 1 2 sudo apt sudo apt -y install nginx nginx-extras libnginx-mod-http-dav-ext libnginx-mod-http-auth-pam 创建nginx配置文件 1 vim /etc/nginx/conf.</description></item><item><title>OJ常用代码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>OJ常用代码 进制转换 任意进制转 10 进制 对于一个 p 进制的 n 位数 y 来说, 其每一位$a_n$的关系是 $$ y = a_1 \times p^{n-1} + n_2 \times p^{n-2} + &amp;hellip; + a_{n-1} \times p^1 + a_n \times p^0 $$</description></item><item><title>PKI</title><link>https://harbor.mffseal.top/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/PKI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_0-%E6%95%B0%E5%AD%A6/2_0_0_2-%E5%AF%86%E7%A0%81%E5%AD%A6/PKI/</guid><description>PKI Public Key Infrastructure，公钥基础设施。
组成 一个PKI体系由终端实体、证书认证机构、证书注册机构和证书/[[2_0_0-数学/2_0_0_2-密码学/CRL|CRL]]存储库四部分共同组成。
证书颁发机构（[[2_0_0-数学/2_0_0_2-密码学/CA|CA]]） 证书注册机构（[[2_0_0-数学/2_0_0_2-密码学/RA|RA]]) 证书库 密钥备份及恢复系统 证书废除处理系统 应用系统接口 [[2_0_0-数学/2_0_0_2-密码学/数字证书|数字证书]] 重要角色 终端实体（EE, End Entity）: 证书的最终使用者，例如总部和分支的网关。 证书颁发机构（CA， Certificate Authority）：是一个权威的、可信的第三方机构，负载[[2_0_0-数学/2_0_0_2-密码学/证书颁发|证书颁发]]、查询以及更新等工作。 证书注册机构（RA）</description></item><item><title>Python中16进制与字符串转换</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid><description>Python中16进制与字符串转换 python3 中的字符串和编码 在最新的 Python 3 版本中，字符串是以 Unicode 编码的 Python 的字符串类型是str 在内存中以Unicode表示，一个字符对应若干个字节 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的 bytes 1 注意区分`&amp;#39;ABC&amp;#39;`和`b&amp;#39;ABC&amp;#39;`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。 hex() hex() 函数用于将10进制整数转换成16进制，以字符串形式表示 1 注意!</description></item><item><title>Python引用传递和值传递</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/</guid><description>Python引用传递和值传递 解释器会查看对象引用（内存地址）指示的那个值的类型，如果变量指示一个可变的值，就会按引用调用语义。如果所指示的数据的类型是不可变的，则会应用按值调用语义。
列表 字典 集合
总是会按引用传入函数，函数代码组中对变量数据结构的任何改变都会反映到调用代码中。
字符串 整数 元组
总是会按值传入函数，函数中对变量的任何修改是这个函数私有的，不会反映到调用代码中。</description></item><item><title>Python网络爬虫入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</guid><description>Python网络爬虫入门 爬虫简介 合法性 抓取数据时现实生活中真实数据则合法 抓取数据为原创数据则受版权保护 背景调研 检查 robots.txt 检查 robots.txt 可以最小化爬虫被封禁的可能 发现和网络结构相关的线索 查看方法 通过访问 http://example.webscraping.com/robots.txt, 得到内容:</description></item><item><title>Python装饰器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid><description>Python装饰器 简述 装饰器是闭包的语法糖 装饰器就是在目标函数&amp;quot;周围&amp;quot;加上附加的代码 一般如插入日志、性能测试、事务处理、缓存、权限校验等场景 装饰器是面向切面编程的设计思想 简单装饰器 目标函数 1 2 def foo(): print(&amp;#39;i am foo&amp;#39;) 额外代码 打印log:</description></item><item><title>qemu运行mips程序</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu%E8%BF%90%E8%A1%8Cmips%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/qemu%E8%BF%90%E8%A1%8Cmips%E7%A8%8B%E5%BA%8F/</guid><description>qemu运行mips程序 [[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/IoT安全/安装qemu|安装qemu]] 拷贝[[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/IoT安全/qemu-user-static|qemu-user-static]]到目标目录下：cp /usr/bin/qemu-mips-static ./。 运行mips程序(其中./bin/busybox为要执行的busybox)：sudo chroot . ./qemu-mips-static ./bin/busybox。</description></item><item><title>ubuntu2004下安装物联网固件分析工具包</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/ubuntu2004%E4%B8%8B%E5%AE%89%E8%A3%85%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8C%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IoT%E5%AE%89%E5%85%A8/ubuntu2004%E4%B8%8B%E5%AE%89%E8%A3%85%E7%89%A9%E8%81%94%E7%BD%91%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%8C%85/</guid><description>ubuntu2004下安装物联网固件分析工具包 基础环境 系统：ubuntu2004 64位。 代理工具：proxychains4。 宿主机网络加速软件开放端口用于给虚拟机代理。
安装流程 安装代理工具：sudo apt install proxychains4。 配置代理：sudo vim /etc/proxychains4.conf，将最后的代理服务器地址换成socks5 宿主机Ip 代理端口 克隆自动化分析工具包脚本项目：git clone --recursive https://github.</description></item><item><title>ubuntu环境配置</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>ubuntu环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # apt换源 sudo cp -a /etc/apt/sources.</description></item><item><title>x86汇编快速入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>x86汇编快速入门 寄存器 CS : IP 物理地址 = 段地址 X 10H + 偏移地址 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H 同一个物理地址可以由不同的段地址和偏移地址构成 段寄存器 CS: 代码段寄存器 (Code Segment) 主要关注此寄存器 DS: 数据段寄存器 (Data Segment) SS: 栈段寄存器 (Stach Segment) ES: 附加段寄存器 (Extra Segment) 程序执行 任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:</description></item><item><title>一. NIO 基础</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/NIO/NIO%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/NIO/NIO%E5%9F%BA%E7%A1%80/</guid><description>一. NIO 基础 non-blocking io 非阻塞 IO
1. 三大组件 1.1 Channel &amp;amp; Buffer channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</description></item><item><title>内存地址在不同场景下的花式叫法</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%8F%AB%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%8F%AB%E6%B3%95/</guid><description>内存地址在不同场景下的花式叫法 指针 &amp;ndash; c/c++语言等 句柄 &amp;ndash; c/c++下就是一个对象的地址 向量 &amp;ndash; 如中断向量，是指向中断号对应中断处理程序的地址</description></item><item><title>内存模型总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid><description>内存模型总结 重点设计到[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]中：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 由 JVM 缓存优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/有序性|有序性]] - 由 JVM [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/指令重排序|指令重排序]]优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/happens-before|happens-before]] 规则 原理方面 CPU 指令[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/并行|并行]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 模式方面 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]]模式的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 改进 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]模式之 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|balking]]</description></item><item><title>分页与分段的区别</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>分页与分段的区别 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/分页|分页]] VS [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/分段|分段]]
分页 分段 在分页中，进程的地址空间被划分为固定大小的页面 在分段中，进程的地址空间被划分为大小不同的段 操作系统负责分页 编译器负责分段 页大小由硬件决定 段大小由用户给出 速度比分段块 分段速度慢 分页会导致内部碎片 分段导致外部碎片 分页中，逻辑地址被划分为页号和页偏移 分段中，逻辑地址被划分为段号和段偏移 分页包含一个页表，页表包含每个页的基地址 分段包含段表，段表中包含段号和段偏移量 分页对于用户不可见 分段对于用户可见 在分页中，处理器需要页号和页偏移来计算实际物理地址 分段中，处理器使用段号和段偏移量计算地址</description></item><item><title>双层not_exists嵌套</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</guid><description>双层not_exists嵌套 SQL 中的 EXISTS 到底做了什么？ - 知乎 (zhihu.com) SQL 双层 not exist 嵌套
WHERE 做了什么 1 2 3 SELECTSno,SnameFROMStudentWHERESdept=&amp;#39;IS&amp;#39; DBMS 会扫描 表中的每一条记录 判断后面的逻辑表达式的值是否为 True 如果为 True，则将当前这条记录放到结果集里面去 如果逻辑表达式的值为 False 则不放 相关子查询 查询每个学生超过其选修的所有课程的平均成绩的课程的课程号:</description></item><item><title>多级页表提高内存使用效率的原理</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87%E7%9A%84%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87%E7%9A%84%E5%8E%9F%E7%90%86/</guid><description>多级页表提高内存使用效率的原理 提高寻址效率 不分页： 16 均分两页：16 &amp;ndash;&amp;gt; 8+8，8 * 8 = 64； 以此类推&amp;hellip;
假设两级[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/分页|分页]]，一级用于定位在第几个二级[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/页表|页表]]，每个二级页表又能定位某一块内存空间，即 8**=64；
提高空间效率 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]的地址空间很少有完全映射的情况。正是因为省却了大量未映射的页表项使得页表的空间大幅减少。
![[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/z-attachments/Pasted image 20220923203858.png]]
参考 页表是啥以及为啥多级页表能够节省空间_wx61307a0120efd的技术博客_51CTO博客</description></item><item><title>寄存器，test，cmp剖析</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/x86/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</guid><description>寄存器，test，cmp剖析 状态寄存器 首先复习一下状态寄存器.
PSW(Program Status Word)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,如下所示：
![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/汇编/z-attachments/Pasted image 20220917161214.png]]
条件码：
OF(Overflow Flag)溢出标志 溢出时为1，否则置0 标明一个溢出了的计算 SF(Sign Flag)符号标志 结果为负时置1，否则置0 ZF(Zero Flag)零标志, 运算结果为0时置1，否则置0 CF(Carry Flag)进位标志 进位时置1，否则置0 注意:Carry标志中存放计算后最右的位 AF(Auxiliary carry Flag)辅助进位标志 记录运算时第3位(半个字节)产生的进位置 有进位时1,否则置0。 PF(Parity Flag)奇偶标志 结果操作数中1的个数为偶数时置1，否则置0 控制标志位：</description></item><item><title>无锁小结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</guid><description>无锁小结 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS与volatile|CAS与volatile]] API [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子整数|原子整数]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子引用|原子引用]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子数组|原子数组]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/字段更新器|字段更新器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子累加器|原子累加器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Unsafe|Unsafe]] 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/LongAdder|LongAdder]] 源码 伪共享</description></item><item><title>段页式内存管理</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>段页式内存管理 结合了[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/分段|分段]]和[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/分页|分页]]的优点：
将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。
![[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/z-attachments/Pasted image 20220923210822.png]]
实现 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量： ![[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/z-attachments/Pasted image 20220923210848.png]] 通过在哪一段的那一页的偏移多少来定位内存位置。
系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）。系统中还应有一个段寄存器，指出作业的段表起始地址和段表长度。
地址变换 首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。 ![[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/z-attachments/Pasted image 20220923212952.png]]
参考 (1条消息) 段页式内存管理_~青萍之末~的博客-CSDN博客_段页式内存管理</description></item><item><title>管程总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</guid><description>管程总结 悲观锁
需要重点掌握的是
分析多[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]访问共享资源时，哪些代码片段属于[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]] 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 互斥解决临界区的线程安全问题 掌握 synchronized 锁对象语法 掌握 synchronzied 加载成员方法和静态方法语法 掌握 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|wait&amp;amp;notify]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]方法 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/ReentrantLock|lock]] 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]性、掌握常见[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程安全类|线程安全类]]的使用 了解线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活跃性|活跃性]]问题：[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]] 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait&amp;amp;notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]、synchronized 、wait&amp;amp;notify 原理 synchronized 进阶原理 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/park&amp;amp;unpark|park&amp;amp;unpark]] 原理 模式方面 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/异步|异步]]模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/顺序控制|顺序控制]]</description></item><item><title>线程安全集合类概述</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</guid><description>线程安全集合类概述 ![[z-oblib/z2-attachments/Pasted image 20220612211057.png]]</description></item><item><title>继承和委派的选择</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</guid><description>继承和委派的选择 想要表达 is-a 关系，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]。 想要将类传递给已有的API，使用继承。 想要增强A，但A不能再被[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。 想要某方法并且不想覆盖该方法，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。</description></item><item><title>设计模式总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</guid><description>设计模式总结 模式 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/装饰器模式|装饰器模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/模板模式|模板模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/单例模式|单例模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工厂模式|工厂模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/享元模式|享元模式]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 工具 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|Balking]] [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/工作线程|工作线程]]</description></item><item><title>逆向wp-Easy-CrackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</guid><description>逆向wp-Easy-CrackMe 题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 windows 窗体程序 没什么输入限制 错误返回字符串 Incorrect Password ![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214007.png]]
反编译 程序是 32 位的.
定位关键函数 通过字符串 Incorrect Password 定位关键函数, F5 分析 C 代码.</description></item><item><title>逆向wp-Easy-Keygen</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</guid><description>逆向wp-Easy-Keygen 基础的异或加密题.
http://gokoucat.ys168.com/
题目要求 Find the Name when the Serial is 5B134977135E7D13
黑盒测试 简单运行一下程序, 发现是 Windows 下的命令行程序, 要求输入 name 和 serial, 程序判断是否正确, 错误直接跳出.</description></item><item><title>逆向wp-Easy-Re</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</guid><description>逆向wp-Easy-Re bugku 逆向第二题.
定位关键函数 通过 ida 反编译, 很容易定位关键函数, 本题结构十分简单:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;amp;v5, _mm_loadu_si128((const __m128i *)&amp;amp;xmmword_413E34)); // &amp;amp;xmmword_413E34 即被比较数据 flag v7 = 0; v6 = qword_413E44; v8 = 0; printf(&amp;#34;欢迎来到DUTCTF呦\n&amp;#34;); printf(&amp;#34;这是一道很可爱很简单的逆向题呦\n&amp;#34;); printf(&amp;#34;输入flag吧:&amp;#34;); scanf(&amp;#34;%s&amp;#34;, &amp;amp;v9); v3 = strcmp((const char *)&amp;amp;v5, &amp;amp;v9); // 将输入与已有数据进行比较, if ( v3 ) v3 = -(v3 &amp;lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;amp;unk_413E90); system(&amp;#34;pause&amp;#34;); return 0; } 解析字符串 对 &amp;amp;xmmword_413E34 位置的数据进行分析, 发现此处就是 flag 的逆序存储, 直接右键显示为 字符, 然后手工反向输入即可.</description></item><item><title>逆向wp-Easy-UnpackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</guid><description>逆向wp-Easy-UnpackMe 脱壳入门题, 找程序 EOP (入口点).
题目在网络对应目录中: http://gokoucat.ys168.com/
题目要求 Find the OEP, ex) 00401000
黑盒测试 双击打开, 是一个空白的 Windows 窗体程序, 没什么特别的.
OD 调试 通过使用 OD 动态调试, 寻找程序的 EOP, 使用的方法是单步跟踪.</description></item><item><title>逆向wp-ebCTF-Teaser-BIN100-Dice</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</guid><description>逆向wp-ebCTF-Teaser-BIN100-Dice 杭电 CTF 平台逆向第一题.
http://gokoucat.ys168.com/
定位关键函数 使用 IDA 字符串搜索 定位回显字符串被交叉引用的位置 得到关键函数中的重要片段如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { .</description></item><item><title>逆向wp-keylead</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</guid><description>逆向wp-keylead 杭电 CTF 平台逆向第二题.
题目在网络对应目录中: http://gokoucat.ys168.com/
文件分析 通过在 lunux 环境下, 使用 file keylead 发现是一个压缩文件, 解压后得到可执行文件.
1 2 3 file keylead keylead: XZ compressed data 函数分析 通过字符串定位的方法, 找到主函数.</description></item><item><title>逆向wp-Reverse-100</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</guid><description>逆向wp-Reverse-100 杭电 CTF 平台逆向第四题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位关键函数 老套路, string 查找, 不多 BB.
解析函数 这个函数比较简单, key 和 判断流程在一个简单的函数中直接展示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __cdecl main(int argc, const char **argv, const char **envp) { signed int i; // edi char s_input; // [esp+10h] [ebp-104h] char Dst; // [esp+11h] [ebp-103h] s_input = 0; memset(&amp;amp;Dst, 0, 0xFFu); printf(&amp;#34;please input ns-ctf password: &amp;#34;); scanf_s(&amp;#34;%s&amp;#34;, &amp;amp;s_input); for ( i = 1; strncmp(&amp;#34;nsF0cuS!</description></item><item><title>逆向wp-reverse02</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</guid><description>逆向wp-reverse02 杭电 CTF 平台逆向第三题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位函数 程序时一个 win32 的窗口程序, 按钮是灰色的.
老套路, 根据字符串来定位函数.
这题可以找到一个内容是 flag:{NSCTF_md57e0cad17016b0&amp;gt;?45?f7c&amp;gt;0&amp;gt;4a&amp;gt;1c3a0} 的字符串, 直接提交错误, 看来没这么简单.
交叉引用 对该字符串的交叉引用有两处, 分别分析发现其中一个应该为主要的函数:</description></item><item><title>逆向wp-WannaLOL2</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</guid><description>逆向wp-WannaLOL2 逆向入门题.
题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 拿到题目第一步, 就是运行软件进行测试
判断软件平台 观察输入限制 观察输出信息 本题是一道 Windows 平台下的窗体程序, 任意输入内容进行测试:
![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215724.png]]
随意输入后, 发现程序对输入的内容和长度没有做限制, 输入不通过时返回字符串 error !</description></item><item><title>逆向wp-游戏过关</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</guid><description>逆向wp-游戏过关 bugku 逆向第三题.
http://gokoucat.ys168.com/
定位关键函数 通过对字符串 done!!! the flag is 进行交叉引用的定位, 找到关键函数的位置.
1 2 3 4 5 6 7 8 9 10 11 12 .</description></item><item><title>逆向中的双字节</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%AD%97%E8%8A%82/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%AD%97%E8%8A%82/</guid><description>逆向中的双字节 数据储存类型分为 byte, word, dword 区别在于占用几个字节(byte) byte 不受大小端的影响, 因为其只有一位 word, 和 dword 受大小端的影响 一般的计算机使用的是小端序 一个2位16进制是1字节 技巧 IDA 中看到 word 16 进制显示时, 两两一组(4位16进制数)从右向左 IDA 中看到 dword 16 进制显示时, 四个一组(8位16进制数)从右向左</description></item><item><title>针对延迟绑定的攻击</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>针对延迟绑定的攻击  2015 年的论文 “How the [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|ELF]] Ruined Christmas” 中提出的。
强迫动态装载器解析请求的函数。
![[z-oblib/z2-attachments/Pasted image 20220911020331.png]] ![[z-oblib/z2-attachments/Pasted image 20220911020936.png]]
图a中，因为动态转载器是从 .</description></item><item><title>锁存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>锁存器 我们将能够存储一个状态的电路叫做锁存器。设想一个电路，初始输入为0，输出为0；然后输入为1，输出变为1（状态发生了变化）。对于迄今为止所有的电路，我们都能保证当输入回到0时，输出也会同时归0；但这个电路不同，它保持在了1，也就是状态没有发生变化，而是被存储了下来。此时，这种电路便可以被叫做锁存器。
为了让电路拥有自己的”状态“，必须要有某种”反馈“机制，将输出输入形成一个闭环。
分类 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/RS锁存器|RS锁存器]]</description></item></channel></rss>