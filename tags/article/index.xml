<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>article on</title><link>https://harbor.mffseal.top/tags/article/</link><description>Recent content in article on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://harbor.mffseal.top/tags/article/index.xml" rel="self" type="application/rss+xml"/><item><title>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_1_0-web%E5%90%8E%E7%AB%AF/Spring/AbstractDispatcherServletInitializer%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96Web%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8/</guid><description>AbstractDispatcherServletInitializer的实现类为什么可以在初始化Web容器的时候被调用 (33条消息) AbstractDispatcherServletInitializer 的实现类为什么可以在初始化Web容器的时候被调用_Nishkata的博客-CSDN博客
Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析_Spring MVC 之 AbstractAnnotationConfigDispatcherServletInitializer剖析|Samuel个人博客 (yangshuaibin.com)
Servlet做的事 Servlet3.0环境中，容器会在类路径中查找实现ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器。
SpringMvc做的事 Spring提供了这个接口的实现类 SpringServletContainerInitializer , 通过@HandlesTypes(WebApplicationInitializer.class) 设置，这个类反过来会查找实现WebApplicationInitializer 的类，并将配置的任务交给他们来完成。
AbstractAnnotationConfigDispatcherServletInitializer 类扩展了WebApplicationInitializer 。这样就可以通过实现AbstractAnnotationConfigDispatcherServletInitializer 来进行配置Servlet的上下文了。
DispatcherServletInitializer 配置类能够被加载的核心是 Java 的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/SPI|SPI]] 服务发现机制。
服务接口的定义：Servlet 规范定义了服务接口 javax-servlet-api-xxx.jar/javax.servlet.ServletContainerInitializer 注册服务接口的实现： Spring MVC 注册服务。在 spring-web-xxx.jar 包下 有 META-INF/services/javax.servlet.ServletContainerInitializer 文件，内容为 org.springframework.web.SpringServletContainerInitializer 服务加载： SpringServletContainerInitializer 中的 onStartup 方法会在 Servlet 容器初始化的时候通过 SPI 机制发现并调用，onStartup 方法里面又会 将所有 WebApplicationInitializer 的实现类的对象的 onStartup 方法全部调用一遍。 AbstractDispatcherServletInitializer 也是 WebApplicationInitializer 接口的实现，所以其 onStartup 方法也会在 Servlet 容器初始化的时候被调用。 !</description></item><item><title>hugo启用最后修改日期</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/hugo/hugo%E5%90%AF%E7%94%A8%E6%9C%80%E5%90%8E%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F/</guid><description>hugo启用最后修改日期 读取笔记yaml信息 修改模板：
1 updated:填入日期 设置配置文件： 如果是yaml文件：
1 2 frontmatter:lastmod:[&amp;#34;:lastmod&amp;#34;,&amp;#34;updated&amp;#34;] 如果是toml文件：
1 2 [frontmatter] lastmod = [&amp;#34;:lastmod&amp;#34;, &amp;#34;updated&amp;#34;] 配置文件中第二个字段与yaml中定义的字段一致即可。
读取笔记文件修改信息 设置配置文件： 如果是yaml文件：
1 2 frontmatter:lastmod:[&amp;#34;:fileModTime&amp;#34;,&amp;#34;lastmod&amp;#34;] 如果是toml文件：
1 2 [frontmatter] lastmod = [&amp;#34;:fileModTime&amp;#34;, &amp;#34;lastmod&amp;#34;]</description></item><item><title>Obsidian配置webdav远程同步服务器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_2_9_0-%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/obsidian/Obsidian%E9%85%8D%E7%BD%AEwebdav%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>Obsidian配置webdav远程同步服务器 准备 obsidian软件 obsidian remotely save插件 vps服务器 （ubuntu2004） 安装并配置nginx服务器 安装nginx及webdav插件 1 2 sudo apt sudo apt -y install nginx nginx-extras libnginx-mod-http-dav-ext libnginx-mod-http-auth-pam 创建nginx配置文件 1 vim /etc/nginx/conf.d/webdav.conf 文件内容：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 server { listen 设置一个端口; listen [::]:设置一个端口; server_name 如果有域名就配在这里; # 设置使用utf-8编码,防止中文文件名乱码 charset utf-8; # 默认存放文件的路径 root /webdav; auth_basic realm_name; # 用户密码文件存放位置 auth_basic_user_file /etc/nginx/.</description></item><item><title>OJ常用代码</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_0_2_1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/OJ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</guid><description>OJ常用代码 进制转换 任意进制转 10 进制 对于一个 p 进制的 n 位数 y 来说, 其每一位$a_n$的关系是 $$ y = a_1 \times p^{n-1} + n_2 \times p^{n-2} + &amp;hellip; + a_{n-1} \times p^1 + a_n \times p^0 $$
转换代码实现:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &amp;lt;iostream&amp;gt;using namespace std; int main(void) { int y = 0, a = 0, p = 1, result = 0; // p 初始为1, 代表p^0 cin&amp;gt;&amp;gt;y&amp;gt;&amp;gt;a; while (y!</description></item><item><title>Python中16进制与字符串转换</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E4%B8%AD16%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid><description>Python中16进制与字符串转换 python3 中的字符串和编码 在最新的 Python 3 版本中，字符串是以 Unicode 编码的 Python 的字符串类型是str 在内存中以Unicode表示，一个字符对应若干个字节 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的 bytes 1 注意区分`&amp;#39;ABC&amp;#39;`和`b&amp;#39;ABC&amp;#39;`，前者是`str`，后者虽然内容显示得和前者一样，但`bytes`的每个字符都只占用一个字节。 hex() hex() 函数用于将10进制整数转换成16进制，以字符串形式表示 1 注意! hex() 返回的结果不是整数, 而是 16 进制的字符串表示形式! 0x 表示的 16 进制数 1 2 3 4 5 a = 0xA b = 0x5 c = a * b print(a) print(c) 输出的结果:
1 2 10 50 1 两个 16 进制数相乘, 结果是以 10 进制保存的!</description></item><item><title>Python网络爬虫入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</guid><description>Python网络爬虫入门 爬虫简介 合法性 抓取数据时现实生活中真实数据则合法 抓取数据为原创数据则受版权保护 背景调研 检查 robots.txt 检查 robots.txt 可以最小化爬虫被封禁的可能 发现和网络结构相关的线索 查看方法 通过访问 http://example.webscraping.com/robots.txt, 得到内容:
1 2 3 4 5 6 7 8 9 10 11 ## section 1 User-agent: BadCrawler // 禁止用户代理为 BadCrawler 的爬虫爬取网站 Disallow: / ## section 2 User-agent: * Disallow: /trap // 封禁爬取不允许链接的爬虫 Crawl-delay: 5 // 两次请求应间隔 5 秒 ## section 3 Sitemap: http://example.webscraping.com/sitemap.xml 检查网站地图 Sitemap 文件帮助爬虫定位最新的文件, 而无需爬取每一个网页 网站地图提供了所以网页的链接 该文件经常存在缺失, 过期或不完整的问题 查看方法 通过访问 robots.</description></item><item><title>ubuntu环境配置</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/ubuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>ubuntu环境配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 # apt换源 sudo cp -a /etc/apt/sources.</description></item><item><title>内存模型总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid><description>内存模型总结 重点设计到[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/JMM|JMM]]中：
[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/可见性|可见性]] - 由 JVM 缓存优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/有序性|有序性]] - 由 JVM [[2_0_2-计算机科学/2_0_2_1_0_1-计算机组成原理/指令重排序|指令重排序]]优化引起 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/happens-before|happens-before]] 规则 原理方面 CPU 指令[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/并行|并行]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 模式方面 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/两阶段终止|两阶段终止]]模式的 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/1-高级特性/volatile|volatile]] 改进 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]模式之 [[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/Balking|balking]]</description></item><item><title>双层not_exists嵌套</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/sql/%E5%8F%8C%E5%B1%82not_exists%E5%B5%8C%E5%A5%97/</guid><description>双层not_exists嵌套 SQL 中的 EXISTS 到底做了什么？ - 知乎 (zhihu.com) SQL 双层 not exist 嵌套
WHERE 做了什么 1 2 3 SELECTSno,SnameFROMStudentWHERESdept=&amp;#39;IS&amp;#39; DBMS 会扫描 表中的每一条记录 判断后面的逻辑表达式的值是否为 True 如果为 True，则将当前这条记录放到结果集里面去 如果逻辑表达式的值为 False 则不放 相关子查询 查询每个学生超过其选修的所有课程的平均成绩的课程的课程号:
1 2 3 4 5 6 7 8 SELECTCnoFROMSCxWHEREGrade&amp;gt;=(SELECTAVG(Grade)FROMSCyWHEREy.Sno=x.Sno) 扫描父查询中数据来源（如 SC 表）中的每一条记录 将当前这条记录中的，在子查询中会用到的值(Grade)代入到子查询中去 执行子查询并得到结果（可以看成是返回值） 再将这个结果代入到父查询的条件中(Grade &amp;gt;=) 判断父查询的条件表达式的值是否为 True (WHERE 起作用) 若为 True，则将当前 SC 表中的这条记录（经过 SELECT 处理）后放到结果集中去 若为 False 则不放 (NOT) EXISTS 做了什么 若存在:</description></item><item><title>寄存器，test，cmp剖析</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8testcmp%E5%89%96%E6%9E%90/</guid><description>寄存器，test，cmp剖析 状态寄存器 首先复习一下状态寄存器.
PSW(Program Status Word)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,如下所示：
![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/汇编/z-attachments/Pasted image 20220917161214.png]]
条件码：
OF(Overflow Flag)溢出标志 溢出时为1，否则置0 标明一个溢出了的计算 SF(Sign Flag)符号标志 结果为负时置1，否则置0 ZF(Zero Flag)零标志, 运算结果为0时置1，否则置0 CF(Carry Flag)进位标志 进位时置1，否则置0 注意:Carry标志中存放计算后最右的位 AF(Auxiliary carry Flag)辅助进位标志 记录运算时第3位(半个字节)产生的进位置 有进位时1,否则置0。 PF(Parity Flag)奇偶标志 结果操作数中1的个数为偶数时置1，否则置0 控制标志位：
DF(Direction Flag)方向标志 在串处理指令中控制信息的方向 IF(Interrupt Flag)中断标志 TF(Trap Flag)陷井标志 test和cmp指令运行后都会设置标志位.
test test 是逻辑运算符</description></item><item><title>无锁小结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%97%A0%E9%94%81%E5%B0%8F%E7%BB%93/</guid><description>无锁小结 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/CAS与volatile|CAS与volatile]] API [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子整数|原子整数]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子引用|原子引用]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子数组|原子数组]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/字段更新器|字段更新器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/原子累加器|原子累加器]] [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/Unsafe|Unsafe]] 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/LongAdder|LongAdder]] 源码 伪共享</description></item><item><title>汇编快速入门</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid><description>汇编快速入门 寄存器 CS : IP 物理地址 = 段地址 X 10H + 偏移地址 物理地址: 200H(段地址) X 10H + 1F60H(偏移地址) = 21F60H 同一个物理地址可以由不同的段地址和偏移地址构成 段寄存器 CS: 代码段寄存器 (Code Segment) 主要关注此寄存器 DS: 数据段寄存器 (Data Segment) SS: 栈段寄存器 (Stach Segment) ES: 附加段寄存器 (Extra Segment) 程序执行 任意时刻, CPU 将 CS:IP 指向的内容作为即将执行的指令:
![[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/汇编/z-attachments/Pasted image 20220917151311.png]]
修改 CS:IP 控制流程 修改 CS 和 IP jmp 段地址:偏移地址 jmp 2AE3:3 -&amp;gt; 从 2AE33H 处读取指令 jmp 3:0B16 -&amp;gt; 从 00B46H 处读取指令 只修改 IP jmp 某合法寄存器 jmp bx 执行前: bx = 0B16H, CS = 2000H, IP = 0003H 执行后: BX = 0B16H, CS = 2000H, IP = 0B16H jmp bx 类似 mov IP, bx (把寄存器的值当作 IP) Winodws 下的汇编工具 准备 DOSBox 环境模拟器 debug.</description></item><item><title>管程总结</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%AE%A1%E7%A8%8B%E6%80%BB%E7%BB%93/</guid><description>管程总结 悲观锁
需要重点掌握的是
分析多[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/线程|线程]]访问共享资源时，哪些代码片段属于[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/临界区|临界区]] 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/synchronized|synchronized]] 互斥解决临界区的线程安全问题 掌握 synchronized 锁对象语法 掌握 synchronzied 加载成员方法和静态方法语法 掌握 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/wait&amp;amp;notify|wait&amp;amp;notify]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/同步|同步]]方法 使用 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/ReentrantLock|lock]] 互斥解决临界区的线程安全问题 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量 学会分析[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/变量的线程安全|变量的线程安全]]性、掌握常见[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/线程安全类|线程安全类]]的使用 了解线程[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活跃性|活跃性]]问题：[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/死锁|死锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/活锁|活锁]]、[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/饥饿|饥饿]] 应用方面 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 同步：使用 wait&amp;amp;notify 或 Lock 的条件变量来达到线程间通信效果 原理方面 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/monitor|monitor]]、synchronized 、wait&amp;amp;notify 原理 synchronized 进阶原理 [[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/park&amp;amp;unpark|park&amp;amp;unpark]] 原理 模式方面 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/保护性暂停|保护性暂停]] [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/异步|异步]]模式之[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/设计模式/生产者消费者|生产者消费者]] 同步模式之[[2_0_2-计算机科学/2_0_2_1_2_0-软件语言/Java/2-并发编程/顺序控制|顺序控制]]</description></item><item><title>线程安全集合类概述</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_0-%E8%BD%AF%E4%BB%B6%E8%AF%AD%E8%A8%80/Java/2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0/</guid><description>线程安全集合类概述 ![[z-oblib/z2-attachments/Pasted image 20220612211057.png]]</description></item><item><title>继承和委派的选择</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_1-%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E5%AD%A6/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A7%94%E6%B4%BE%E7%9A%84%E9%80%89%E6%8B%A9/</guid><description>继承和委派的选择 想要表达 is-a 关系，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]。 想要将类传递给已有的API，使用继承。 想要增强A，但A不能再被[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/继承|继承]]，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。 想要某方法并且不想覆盖该方法，使用[[2_0_2-计算机科学/2_0_2_1_2_1-软件方法学/编程思想/委派|委派]]。</description></item><item><title>进程间通讯</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_2_3-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/2_0_2_1_2_3_1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/</guid><description>进程间通讯 单机操作系统上的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/进程|进程]]可以分为两类：
独立进程：这类进程不会和其它进程有任何交[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/流|流]]。 协作进程：两个或多个进程之间需要交流。 例如，ls /tmp命令是独立运行的，不依赖于其它进程，而cat a.log | grep 'abc'命令中的两个进程是协作进程，grep进程依赖于cat进程，grep只有等待到了cat进程产生的数据才能继续执行下去。
对于单机上不同进程之间的协作，各进程之间需要进行数据的交流，这种行为称为进程间通信（Inter-process communication，IPC），即进程与进程的通信。
除了单机上的多个进程可能需要进程间通信，多计算机之间的进程有时候也需要进行进程间的通信，这很常见，例如本机上的QQ客户端进程需要和腾讯的QQ服务器上的进程进行数据传输，浏览器浏览网页时，浏览器进程需要和网页所在的服务端进程进行数据传输，等等。
进程间通信的方式有很多种。从广义上讲，只要进程间能共享数据或传递数据就算是进程间通信。下面列出常见的进程间通信方式：
进程间通信方式 描述 文件（File） 多个进程可以获取到同一个文件的数据 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/管道 | 管道]]（pipe） 单方向传输数据的管道，只能一方写，另一方读 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/套接字|套接字]]（Socket） 多机进程间通信，当然也可以在本机让两个进程使用socket通信 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/Unix域套接字|Unix域套接字]]（Unix Domain Socket） 单机进程间通过域套接字模式通信，可看作是双向管道 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/共享内存|共享内存]]（Shared Memory，shm） 在物理内存上划分一片内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/文件映射|文件映射]]（Memory-maped file） 将文件中的一段数据映射到物理内存，多个进程共享这片内存 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/消息队列|消息队列]]（Message Queue） 某进程将消息放入消息队列，其它进程从队列中接收消息 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号|信号]]（Signal） 通过发送某些信号通知其它进程，进程收到信号做出不同的处理 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/信号量|信号量]]（Semaphore） 就是信号灯。应用方式有多种，其作用概括起来就是，根据是否有信号灯或信号灯的数量多少来决定是否阻塞进程 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/锁|锁]]（Lock） 对资源上锁，如果资源已被某进程锁住，则其它进程想要修改甚至读取这些资源，都将被阻塞，直到锁被打开。</description></item><item><title>逆向wp-Easy-CrackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-CrackMe/</guid><description>逆向wp-Easy-CrackMe 题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 windows 窗体程序 没什么输入限制 错误返回字符串 Incorrect Password ![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214007.png]]
反编译 程序是 32 位的.
定位关键函数 通过字符串 Incorrect Password 定位关键函数, F5 分析 C 代码.
关键函数分析 变量名根据用途重命名过.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int __cdecl sub_401080(HWND hDlg) { int result; // eax@5 CHAR c1; // [sp+4h] [bp-64h]@1 char c2; // [sp+5h] [bp-63h]@1 char c3; // [sp+6h] [bp-62h]@2 char c4; // [sp+8h] [bp-60h]@3 __int16 v6; // [sp+65h] [bp-3h]@1 char v7; // [sp+67h] [bp-1h]@1 c1 = 0; memset(&amp;amp;c2, 0, 0x60u); v6 = 0; v7 = 0; GetDlgItemTextA(hDlg, 1000, &amp;amp;c1, 100); if ( c2 == &amp;#39;a&amp;#39; &amp;amp;&amp;amp; !</description></item><item><title>逆向wp-Easy-Keygen</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Keygen/</guid><description>逆向wp-Easy-Keygen 基础的异或加密题.
http://gokoucat.ys168.com/
题目要求 Find the Name when the Serial is 5B134977135E7D13
黑盒测试 简单运行一下程序, 发现是 Windows 下的命令行程序, 要求输入 name 和 serial, 程序判断是否正确, 错误直接跳出.
反编译 直接放 IDA 里反编译.
定位函数 通过搜索字符串 Input Name: 或Input Serial:, 查找交叉应用来定位主函数.
分析函数 这里没有什么坑, 找到主函数直接 F5 看 C 代码:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // ebp@1 signed int i; // esi@1 int result; // eax@6 char v6; // [sp+Ch] [bp-130h]@1 char v7; // [sp+Dh] [bp-12Fh]@1 char v8; // [sp+Eh] [bp-12Eh]@1 char v9; // [sp+10h] [bp-12Ch]@1 char v10; // [sp+11h] [bp-12Bh]@1 __int16 v11; // [sp+71h] [bp-CBh]@1 char v12; // [sp+73h] [bp-C9h]@1 char v13; // [sp+74h] [bp-C8h]@1 char v14; // [sp+75h] [bp-C7h]@1 __int16 v15; // [sp+139h] [bp-3h]@1 char v16; // [sp+13Bh] [bp-1h]@1 v9 = 0; v13 = 0; memset(&amp;amp;v10, 0, 0x60u); v11 = 0; v12 = 0; memset(&amp;amp;v14, 0, 0xC4u); v15 = 0; v16 = 0; v6 = 16; v7 = 32; v8 = 48; sub_4011B9(aInputName); scanf(aS, &amp;amp;v9); v3 = 0; for ( i = 0; v3 &amp;lt; (signed int)strlen(&amp;amp;v9); ++i ) { if ( i &amp;gt;= 3 ) i = 0; sprintf(&amp;amp;v13, aS02x, &amp;amp;v13, *(&amp;amp;v9 + v3++) ^ *(&amp;amp;v6 + i)); } memset(&amp;amp;v9, 0, 0x64u); sub_4011B9(aInputSerial); scanf(aS, &amp;amp;v9); if ( !</description></item><item><title>逆向wp-Easy-Re</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-Re/</guid><description>逆向wp-Easy-Re bugku 逆向第二题.
定位关键函数 通过 ida 反编译, 很容易定位关键函数, 本题结构十分简单:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax __int128 v5; // [esp+0h] [ebp-44h] __int64 v6; // [esp+10h] [ebp-34h] int v7; // [esp+18h] [ebp-2Ch] __int16 v8; // [esp+1Ch] [ebp-28h] char v9; // [esp+20h] [ebp-24h] _mm_storeu_si128((__m128i *)&amp;amp;v5, _mm_loadu_si128((const __m128i *)&amp;amp;xmmword_413E34)); // &amp;amp;xmmword_413E34 即被比较数据 flag v7 = 0; v6 = qword_413E44; v8 = 0; printf(&amp;#34;欢迎来到DUTCTF呦\n&amp;#34;); printf(&amp;#34;这是一道很可爱很简单的逆向题呦\n&amp;#34;); printf(&amp;#34;输入flag吧:&amp;#34;); scanf(&amp;#34;%s&amp;#34;, &amp;amp;v9); v3 = strcmp((const char *)&amp;amp;v5, &amp;amp;v9); // 将输入与已有数据进行比较, if ( v3 ) v3 = -(v3 &amp;lt; 0) | 1; if ( v3 ) printf(aFlag_0); else printf((const char *)&amp;amp;unk_413E90); system(&amp;#34;pause&amp;#34;); return 0; } 解析字符串 对 &amp;amp;xmmword_413E34 位置的数据进行分析, 发现此处就是 flag 的逆序存储, 直接右键显示为 字符, 然后手工反向输入即可.</description></item><item><title>逆向wp-Easy-UnpackMe</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Easy-UnpackMe/</guid><description>逆向wp-Easy-UnpackMe 脱壳入门题, 找程序 EOP (入口点).
题目在网络对应目录中: http://gokoucat.ys168.com/
题目要求 Find the OEP, ex) 00401000
黑盒测试 双击打开, 是一个空白的 Windows 窗体程序, 没什么特别的.
OD 调试 通过使用 OD 动态调试, 寻找程序的 EOP, 使用的方法是单步跟踪.
单步跟踪 参考视频
程序载入 OD 后即开始单步步过 (F8) 调试
遇到向下跳转的一律执行
遇到向上跳转的一律不执行
选中下一条指令 按 F4 执行到选中位置 或者在下一条指令处下断点, 再继续程序, 到达断点后删除断点 (不常用) 直到遇到地址跳跃幅度很大的地址
找到这样的地址, 基本就是程序的 OEP 了, 注意在 OD 中, 红色的线代表跳转已经实现, 绿色的线代表跳转未实现.
![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917214517.</description></item><item><title>逆向wp-ebCTF-Teaser-BIN100-Dice</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-ebCTF-Teaser-BIN100-Dice/</guid><description>逆向wp-ebCTF-Teaser-BIN100-Dice 杭电 CTF 平台逆向第一题.
http://gokoucat.ys168.com/
定位关键函数 使用 IDA 字符串搜索 定位回显字符串被交叉引用的位置 得到关键函数中的重要片段如下:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) { .</description></item><item><title>逆向wp-keylead</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-keylead/</guid><description>逆向wp-keylead 杭电 CTF 平台逆向第二题.
题目在网络对应目录中: http://gokoucat.ys168.com/
文件分析 通过在 lunux 环境下, 使用 file keylead 发现是一个压缩文件, 解压后得到可执行文件.
1 2 3 file keylead keylead: XZ compressed data 函数分析 通过字符串定位的方法, 找到主函数.
主函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 signed __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax unsigned int i_rand_n1; // ST14_4 signed __int64 result; // rax unsigned int i_rand_n5; // [rsp+4h] [rbp-1Ch] unsigned int i_rand_n4; // [rsp+8h] [rbp-18h] unsigned int i_rand_n3; // [rsp+Ch] [rbp-14h] unsigned int i_rand_n2; // [rsp+10h] [rbp-10h] int start_time; // [rsp+18h] [rbp-8h] puts(&amp;#34;hi all ----------------------&amp;#34;); puts(&amp;#34;Welcome to dice game!</description></item><item><title>逆向wp-Reverse-100</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-Reverse-100/</guid><description>逆向wp-Reverse-100 杭电 CTF 平台逆向第四题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位关键函数 老套路, string 查找, 不多 BB.
解析函数 这个函数比较简单, key 和 判断流程在一个简单的函数中直接展示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __cdecl main(int argc, const char **argv, const char **envp) { signed int i; // edi char s_input; // [esp+10h] [ebp-104h] char Dst; // [esp+11h] [ebp-103h] s_input = 0; memset(&amp;amp;Dst, 0, 0xFFu); printf(&amp;#34;please input ns-ctf password: &amp;#34;); scanf_s(&amp;#34;%s&amp;#34;, &amp;amp;s_input); for ( i = 1; strncmp(&amp;#34;nsF0cuS!</description></item><item><title>逆向wp-reverse02</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-reverse02/</guid><description>逆向wp-reverse02 杭电 CTF 平台逆向第三题.
题目在网络对应目录中: http://gokoucat.ys168.com/
定位函数 程序时一个 win32 的窗口程序, 按钮是灰色的.
老套路, 根据字符串来定位函数.
这题可以找到一个内容是 flag:{NSCTF_md57e0cad17016b0&amp;gt;?45?f7c&amp;gt;0&amp;gt;4a&amp;gt;1c3a0} 的字符串, 直接提交错误, 看来没这么简单.
交叉引用 对该字符串的交叉引用有两处, 分别分析发现其中一个应该为主要的函数:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int __thiscall sub_401070(_BYTE *this) { int v1; // edx int v2; // esi int result; // eax if ( ((unsigned __int8)byte_403028 ^ 7) !</description></item><item><title>逆向wp-WannaLOL2</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-WannaLOL2/</guid><description>逆向wp-WannaLOL2 逆向入门题.
题目在网络对应目录中: http://gokoucat.ys168.com/
黑盒测试 拿到题目第一步, 就是运行软件进行测试
判断软件平台 观察输入限制 观察输出信息 本题是一道 Windows 平台下的窗体程序, 任意输入内容进行测试:
![[2_0_2-计算机科学/2_0_2_1_3_0-网络安全/二进制安全/逆向/writeup/z-attachments/Pasted image 20220917215724.png]]
随意输入后, 发现程序对输入的内容和长度没有做限制, 输入不通过时返回字符串 error !
返回错的的字符串就是定位关键函数的一个突破点.
反编译 使用 IDA 软件对程序进行反编译.
1 无法确认程序位数时, 统一先用 X86 的 IDA 打开, 观察是否报错来确定是多少位的程序. IDA 视图配置 打开机器码显示 打开 16 进制视图 (Hex-View) 打开字符串视图 (Strings windows) 定位关键函数 通过输出字符串 error ! 定位程序的关键函数.
搜索字符串定位 在 strings windows 中按 ctrl + F 搜索字符串 error ! 双击结果中匹配的内容, 跳转到对应的数据位置 定位字符串引用位置 光标放在字符串的变量名处, 按 x 调出交叉应用窗口, 双击条目跳转到对应函数</description></item><item><title>逆向wp-游戏过关</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/%E9%80%86%E5%90%91/writeup/%E9%80%86%E5%90%91wp-%E6%B8%B8%E6%88%8F%E8%BF%87%E5%85%B3/</guid><description>逆向wp-游戏过关 bugku 逆向第三题.
http://gokoucat.ys168.com/
定位关键函数 通过对字符串 done!!! the flag is 进行交叉引用的定位, 找到关键函数的位置.
1 2 3 4 5 6 7 8 9 10 11 12 ... if ( byte_532E28[0] == 1 &amp;amp;&amp;amp; byte_532E28[1] == 1 &amp;amp;&amp;amp; byte_532E28[2] == 1 &amp;amp;&amp;amp; byte_532E28[3] == 1 &amp;amp;&amp;amp; byte_532E28[4] == 1 &amp;amp;&amp;amp; byte_532E28[5] == 1 &amp;amp;&amp;amp; byte_532E28[6] == 1 &amp;amp;&amp;amp; byte_532E28[7] == 1 ) { sub_457AB4(); //关键函数 } 分析函数 函数内部是对已有的数据进行处理并输出</description></item><item><title>针对延迟绑定的攻击</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_3_0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/pwn/%E9%92%88%E5%AF%B9%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E6%94%BB%E5%87%BB/</guid><description>针对延迟绑定的攻击  2015 年的论文 “How the [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/ELF|ELF]] Ruined Christmas” 中提出的。
强迫动态装载器解析请求的函数。
![[z-oblib/z2-attachments/Pasted image 20220911020331.png]] ![[z-oblib/z2-attachments/Pasted image 20220911020936.png]]
图a中，因为动态转载器是从 .dynamic 段的 DT_STRTAB 条目中获得 .dynstr 段的地址的，而 DT_STRTAB 条目的位置已知，默认情况下也可写。所以攻击者能够改写 DT_STRTAB 条目的内容，欺骗动态装载器，让它以为 .dynstr 段在 .bss 段中，并在那里伪造一个假的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/字符串表|字符串表]]。当它尝试解析 printf 时会使用不同的[[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/基地址|基地址]]来寻找函数名，最终执行的是 execve。这种方式非常简单，但仅当二进制程序的 .dynamic 段可写时有效。 图b中，我们已经知道 [[2_0_2-计算机科学/2_0_2_1_2_3-软件系统/2_0_2_1_2_3_1-操作系统/linux/_dl_runtime_resolve|_dl_runtime_resolve]] 的第二个参数是 Elf_Rel 条目在 .rel.plt 段中的偏移，动态装载器将这个值加上 .rel.plt 的基址来得到目标结构体的绝对位置。然后当传递给 _dl_runtime_resolve 的参数 reloc_index 超出了 .rel.plt 段，并最终落在 .bss 段中时，攻击者可以在该位置伪造了一个 Elf_Rel 结构，并填写 r_offset 的值为一个可写的内存地址来将解析后的函数地址写在那里，同理 r_info 也会是一个将动态装载器导向到攻击者控制内存的下标。这个下标就指向一个位于它后面的 Elf_Sym 结构，而 Elf_Sym 结构中的 st_name 同样超出了 .dynsym 段。这样这个符号就会包含一个相对于 .</description></item><item><title>锁存器</title><link>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://harbor.mffseal.top/2_0_2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2_0_2_1_1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/0-%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6/%E9%94%81%E5%AD%98%E5%99%A8/</guid><description>锁存器 我们将能够存储一个状态的电路叫做锁存器。设想一个电路，初始输入为0，输出为0；然后输入为1，输出变为1（状态发生了变化）。对于迄今为止所有的电路，我们都能保证当输入回到0时，输出也会同时归0；但这个电路不同，它保持在了1，也就是状态没有发生变化，而是被存储了下来。此时，这种电路便可以被叫做锁存器。
为了让电路拥有自己的”状态“，必须要有某种”反馈“机制，将输出输入形成一个闭环。
分类 [[2_0_2-计算机科学/2_0_2_1_1-计算机硬件/0-基础元器件/RS锁存器|RS锁存器]]</description></item></channel></rss>